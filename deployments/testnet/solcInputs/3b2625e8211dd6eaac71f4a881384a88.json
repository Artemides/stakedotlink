{
  "language": "Solidity",
  "sources": {
    "contracts/airdrop/MerkleDistributor.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title MerkleDistributor\n * @notice Handles token airdrops from an unlimited amount of token rewards\n * @dev Based on https://github.com/Uniswap/merkle-distributor but modified to handle multiple airdrops concurrently\n */\ncontract MerkleDistributor is Ownable {\n    using SafeERC20 for IERC20;\n\n    uint public constant TIME_LIMIT = 90 days;\n\n    struct Distribution {\n        address token;\n        bool timeLimitEnabled;\n        bool isPaused;\n        uint timeOfLastUpdate;\n        bytes32 merkleRoot;\n        uint totalAmount;\n        mapping(address => uint256) claimed;\n    }\n    address[] public tokens;\n    mapping(address => Distribution) public distributions;\n\n    event Claimed(address indexed token, uint256 index, address indexed account, uint256 amount);\n    event DistributionAdded(uint256 indexed tokenIndex, address indexed token, uint totalAmount);\n    event DistributionUpdated(address indexed token, uint additionalAmount);\n\n    modifier distributionExists(address _token) {\n        require(distributions[_token].token != address(0), \"MerkleDistributor: Distribution does not exist.\");\n        _;\n    }\n\n    /**\n     * @notice returns the total amount that an account has claimed from a distribution\n     * @param _token token address\n     * @param _account address of the account to return claimed amount for\n     **/\n    function getClaimed(address _token, address _account) external view distributionExists(_token) returns (uint) {\n        return distributions[_token].claimed[_account];\n    }\n\n    /**\n     * @notice add multiple token distributions\n     * @param _tokens the list of token addresses to add\n     * @param _merkleRoots list of merkle roots for each distribution\n     * @param _totalAmounts list of total distribution amounts for each token\n     **/\n    function addDistributions(\n        address[] calldata _tokens,\n        bytes32[] calldata _merkleRoots,\n        uint[] calldata _totalAmounts\n    ) external onlyOwner {\n        require(\n            _tokens.length == _merkleRoots.length && _tokens.length == _totalAmounts.length,\n            \"MerkleDistributor: Array lengths need to match.\"\n        );\n\n        for (uint i = 0; i < _tokens.length; i++) {\n            addDistribution(_tokens[i], _merkleRoots[i], _totalAmounts[i]);\n        }\n    }\n\n    /**\n     * @notice add a token distribution\n     * @param _token token address\n     * @param _merkleRoot merkle root for token distribution\n     * @param _totalAmount total distribution amount\n     **/\n    function addDistribution(\n        address _token,\n        bytes32 _merkleRoot,\n        uint _totalAmount\n    ) public onlyOwner {\n        require(distributions[_token].token == address(0), \"MerkleDistributor: Distribution is already added.\");\n\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _totalAmount);\n        tokens.push(_token);\n\n        distributions[_token].token = _token;\n        distributions[_token].merkleRoot = _merkleRoot;\n        distributions[_token].totalAmount = _totalAmount;\n        distributions[_token].timeOfLastUpdate = block.timestamp;\n\n        emit DistributionAdded(tokens.length - 1, _token, _totalAmount);\n    }\n\n    /**\n     * @notice update multiple token distributions\n     * @param _tokens the list of token addresses to update\n     * @param _merkleRoots list of updated merkle roots for the distributions\n     * @param _additionalAmounts list of total additional distribution amounts for each token\n     **/\n    function updateDistributions(\n        address[] calldata _tokens,\n        bytes32[] calldata _merkleRoots,\n        uint[] calldata _additionalAmounts\n    ) external onlyOwner {\n        require(\n            _tokens.length == _merkleRoots.length && _tokens.length == _additionalAmounts.length,\n            \"MerkleDistributor: Array lengths need to match.\"\n        );\n\n        for (uint i = 0; i < _tokens.length; i++) {\n            updateDistribution(_tokens[i], _merkleRoots[i], _additionalAmounts[i]);\n        }\n    }\n\n    /**\n     * @notice update a token distribution\n     * @dev merkle root should be updated to reflect additional amount - the amount for each\n     * account should be incremented by any additional allocation and any new accounts should be added\n     * to the tree\n     * @param _token token address\n     * @param _merkleRoot updated merkle root for token distribution\n     * @param _additionalAmount total additional distribution amount\n     **/\n    function updateDistribution(\n        address _token,\n        bytes32 _merkleRoot,\n        uint _additionalAmount\n    ) public onlyOwner distributionExists(_token) {\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _additionalAmount);\n\n        distributions[_token].merkleRoot = _merkleRoot;\n        distributions[_token].totalAmount += _additionalAmount;\n        distributions[_token].timeOfLastUpdate = block.timestamp;\n\n        emit DistributionUpdated(_token, _additionalAmount);\n    }\n\n    /**\n     * @notice claim multiple token distributions\n     * @param _tokens list of token address\n     * @param _indexes list of indexes of the claims within the distributions\n     * @param _account address of the account to claim for\n     * @param _amounts list of lifetime amounts of the tokens allocated to account\n     * @param _merkleProofs list of merkle proofs for the token claims\n     **/\n    function claimDistributions(\n        address[] calldata _tokens,\n        uint256[] calldata _indexes,\n        address _account,\n        uint256[] calldata _amounts,\n        bytes32[][] calldata _merkleProofs\n    ) external {\n        require(\n            _tokens.length == _indexes.length && _tokens.length == _amounts.length && _tokens.length == _merkleProofs.length,\n            \"MerkleDistributor: Array lengths need to match.\"\n        );\n\n        for (uint i = 0; i < _tokens.length; i++) {\n            claimDistribution(_tokens[i], _indexes[i], _account, _amounts[i], _merkleProofs[i]);\n        }\n    }\n\n    /**\n     * @notice claim a token distribution\n     * @param _token token address\n     * @param _index index of the claim within the distribution\n     * @param _account address of the account to claim for\n     * @param _amount lifetime amount of the token allocated to account\n     * @param _merkleProof the merkle proof for the token claim\n     **/\n    function claimDistribution(\n        address _token,\n        uint256 _index,\n        address _account,\n        uint256 _amount,\n        bytes32[] calldata _merkleProof\n    ) public distributionExists(_token) {\n        require(!distributions[_token].isPaused, \"MerkleDistributor: Distribution is paused.\");\n        Distribution storage distribution = distributions[_token];\n\n        bytes32 node = keccak256(abi.encodePacked(_index, _account, _amount));\n        require(MerkleProof.verify(_merkleProof, distribution.merkleRoot, node), \"MerkleDistributor: Invalid proof.\");\n\n        require(distribution.claimed[_account] < _amount, \"MerkleDistributor: No claimable tokens.\");\n\n        uint amount = _amount - distribution.claimed[_account];\n        distribution.claimed[_account] = _amount;\n        IERC20(_token).safeTransfer(_account, amount);\n\n        emit Claimed(_token, _index, _account, amount);\n    }\n\n    /**\n     * @notice withdraws unclaimed tokens\n     * @dev merkle root should be updated to reflect current state of claims - the amount for each\n     * account should be equal to it's claimed amount\n     * @param _token token address\n     * @param _merkleRoot updated merkle root\n     * @param _totalAmount updated total amount\n     **/\n    function withdrawUnclaimedTokens(\n        address _token,\n        bytes32 _merkleRoot,\n        uint _totalAmount\n    ) external onlyOwner distributionExists(_token) {\n        require(distributions[_token].isPaused, \"MerkleDistributor: Distribution is not paused.\");\n\n        IERC20 token = IERC20(_token);\n        uint balance = token.balanceOf(address(this));\n        if (balance > 0) {\n            token.safeTransfer(msg.sender, balance);\n        }\n\n        distributions[_token].merkleRoot = _merkleRoot;\n        distributions[_token].totalAmount = _totalAmount;\n        distributions[_token].isPaused = false;\n    }\n\n    /**\n     * @notice pauses a token distribution for withdrawal of unclaimed tokens\n     * @dev must be called before withdrawUnlclaimedTokens to ensure state doesn't change\n     * while the new merkle root is calculated\n     * @param _token token address\n     **/\n    function pauseForWithdrawal(address _token) external onlyOwner distributionExists(_token) {\n        require(distributions[_token].timeLimitEnabled, \"MerkleDistributor: Time limit is not enabled.\");\n        require(\n            block.timestamp > distributions[_token].timeOfLastUpdate + TIME_LIMIT,\n            \"MerkleDistributor: Time limit has not been reached.\"\n        );\n\n        distributions[_token].isPaused = true;\n    }\n\n    /**\n     * @notice enables/disables the time limit for a token\n     * @param _token token addresse\n     * @param _enabled whether to enable or disable the limit\n     **/\n    function setTimeLimitEnabled(address _token, bool _enabled) external onlyOwner distributionExists(_token) {\n        require(distributions[_token].timeLimitEnabled != _enabled, \"MerkleDistributor: Value already set.\");\n        distributions[_token].timeLimitEnabled = _enabled;\n        if (_enabled) {\n            distributions[_token].timeOfLastUpdate = block.timestamp;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The proofs can be generated using the JavaScript library\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\n *\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     *\n     * _Available since v4.7._\n     */\n    function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     *\n     * _Available since v4.7._\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be proved to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and the sibling nodes in `proof`,\n     * consuming from one or the other at each step according to the instructions given by\n     * `proofFlags`.\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "contracts/linkStaking/base/VaultControllerStrategy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\n\nimport \"../../core/interfaces/IERC677.sol\";\nimport \"../../core/base/Strategy.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../interfaces/IStaking.sol\";\n\n/**\n * @title Vault Controller Strategy\n * @notice Base strategy for managing multiple Chainlink staking vaults\n */\nabstract contract VaultControllerStrategy is Strategy {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    struct Fee {\n        address receiver;\n        uint basisPoints;\n    }\n\n    IStaking public stakeController;\n    Fee[] internal fees;\n\n    address public vaultImplementation;\n\n    IVault[] internal vaults;\n    uint internal totalDeposits;\n    uint internal bufferedDeposits;\n    uint public minDepositThreshold;\n\n    uint[10] private __gap;\n\n    event MigratedVaults(uint startIndex, uint numVaults, bytes data);\n    event UpgradedVaults(uint startIndex, uint numVaults, bytes data);\n    event SetMinDepositThreshold(uint minDepositThreshold);\n    event SetVaultImplementation(address vaultImplementation);\n\n    function __VaultControllerStrategy_init(\n        address _token,\n        address _stakingPool,\n        address _stakeController,\n        address _vaultImplementation,\n        uint _minDepositThreshold,\n        Fee[] memory _fees\n    ) public onlyInitializing {\n        __Strategy_init(_token, _stakingPool);\n\n        require(_isContract(_vaultImplementation), \"Vault implementation address must belong to a contract\");\n        vaultImplementation = _vaultImplementation;\n\n        stakeController = IStaking(_stakeController);\n        minDepositThreshold = _minDepositThreshold;\n        for (uint i = 0; i < _fees.length; i++) {\n            fees.push(_fees[i]);\n        }\n    }\n\n    /**\n     * @notice returns a list of all vaults\n     * @return vaults list of vault addresses\n     */\n    function getVaults() external view returns (IVault[] memory) {\n        return vaults;\n    }\n\n    /**\n     * @notice deposits tokens into this strategy\n     * @param _amount amount to deposit\n     */\n    function deposit(uint256 _amount) external onlyStakingPool {\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n        totalDeposits += _amount;\n        bufferedDeposits += _amount;\n    }\n\n    /**\n     * @notice withdrawals are not yet implemented in this iteration of Chainlink staking\n     */\n    function withdraw(uint256) external view onlyStakingPool {\n        revert(\"withdrawals not yet implemented\");\n    }\n\n    function checkUpkeep(bytes calldata) external view returns (bool, bytes memory) {\n        if (!stakeController.isActive() || stakeController.isPaused()) {\n            return (false, bytes(\"\"));\n        }\n        if (bufferedDeposits < minDepositThreshold) {\n            return (false, bytes(\"\"));\n        }\n\n        (, uint vaultMaxDeposits) = getVaultDepositLimits();\n        uint firstNonFullVault;\n\n        for (uint i = 0; i < vaults.length; i++) {\n            uint vaultDeposits = vaults[i].getPrincipalDeposits();\n\n            if (vaultDeposits < vaultMaxDeposits) {\n                firstNonFullVault = i;\n                break;\n            }\n        }\n\n        return (true, abi.encode(firstNonFullVault));\n    }\n\n    /**\n     * @notice deposits buffered tokens into vaults if buffered balance exceeds minDepositThreshold\n     * @param _performData abi encoded index of first non-full vault\n     */\n    function performUpkeep(bytes calldata _performData) external {\n        require(bufferedDeposits >= minDepositThreshold, \"Minimum deposit threshold has not been met\");\n        uint startIndex = abi.decode(_performData, (uint));\n        depositBufferedTokens(startIndex);\n    }\n\n    /**\n     * @notice deposits buffered tokens into vaults\n     * @param _startIndex index of first non-full vault\n     */\n    function depositBufferedTokens(uint _startIndex) public {\n        (uint vaultMinDeposits, uint vaultMaxDeposits) = getVaultDepositLimits();\n        require(\n            _startIndex == vaults.length - 1 || vaults[_startIndex].getPrincipalDeposits() < vaultMaxDeposits,\n            \"Cannot deposit into vault that is full\"\n        );\n        require(\n            _startIndex == 0 || vaults[_startIndex - 1].getPrincipalDeposits() >= vaultMaxDeposits,\n            \"Cannot deposit into vault if lower index vault is not full\"\n        );\n\n        _depositBufferedTokens(_startIndex, bufferedDeposits, vaultMinDeposits, vaultMaxDeposits);\n    }\n\n    /**\n     * @notice returns the deposit change (positive/negative) since deposits were last updated\n     * @return int deposit change\n     */\n    function depositChange() public view returns (int) {\n        uint totalBalance = token.balanceOf(address(this));\n        for (uint i = 0; i < vaults.length; i++) {\n            totalBalance += vaults[i].getTotalDeposits();\n        }\n        return int(totalBalance) - int(totalDeposits);\n    }\n\n    /**\n     * @notice updates the total amount deposited for reward distribution\n     * @return receivers list of fee receivers\n     * @return amounts list of fee amounts\n     */\n    function updateDeposits() external onlyStakingPool returns (address[] memory receivers, uint[] memory amounts) {\n        receivers = new address[](fees.length);\n        amounts = new uint[](fees.length);\n\n        for (uint i = 0; i < fees.length; i++) {\n            receivers[i] = fees[i].receiver;\n            amounts[i] = fees[i].basisPoints;\n        }\n\n        int balanceChange = depositChange();\n        if (balanceChange > 0) {\n            totalDeposits += uint(balanceChange);\n        } else if (balanceChange < 0) {\n            totalDeposits -= uint(balanceChange * -1);\n        }\n    }\n\n    /**\n     * @notice the amount of total deposits as tracked in this strategy\n     * @return uint total deposited\n     */\n    function getTotalDeposits() public view override returns (uint) {\n        return totalDeposits;\n    }\n\n    /**\n     * @notice returns the vault deposit limits\n     * @return minimum minimum amount of deposits that a vault can hold\n     * @return maximum maximum amount of deposits that a vault can hold\n     */\n    function getVaultDepositLimits() public view virtual returns (uint, uint);\n\n    /**\n     * @notice migrates vaults to a new stake controller\n     * @param _startIndex index of first vault to migrate\n     * @param _numVaults number of vaults to migrate starting at _startIndex\n     * @param _data migration data\n     */\n    function migrateVaults(\n        uint _startIndex,\n        uint _numVaults,\n        bytes calldata _data\n    ) external onlyOwner {\n        for (uint i = _startIndex; i < _startIndex + _numVaults; i++) {\n            vaults[i].migrate(_data);\n        }\n        emit MigratedVaults(_startIndex, _numVaults, _data);\n    }\n\n    /**\n     * @notice upgrades vaults to a new implementation contract\n     * @param _startIndex index of first vault to upgrade\n     * @param _numVaults number of vaults to upgrade starting at _startIndex\n     * @param _data optional encoded function call to be executed after upgrade\n     */\n    function upgradeVaults(\n        uint _startIndex,\n        uint _numVaults,\n        bytes memory _data\n    ) external onlyOwner {\n        for (uint i = _startIndex; i < _startIndex + _numVaults; i++) {\n            _upgradeVault(i, _data);\n        }\n        emit UpgradedVaults(_startIndex, _numVaults, _data);\n    }\n\n    /**\n     * @notice adds a new fee\n     * @param _receiver receiver of fee\n     * @param _feeBasisPoints fee in basis points\n     **/\n    function addFee(address _receiver, uint _feeBasisPoints) external onlyOwner {\n        fees.push(Fee(_receiver, _feeBasisPoints));\n    }\n\n    /**\n     * @notice updates an existing fee\n     * @param _index index of fee\n     * @param _receiver receiver of fee\n     * @param _feeBasisPoints fee in basis points\n     **/\n    function updateFee(\n        uint _index,\n        address _receiver,\n        uint _feeBasisPoints\n    ) external onlyOwner {\n        require(_index < fees.length, \"Fee does not exist\");\n\n        if (_feeBasisPoints == 0) {\n            fees[_index] = fees[fees.length - 1];\n            fees.pop();\n        } else {\n            fees[_index].receiver = _receiver;\n            fees[_index].basisPoints = _feeBasisPoints;\n        }\n    }\n\n    /**\n     * @notice sets the minimum buffered token balance needed to initiate a deposit into vaults\n     * @dev should always be >= to minimum vault deposit limit\n     * @param _minDepositThreshold mimumum token balance\n     **/\n    function setMinDepositThreshold(uint _minDepositThreshold) external onlyOwner {\n        (uint vaultMinDeposits, ) = getVaultDepositLimits();\n        require(_minDepositThreshold >= vaultMinDeposits, \"Must be >= to minimum vault deposit limit\");\n        minDepositThreshold = _minDepositThreshold;\n        emit SetMinDepositThreshold(_minDepositThreshold);\n    }\n\n    /**\n     * @notice sets a new vault implementation contract to be used when deploying/upgrading vaults\n     * @param _vaultImplementation address of implementaion contract\n     */\n    function setVaultImplementation(address _vaultImplementation) external onlyOwner {\n        require(_isContract(_vaultImplementation), \"Address must belong to a contract\");\n        vaultImplementation = _vaultImplementation;\n        emit SetVaultImplementation(_vaultImplementation);\n    }\n\n    /**\n     * @notice deposits buffered tokens into vaults\n     * @param _startIndex index of first vault to deposit into\n     * @param _toDeposit amount to deposit\n     * @param _vaultMinDeposits minimum amount of deposits that a vault can hold\n     * @param _vaultMaxDeposits minimum amount of deposits that a vault can hold\n     */\n    function _depositBufferedTokens(\n        uint _startIndex,\n        uint _toDeposit,\n        uint _vaultMinDeposits,\n        uint _vaultMaxDeposits\n    ) internal virtual;\n\n    /**\n     * @notice deposits tokens into vaults\n     * @param _startIndex index of first vault to deposit into\n     * @param _toDeposit amount to deposit\n     * @param _minDeposits minimum amount of deposits that a vault can hold\n     * @param _maxDeposits minimum amount of deposits that a vault can hold\n     */\n    function _depositToVaults(\n        uint _startIndex,\n        uint _toDeposit,\n        uint _minDeposits,\n        uint _maxDeposits\n    ) internal returns (uint) {\n        uint toDeposit = _toDeposit;\n        for (uint i = _startIndex; i < vaults.length; i++) {\n            IVault vault = vaults[i];\n            uint deposits = vault.getPrincipalDeposits();\n            uint canDeposit = _maxDeposits - deposits;\n\n            if (deposits < _minDeposits && toDeposit < (_minDeposits - deposits)) {\n                break;\n            } else if (toDeposit > canDeposit) {\n                vault.deposit(canDeposit);\n                toDeposit -= canDeposit;\n            } else {\n                vault.deposit(toDeposit);\n                toDeposit = 0;\n                break;\n            }\n        }\n        return _toDeposit - toDeposit;\n    }\n\n    /**\n     * @notice deploys a new vault\n     * @param _data optional encoded function call to be executed after deployment\n     */\n    function _deployVault(bytes memory _data) internal {\n        address vault = address(new ERC1967Proxy(vaultImplementation, _data));\n        token.safeApprove(vault, type(uint).max);\n        vaults.push(IVault(vault));\n    }\n\n    /**\n     * @notice upgrades a vault\n     * @param _vaultIdx index of vault to upgrade\n     * @param _data optional encoded function call to be executed after upgrade\n     */\n    function _upgradeVault(uint _vaultIdx, bytes memory _data) internal {\n        IVault vault = vaults[_vaultIdx];\n        if (_data.length == 0) {\n            vault.upgradeTo(vaultImplementation);\n        } else {\n            vault.upgradeToAndCall(vaultImplementation, _data);\n        }\n    }\n\n    /**\n     * @notice returns whether an address belongs to a contract\n     * @param _address address to check\n     * @return isContract true if address is contract\n     */\n    function _isContract(address _address) private view returns (bool) {\n        uint256 length;\n        assembly {\n            length := extcodesize(_address)\n        }\n        return length > 0;\n    }\n}\n"
    },
    "contracts/core/interfaces/IERC677.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IERC677 is IERC20 {\n    function transferAndCall(\n        address _to,\n        uint256 _value,\n        bytes calldata _data\n    ) external returns (bool success);\n}\n"
    },
    "contracts/core/base/Strategy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"../interfaces/IStrategy.sol\";\nimport \"../interfaces/IStakingPool.sol\";\n\n/**\n * @title Strategy\n * @notice Base strategy contract to inherit from\n */\nabstract contract Strategy is IStrategy, Initializable, UUPSUpgradeable, OwnableUpgradeable {\n    IERC20Upgradeable public token;\n    IStakingPool public stakingPool;\n\n    function __Strategy_init(address _token, address _stakingPool) public onlyInitializing {\n        token = IERC20Upgradeable(_token);\n        stakingPool = IStakingPool(_stakingPool);\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n    }\n\n    modifier onlyStakingPool() {\n        require(address(stakingPool) == msg.sender, \"StakingPool only\");\n        _;\n    }\n\n    /**\n     * @notice returns the available deposit room for this strategy\n     * @return available deposit room\n     */\n    function canDeposit() public view virtual returns (uint) {\n        uint deposits = getTotalDeposits();\n        if (deposits >= getMaxDeposits()) {\n            return 0;\n        } else {\n            return getMaxDeposits() - deposits;\n        }\n    }\n\n    /**\n     * @notice returns the available withdrawal room for this strategy\n     * @return available withdrawal room\n     */\n    function canWithdraw() public view virtual returns (uint) {\n        uint deposits = getTotalDeposits();\n        if (deposits <= getMinDeposits()) {\n            return 0;\n        } else {\n            return deposits - getMinDeposits();\n        }\n    }\n\n    /**\n     * @notice returns the total amount of deposits in this strategy\n     * @return total deposits\n     */\n    function getTotalDeposits() public view virtual returns (uint);\n\n    /**\n     * @notice returns the maximum that can be deposited into this strategy\n     * @return max deposit\n     */\n    function getMaxDeposits() public view virtual returns (uint);\n\n    /**\n     * @notice returns the minimum that must remain in this strategy\n     * @return min deposit\n     */\n    function getMinDeposits() public view virtual returns (uint);\n\n    function _authorizeUpgrade(address) internal override onlyOwner {}\n}\n"
    },
    "contracts/linkStaking/interfaces/IVault.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\ninterface IVault {\n    function deposit(uint _amount) external;\n\n    function withdraw(uint _amount) external view;\n\n    function getTotalDeposits() external view returns (uint);\n\n    function getPrincipalDeposits() external view returns (uint);\n\n    function migrate(bytes calldata _data) external;\n\n    function upgradeToAndCall(address newImplementation, bytes memory data) external;\n\n    function upgradeTo(address newImplementation) external;\n}\n"
    },
    "contracts/linkStaking/interfaces/IStaking.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\ninterface IStaking {\n    function getCommunityStakerLimits() external view returns (uint256, uint256);\n\n    function getOperatorLimits() external view returns (uint256, uint256);\n\n    function getMaxPoolSize() external view returns (uint256);\n\n    function getTotalStakedAmount() external view returns (uint256);\n\n    function isActive() external view returns (bool);\n\n    function isOperator(address staker) external view returns (bool);\n\n    function getStake(address staker) external view returns (uint256);\n\n    function migrate(bytes calldata data) external;\n\n    function getBaseReward(address staker) external view returns (uint256);\n\n    function getDelegationReward(address staker) external view returns (uint256);\n\n    function getMigrationTarget() external view returns (address);\n\n    function isPaused() external view returns (bool);\n\n    function raiseAlert() external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/core/interfaces/IStrategy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\ninterface IStrategy {\n    function deposit(uint256 _amount) external;\n\n    function withdraw(uint256 _amount) external;\n\n    function updateDeposits() external returns (address[] memory receivers, uint[] memory amounts);\n\n    function getTotalDeposits() external view returns (uint256);\n\n    function getMaxDeposits() external view returns (uint256);\n\n    function getMinDeposits() external view returns (uint256);\n\n    function canDeposit() external view returns (uint256);\n\n    function canWithdraw() external view returns (uint256);\n\n    function depositChange() external view returns (int256);\n}\n"
    },
    "contracts/core/interfaces/IStakingPool.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"./IStakingRewardsPool.sol\";\n\ninterface IStakingPool is IStakingRewardsPool {\n    function stake(address _account, uint256 _amount) external;\n\n    function withdraw(\n        address _account,\n        address _receiver,\n        uint256 _amount\n    ) external;\n\n    function strategyDeposit(uint _index, uint256 _amount) external;\n\n    function strategyWithdraw(uint _index, uint256 _amount) external;\n\n    function updateStrategyRewards(uint[] memory _strategyIdxs) external;\n\n    function getMaxDeposits() external view returns (uint256);\n\n    function addStrategy(address _strategy) external;\n\n    function removeStrategy(uint _index) external;\n\n    function reorderStrategies(uint[] calldata _newOrder) external;\n\n    function getStrategies() external view returns (address[] memory);\n\n    function setPoolIndex(uint16 _poolIndex) external;\n\n    function canDeposit() external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = _setInitializedVersion(1);\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        bool isTopLevelCall = _setInitializedVersion(version);\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(version);\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        _setInitializedVersion(type(uint8).max);\n    }\n\n    function _setInitializedVersion(uint8 version) private returns (bool) {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, and for the lowest level\n        // of initializers, because in other contexts the contract may have been reentered.\n        if (_initializing) {\n            require(\n                version == 1 && !AddressUpgradeable.isContract(address(this)),\n                \"Initializable: contract is already initialized\"\n            );\n            return false;\n        } else {\n            require(_initialized < version, \"Initializable: contract is already initialized\");\n            _initialized = version;\n            return true;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../ERC1967/ERC1967UpgradeUpgradeable.sol\";\nimport \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");\n        _;\n    }\n\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate that the this implementation remains valid after an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/core/interfaces/IStakingRewardsPool.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"./IERC677.sol\";\n\ninterface IStakingRewardsPool is IERC677 {\n    /**\n     * @notice returns an account's share balance\n     * @param _account account to return balance for\n     * @return account's share balance\n     **/\n    function sharesOf(address _account) external view returns (uint);\n\n    /**\n     * @notice returns the amount of shares that corresponds to a staked amount\n     * @param _amount staked amount\n     * @return amount of shares\n     **/\n    function getSharesByStake(uint256 _amount) external view returns (uint);\n\n    /**\n     * @notice returns the amount of stake that corresponds to an amount of shares\n     * @param _amount shares amount\n     * @return amount of stake\n     **/\n    function getStakeByShares(uint256 _amount) external view returns (uint);\n\n    function totalShares() external view returns (uint);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/draft-IERC1822Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822ProxiableUpgradeable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeaconUpgradeable.sol\";\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/StorageSlotUpgradeable.sol\";\nimport \"../utils/Initializable.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967UpgradeUpgradeable is Initializable {\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\n        require(AddressUpgradeable.isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return AddressUpgradeable.verifyCallResult(success, returndata, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeaconUpgradeable {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlotUpgradeable {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "contracts/linkStaking/test/VCSMock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"../base/VaultControllerStrategy.sol\";\n\n/**\n * @title Mock Vault Controller Strategy\n * @dev Mocks contract for testing\n */\ncontract VCSMock is VaultControllerStrategy {\n    uint private totalPrincipalDeposits;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address _token,\n        address _stakingPool,\n        address _stakeController,\n        address _vaultImplementation,\n        uint _minDepositThreshold,\n        Fee[] memory _fees,\n        address[] calldata _initialVaults\n    ) public initializer {\n        __VaultControllerStrategy_init(\n            _token,\n            _stakingPool,\n            _stakeController,\n            _vaultImplementation,\n            _minDepositThreshold,\n            _fees\n        );\n        for (uint i = 0; i < _initialVaults.length; i++) {\n            address vault = _initialVaults[i];\n            vaults.push(IVault(vault));\n            token.approve(vault, type(uint256).max);\n        }\n    }\n\n    function getMaxDeposits() public view override returns (uint) {\n        return totalDeposits;\n    }\n\n    function getMinDeposits() public view override returns (uint) {\n        return totalDeposits;\n    }\n\n    function getVaultDepositLimits() public view override returns (uint, uint) {\n        return stakeController.getOperatorLimits();\n    }\n\n    function depositToVaults(\n        uint _startIndex,\n        uint _toDeposit,\n        uint _vaultMinDeposits,\n        uint _vaultMaxDeposits\n    ) external returns (uint) {\n        return _depositToVaults(_startIndex, _toDeposit, _vaultMinDeposits, _vaultMaxDeposits);\n    }\n\n    function deployVault(bytes memory _data) external {\n        _deployVault(_data);\n    }\n\n    function getBufferedDeposits() external view returns (uint) {\n        return bufferedDeposits;\n    }\n\n    function _depositBufferedTokens(\n        uint _startIndex,\n        uint _toDeposit,\n        uint _vaultMinDeposits,\n        uint _vaultMaxDeposits\n    ) internal override {\n        uint deposited = _depositToVaults(_startIndex, _toDeposit, _vaultMinDeposits, _vaultMaxDeposits);\n        totalPrincipalDeposits += deposited;\n        bufferedDeposits -= deposited;\n    }\n}\n"
    },
    "contracts/linkStaking/base/Vault.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"../../core/interfaces/IERC677.sol\";\nimport \"../interfaces/IStaking.sol\";\n\n/**\n * @title Vault\n * @notice Base vault contract for depositing LINK collateral into the Chainlink staking controller\n */\nabstract contract Vault is Initializable, UUPSUpgradeable, OwnableUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    IERC20Upgradeable public token;\n    address public vaultController;\n    IStaking public stakeController;\n\n    uint[10] private __gap;\n\n    function __Vault_init(\n        address _token,\n        address _vaultController,\n        address _stakeController\n    ) public onlyInitializing {\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n        token = IERC20Upgradeable(_token);\n        vaultController = _vaultController;\n        stakeController = IStaking(_stakeController);\n    }\n\n    modifier onlyVaultController() {\n        require(vaultController == msg.sender, \"Vault controller only\");\n        _;\n    }\n\n    /**\n     * @notice deposits the amount of token into the Chainlink staking contract\n     * @param _amount amount to deposit\n     */\n    function deposit(uint256 _amount) external onlyVaultController {\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n        IERC677(address(token)).transferAndCall(address(stakeController), _amount, \"0x00\");\n    }\n\n    /**\n     * @notice withdrawals are not yet implemented in this iteration of Chainlink staking\n     */\n    function withdraw(uint256) external view onlyVaultController {\n        revert(\"withdrawals not yet implemented\");\n    }\n\n    /**\n     * @notice returns the total balance of this contract in the Chainlink staking contract\n     * @return balance total balance\n     */\n    function getTotalDeposits() public view virtual returns (uint);\n\n    /**\n     * @notice returns the principal balance of this contract in the Chainlink staking contract\n     * @return balance principal balance\n     */\n    function getPrincipalDeposits() public view returns (uint) {\n        return stakeController.getStake(address(this));\n    }\n\n    /**\n     * @notice migrates the tokens deposited into a new stake controller\n     */\n    function migrate(bytes calldata data) external onlyVaultController {\n        stakeController.migrate(data);\n        stakeController = IStaking(stakeController.getMigrationTarget());\n    }\n\n    /**\n     * @notice allows the vault controller to be set after deployment only if it was set as an empty\n     * address on deploy\n     * @param _vaultController vault controller address\n     */\n    function setVaultController(address _vaultController) external onlyOwner {\n        require(\n            _vaultController != address(0) && vaultController == address(0),\n            \"Vault controller cannot be empty/controller is already set\"\n        );\n        vaultController = _vaultController;\n    }\n\n    /**\n     * @notice allows the stake controller to be set after deployment only if it was set as an empty\n     * address on deploy\n     * @param _stakeController stake controller address\n     */\n    function setStakeController(address _stakeController) external onlyOwner {\n        require(\n            _stakeController != address(0) && address(stakeController) == address(0),\n            \"Stake controller cannot be empty/controller is already set\"\n        );\n        stakeController = IStaking(_stakeController);\n    }\n\n    function _authorizeUpgrade(address) internal override onlyOwner {}\n}\n"
    },
    "contracts/ethStaking/base/OperatorController.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"solidity-bytes-utils/contracts/BytesLib.sol\";\n\nimport \"../../core/interfaces/IRewardsPool.sol\";\nimport \"../../core/interfaces/IERC677.sol\";\n\n/**\n * @title Operator Controller\n * @notice Base controller contract to be inherited from\n */\nabstract contract OperatorController is Initializable, UUPSUpgradeable, OwnableUpgradeable {\n    uint public constant PUBKEY_LENGTH = 48;\n    uint public constant SIGNATURE_LENGTH = 96;\n\n    struct Operator {\n        string name;\n        address owner;\n        bool active;\n        bool keyValidationInProgress;\n        uint64 validatorLimit;\n        uint64 stoppedValidators;\n        uint64 totalKeyPairs;\n        uint64 usedKeyPairs;\n    }\n\n    address public ethStakingStrategy;\n    address public keyValidationOracle;\n    address public beaconOracle;\n\n    IERC677 public sdToken;\n    IRewardsPool public rewardsPool;\n\n    Operator[] internal operators;\n\n    uint public totalAssignedValidators;\n    uint public totalActiveValidators;\n    mapping(address => uint) internal activeValidators;\n\n    uint public queueLength;\n    bytes32 public currentStateHash;\n\n    event AddOperator(address indexed owner, string name);\n    event OperatorOwnerChange(uint indexed operatorId, address indexed from, address indexed to);\n    event AddKeyPairs(uint indexed operatorId, uint quantity);\n    event SetKeyValidationOracle(address oracle);\n    event SetBeaconOracle(address oracle);\n    event SetRewardsPool(address pool);\n\n    modifier operatorExists(uint _id) {\n        require(_id < operators.length, \"Operator does not exist\");\n        _;\n    }\n\n    modifier onlyKeyValidationOracle() {\n        require(msg.sender == keyValidationOracle, \"Sender is not key validation oracle\");\n        _;\n    }\n\n    modifier onlyBeaconOracle() {\n        require(msg.sender == beaconOracle, \"Sender is not beacon oracle\");\n        _;\n    }\n\n    modifier onlyEthStakingStrategy() {\n        require(msg.sender == ethStakingStrategy, \"Sender is not ETH staking strategy\");\n        _;\n    }\n\n    function __OperatorController_init(address _ethStakingStrategy, address _sdToken) public onlyInitializing {\n        __UUPSUpgradeable_init();\n        __Ownable_init();\n        ethStakingStrategy = _ethStakingStrategy;\n        sdToken = IERC677(_sdToken);\n        currentStateHash = keccak256(\"initialized\");\n    }\n\n    /**\n     * @notice returns an account's stake balance for use by reward pools\n     * controlled by this contract\n     * @dev stake balance in this case is an account's # of active validators\n     * @return activeValidators account's # of active validators\n     */\n    function staked(address _account) public view returns (uint) {\n        return activeValidators[_account];\n    }\n\n    /**\n     * @notice returns the total staked amount for use by reward pools\n     * controlled by this contract\n     * @dev total staked amount in this case is the total # of active validators\n     * @return totalActiveValidators total # of active validators\n     */\n    function totalStaked() public view returns (uint) {\n        return totalActiveValidators;\n    }\n\n    /**\n     * @notice returns a list of operators\n     * @param _operatorIds id list of operators to return\n     * @return operators list of opertors\n     */\n    function getOperators(uint[] calldata _operatorIds) external view returns (Operator[] memory) {\n        Operator[] memory ret = new Operator[](_operatorIds.length);\n        for (uint i = 0; i < _operatorIds.length; i++) {\n            require(_operatorIds[i] < operators.length, \"Operator does not exist\");\n            ret[i] = operators[_operatorIds[i]];\n        }\n        return ret;\n    }\n\n    /**\n     * @notice returns a list key/signature pairs for an operator\n     * @param _operatorId id of operator to return pairs for\n     * @param _startIndex index of first pair to return\n     * @param _numPairs total number of pairs to return\n     * @return keys concatenated list of pubkeys\n     * @return signatures concatenated list of signatures\n     */\n    function getKeyPairs(\n        uint _operatorId,\n        uint _startIndex,\n        uint _numPairs\n    ) external view operatorExists(_operatorId) returns (bytes memory keys, bytes memory signatures) {\n        require(_startIndex < operators[_operatorId].totalKeyPairs, \"startIndex out of range\");\n\n        uint endIndex = _startIndex + _numPairs;\n        if (endIndex > operators[_operatorId].totalKeyPairs) {\n            endIndex = operators[_operatorId].totalKeyPairs;\n        }\n\n        for (uint i = _startIndex; i < endIndex; i++) {\n            (bytes memory key, bytes memory signature) = _loadKeyPair(_operatorId, i);\n            keys = bytes.concat(keys, key);\n            signatures = bytes.concat(signatures, signature);\n        }\n    }\n\n    /**\n     * @notice returns a list of assigned validator keys\n     * @param _startIndex index of first key to return\n     * @param _numKeys total number of keys to return\n     * @return keys concatenated list of pubkeys\n     */\n    function getAssignedKeys(uint _startIndex, uint _numKeys) external view returns (bytes memory keys) {\n        require(_startIndex < totalAssignedValidators, \"startIndex out of range\");\n\n        uint endIndex = _startIndex + _numKeys;\n        if (endIndex > totalAssignedValidators) {\n            endIndex = totalAssignedValidators;\n        }\n\n        uint index;\n\n        for (uint i = 0; i < operators.length && index < endIndex; i++) {\n            uint usedKeyPairs = operators[i].usedKeyPairs;\n\n            for (uint j = 0; j < usedKeyPairs && index < endIndex; j++) {\n                if (index >= _startIndex) {\n                    (bytes memory key, ) = _loadKeyPair(i, j);\n                    keys = bytes.concat(keys, key);\n                }\n                index++;\n            }\n        }\n    }\n\n    /**\n     * @notice ERC677 implementation to receive operator rewards\n     * @param _sender of the token transfer\n     * @param _value of the token transfer\n     **/\n    function onTokenTransfer(\n        address _sender,\n        uint256 _value,\n        bytes calldata _data\n    ) external {\n        require(msg.sender == address(sdToken), \"Sender is not sdToken\");\n        sdToken.transferAndCall(address(rewardsPool), _value, \"0x00\");\n    }\n\n    /**\n     * @notice Withdraws all available rewards for an operator owner\n     **/\n    function withdrawRewards() public {\n        rewardsPool.withdraw(msg.sender);\n    }\n\n    /**\n     * @notice Returns an operator owner's withdrawable reward amount\n\n     **/\n    function withdrawableRewards(address _account) external view returns (uint) {\n        return rewardsPool.withdrawableRewards(_account);\n    }\n\n    /**\n     * @notice Initiates a key pair validation for an operator\n     * @param _sender account initiating the validation\n     * @param _operatorId id of operator to initiate validation for\n     **/\n    function initiateKeyPairValidation(address _sender, uint _operatorId)\n        external\n        onlyKeyValidationOracle\n        operatorExists(_operatorId)\n    {\n        require(_sender == operators[_operatorId].owner, \"Sender is not operator owner\");\n        require(operators[_operatorId].active, \"Operator is not active\");\n        operators[_operatorId].keyValidationInProgress = true;\n    }\n\n    /**\n     * @notice Sets the name of an existing operator\n     * @param _name new name of operator\n     */\n    function setOperatorName(uint _operatorId, string calldata _name) external operatorExists(_operatorId) {\n        require(msg.sender == operators[_operatorId].owner, \"Sender is not operator owner\");\n        operators[_operatorId].name = _name;\n    }\n\n    /**\n     * @notice Sets the owner of an existing operator\n     * @dev this address will receive rewards and is authorized to modify all\n     * attributes of the operator\n     * @param _operatorId id of operator\n     * @param _owner new owner of operator\n     */\n    function setOperatorOwner(uint _operatorId, address _owner) external operatorExists(_operatorId) {\n        require(msg.sender == operators[_operatorId].owner, \"Sender is not operator owner\");\n        require(_owner != address(0), \"Owner address cannot be 0\");\n\n        uint operatorActiveValidators = operators[_operatorId].usedKeyPairs - operators[_operatorId].stoppedValidators;\n        activeValidators[_owner] += operatorActiveValidators;\n        activeValidators[msg.sender] -= operatorActiveValidators;\n        operators[_operatorId].owner = _owner;\n\n        emit OperatorOwnerChange(_operatorId, msg.sender, _owner);\n    }\n\n    /**\n     * @notice Permanently disables an operator\n     * @dev used when an operator misbehaves\n     * @param _operatorId id of operator\n     */\n    function disableOperator(uint _operatorId) external onlyOwner operatorExists(_operatorId) {\n        require(operators[_operatorId].active, \"Operator is already disabled\");\n\n        uint unusedKeys = operators[_operatorId].validatorLimit - operators[_operatorId].usedKeyPairs;\n        if (unusedKeys > 0) {\n            queueLength -= unusedKeys;\n            operators[_operatorId].validatorLimit -= uint64(unusedKeys);\n            currentStateHash = keccak256(abi.encodePacked(currentStateHash, \"disableOperator\", _operatorId));\n        }\n\n        uint unstoppedValidators = operators[_operatorId].usedKeyPairs - operators[_operatorId].stoppedValidators;\n        if (unstoppedValidators > 0) {\n            activeValidators[operators[_operatorId].owner] -= unstoppedValidators;\n            totalActiveValidators -= unstoppedValidators;\n        }\n\n        operators[_operatorId].active = false;\n    }\n\n    /**\n     * @notice Sets the key validation oracle\n     * @param _keyValidationOracle oracle address\n     */\n    function setKeyValidationOracle(address _keyValidationOracle) external onlyOwner {\n        keyValidationOracle = _keyValidationOracle;\n        emit SetKeyValidationOracle(_keyValidationOracle);\n    }\n\n    /**\n     * @notice Sets the beacon oracle\n     * @param _beaconOracle oracle address\n     */\n    function setBeaconOracle(address _beaconOracle) external onlyOwner {\n        beaconOracle = _beaconOracle;\n        emit SetBeaconOracle(_beaconOracle);\n    }\n\n    /**\n     * @notice Sets the rewards pool\n     * @param _rewardsPool rewards pool address\n     */\n    function setRewardsPool(address _rewardsPool) external onlyOwner {\n        rewardsPool = IRewardsPool(_rewardsPool);\n        emit SetRewardsPool(_rewardsPool);\n    }\n\n    /**\n     * @notice Adds a new operator\n     * @param _name name of operator\n     */\n    function _addOperator(string calldata _name) internal {\n        Operator memory operator = Operator(_name, msg.sender, true, false, 0, 0, 0, 0);\n        operators.push(operator);\n\n        emit AddOperator(msg.sender, _name);\n    }\n\n    /**\n     * @notice Adds a set of new validator pubkey/signature pairs for an operator\n     * @param _operatorId id of operator\n     * @param _quantity number of new pairs to add\n     * @param _pubkeys concatenated set of pubkeys to add\n     * @param _signatures concatenated set of signatures to add\n     */\n    function _addKeyPairs(\n        uint _operatorId,\n        uint _quantity,\n        bytes calldata _pubkeys,\n        bytes calldata _signatures\n    ) internal {\n        require(!operators[_operatorId].keyValidationInProgress, \"Key validation in progress\");\n        require(_pubkeys.length == _quantity * PUBKEY_LENGTH, \"Invalid pubkeys length\");\n        require(_signatures.length == _quantity * SIGNATURE_LENGTH, \"Invalid signatures length\");\n\n        bytes32 stateHash = currentStateHash;\n\n        for (uint256 i = 0; i < _quantity; ++i) {\n            bytes memory key = BytesLib.slice(_pubkeys, i * PUBKEY_LENGTH, PUBKEY_LENGTH);\n            require(!_isEmptyKey(key), \"Empty key\");\n            bytes memory signature = BytesLib.slice(_signatures, i * SIGNATURE_LENGTH, SIGNATURE_LENGTH);\n\n            _storeKeyPair(_operatorId, operators[_operatorId].totalKeyPairs + i, key, signature);\n            stateHash = keccak256(abi.encodePacked(stateHash, \"addKey\", _operatorId, key));\n        }\n\n        operators[_operatorId].totalKeyPairs += uint64(_quantity);\n        currentStateHash = stateHash;\n\n        emit AddKeyPairs(_operatorId, _quantity);\n    }\n\n    /**\n     * @notice Stores a pubkey/signature pair\n     * @param _operatorId id of operator that owns pair\n     * @param _keyIndex index of pair\n     * @param _key key to store\n     * @param _signature signature to store\n     */\n    function _storeKeyPair(\n        uint _operatorId,\n        uint _keyIndex,\n        bytes memory _key,\n        bytes memory _signature\n    ) internal {\n        assert(_key.length == PUBKEY_LENGTH);\n        assert(_signature.length == SIGNATURE_LENGTH);\n\n        // key\n        uint storageAddress = _keyPairStorageAddress(_operatorId, _keyIndex);\n        uint keyExcessBits = (2 * 32 - PUBKEY_LENGTH) * 8;\n        assembly {\n            sstore(storageAddress, mload(add(_key, 0x20)))\n            sstore(add(storageAddress, 1), shl(keyExcessBits, shr(keyExcessBits, mload(add(_key, 0x40)))))\n        }\n        storageAddress += 2;\n\n        // signature\n        for (uint i = 0; i < SIGNATURE_LENGTH; i += 32) {\n            assembly {\n                sstore(storageAddress, mload(add(_signature, add(0x20, i))))\n            }\n            storageAddress++;\n        }\n    }\n\n    /**\n     * @notice Loads a pubkey/signature pair from storage\n     * @param _operatorId id of operator that owns pair\n     * @param _keyIndex index of pair\n     * @return key stored pubkey\n     * @return signature stored signature\n     */\n    function _loadKeyPair(uint _operatorId, uint _keyIndex)\n        internal\n        view\n        returns (bytes memory key, bytes memory signature)\n    {\n        uint256 storageAddress = _keyPairStorageAddress(_operatorId, _keyIndex);\n\n        bytes memory tmpKey = new bytes(64);\n        assembly {\n            mstore(add(tmpKey, 0x20), sload(storageAddress))\n            mstore(add(tmpKey, 0x40), sload(add(storageAddress, 1)))\n        }\n        storageAddress += 2;\n        key = BytesLib.slice(tmpKey, 0, PUBKEY_LENGTH);\n\n        signature = new bytes(SIGNATURE_LENGTH);\n        for (uint256 i = 0; i < SIGNATURE_LENGTH; i += 32) {\n            assembly {\n                mstore(add(signature, add(0x20, i)), sload(storageAddress))\n            }\n            storageAddress++;\n        }\n\n        return (key, signature);\n    }\n\n    /**\n     * @notice Returns the storage address for pubkey/signature pair\n     * @param _operatorId id of operator that owns pair\n     * @param _keyIndex index of pair\n     * @return storageAddress storage address of pair\n     */\n    function _keyPairStorageAddress(uint _operatorId, uint _keyIndex) internal pure returns (uint) {\n        return uint256(keccak256(abi.encodePacked(\"operator-controller-keys\", _operatorId, _keyIndex)));\n    }\n\n    /**\n     * @notice Checks if a pubkey is empty\n     * @param _key key to check\n     * @return isEmpty whether key is empty\n     */\n    function _isEmptyKey(bytes memory _key) internal pure returns (bool) {\n        assert(_key.length == PUBKEY_LENGTH);\n\n        uint256 k1;\n        uint256 k2;\n        assembly {\n            k1 := mload(add(_key, 0x20))\n            k2 := mload(add(_key, 0x40))\n        }\n\n        return 0 == k1 && 0 == (k2 >> ((2 * 32 - PUBKEY_LENGTH) * 8));\n    }\n\n    function _authorizeUpgrade(address) internal override onlyOwner {}\n}\n"
    },
    "contracts/core/interfaces/IRewardsPool.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\ninterface IRewardsPool {\n    function updateReward(address _account) external;\n\n    function withdraw(address _account) external;\n\n    function distributeRewards() external;\n\n    function withdrawableRewards(address _account) external view returns (uint);\n}\n"
    },
    "solidity-bytes-utils/contracts/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity >=0.8.0 <0.9.0;\n\n\nlibrary BytesLib {\n    function concat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n              not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n            // Read the first 32 bytes of _preBytes storage, which is the length\n            // of the array. (We don't need to use the offset into the slot\n            // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n            // Arrays of 31 bytes or less have an even value in their slot,\n            // while longer arrays have an odd value. The actual length is\n            // the slot divided by two for odd values, and the lowest order\n            // byte divided by two for even values.\n            // If the slot is even, bitwise and the slot with 255 and divide by\n            // two to get the length. If the slot is odd, bitwise and the slot\n            // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n                // Since the new array still fits in the slot, we just need to\n                // update the contents of the slot.\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                    _preBytes.slot,\n                    // all the modifications to the slot are inside this\n                    // next block\n                    add(\n                        // we can just add to the slot contents because the\n                        // bytes we want to change are the LSBs\n                        fslot,\n                        add(\n                            mul(\n                                div(\n                                    // load the bytes from memory\n                                    mload(add(_postBytes, 0x20)),\n                                    // zero all bytes to the right\n                                    exp(0x100, sub(32, mlength))\n                                ),\n                                // and now shift left the number of bytes to\n                                // leave space for the length in the slot\n                                exp(0x100, sub(32, newlength))\n                            ),\n                            // increase length by the double of the memory\n                            // bytes length\n                            mul(mlength, 2)\n                        )\n                    )\n                )\n            }\n            case 1 {\n                // The stored value fits in the slot, but the combined value\n                // will exceed it.\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // The contents of the _postBytes array start 32 bytes into\n                // the structure. Our first read should obtain the `submod`\n                // bytes that can fit into the unused space in the last word\n                // of the stored array. To get this, we read 32 bytes starting\n                // from `submod`, so the data we read overlaps with the array\n                // contents by `submod` bytes. Masking the lowest-order\n                // `submod` bytes allows us to add that value directly to the\n                // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                    sc,\n                    add(\n                        and(\n                            fslot,\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                        ),\n                        and(mload(mc), mask)\n                    )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // Copy over the first `submod` bytes of the new data as in\n                // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1 , \"toUint8_outOfBounds\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, \"toUint16_outOfBounds\");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, \"toUint32_outOfBounds\");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, \"toUint64_outOfBounds\");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n        require(_bytes.length >= _start + 12, \"toUint96_outOfBounds\");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, \"toUint128_outOfBounds\");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, \"toUint256_outOfBounds\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, \"toBytes32_outOfBounds\");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                // the next line is the loop condition:\n                // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(\n        bytes storage _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        view\n        returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n            // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n                // slength can contain both the length and contents of the array\n                // if length < 32 bytes so let's prepare for that\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                        // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                            // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                        // cb is a circuit breaker in the for loop since there's\n                        //  no said feature for inline assembly loops\n                        // cb = 1 - don't breaker\n                        // cb = 0 - break\n                        let cb := 1\n\n                        // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                        // the next line is the loop condition:\n                        // while(uint256(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                                // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}\n"
    },
    "contracts/ethStaking/test/OperatorControllerMock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"solidity-bytes-utils/contracts/BytesLib.sol\";\n\nimport \"../base/OperatorController.sol\";\n\n/**\n * @title Operator Controller\n * @notice Base controller contract to be inherited from\n */\ncontract OperatorControllerMock is OperatorController {\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address _ethStakingStrategy, address _wsdToken) public initializer {\n        __OperatorController_init(_ethStakingStrategy, _wsdToken);\n    }\n\n    /**\n     * @notice Adds a new operator\n     * @param _name name of operator\n     */\n    function addOperator(string calldata _name) external {\n        _addOperator(_name);\n    }\n\n    /**\n     * @notice Adds a set of new validator pubkey/signature pairs for an operator\n     * @param _operatorId id of operator\n     * @param _quantity number of new pairs to add\n     * @param _pubkeys concatenated set of pubkeys to add\n     * @param _signatures concatenated set of signatures to add\n     */\n    function addKeyPairs(\n        uint _operatorId,\n        uint _quantity,\n        bytes calldata _pubkeys,\n        bytes calldata _signatures\n    ) external {\n        _addKeyPairs(_operatorId, _quantity, _pubkeys, _signatures);\n    }\n\n    /**\n     * @notice Assigns the next set of validators in the queue\n     * @param _operatorIds ids of operators that should be assigned validators\n     * @param _validatorCounts number of validators to assign each operator\n     * @param _totalValidatorCount sum of all entries in _validatorCounts\n     * @return keys concatenated list of pubkeys\n     * @return signatures concatenated list of signatures\n     */\n    function assignNextValidators(\n        uint[] calldata _operatorIds,\n        uint[] calldata _validatorCounts,\n        uint _totalValidatorCount\n    ) external returns (bytes memory keys, bytes memory signatures) {\n        for (uint i = 0; i < _operatorIds.length; i++) {\n            uint operatorId = _operatorIds[i];\n\n            operators[operatorId].usedKeyPairs += uint64(_validatorCounts[i]);\n            activeValidators[operators[operatorId].owner] += _validatorCounts[i];\n            totalActiveValidators += _validatorCounts[i];\n            totalAssignedValidators += _validatorCounts[i];\n        }\n    }\n\n    function reportKeyPairValidation(uint _operatorId, bool _success) external {\n        require(operators[_operatorId].keyValidationInProgress, \"No key validation in progress\");\n\n        if (_success) {\n            queueLength += operators[_operatorId].totalKeyPairs - operators[_operatorId].validatorLimit;\n            operators[_operatorId].validatorLimit = operators[_operatorId].totalKeyPairs;\n        }\n        operators[_operatorId].keyValidationInProgress = false;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`.\n        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\n        // This gives `2**k < a <= 2**(k+1)` → `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\n        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\n        // good first aproximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1;\n        uint256 x = a;\n        if (x >> 128 > 0) {\n            x >>= 128;\n            result <<= 64;\n        }\n        if (x >> 64 > 0) {\n            x >>= 64;\n            result <<= 32;\n        }\n        if (x >> 32 > 0) {\n            x >>= 32;\n            result <<= 16;\n        }\n        if (x >> 16 > 0) {\n            x >>= 16;\n            result <<= 8;\n        }\n        if (x >> 8 > 0) {\n            x >>= 8;\n            result <<= 4;\n        }\n        if (x >> 4 > 0) {\n            x >>= 4;\n            result <<= 2;\n        }\n        if (x >> 2 > 0) {\n            result <<= 1;\n        }\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = sqrt(a);\n        if (rounding == Rounding.Up && result * result < a) {\n            result += 1;\n        }\n        return result;\n    }\n}\n"
    },
    "contracts/ethStaking/test/OperatorControllerMockV2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"./OperatorControllerMock.sol\";\n\n/**\n * @title Operator Controller Mock V2\n * @notice Mocks contract upgrade for testing\n */\ncontract OperatorControllerMockV2 is OperatorControllerMock {\n    function contractVersion() external pure returns (uint) {\n        return 2;\n    }\n}\n"
    },
    "contracts/core/feeCurves/RampUpCurve.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@prb/math/contracts/PRBMathUD60x18.sol\";\n\n/**\n * @title Ramp Up Curve\n * @notice Sets a fee curve that significantly ramps up when the percentage increases\n */\ncontract RampUpCurve is Ownable {\n    using PRBMathUD60x18 for uint;\n\n    uint public rateConstantA;\n    uint public rateConstantB;\n    uint public rateConstantC;\n    uint public rateConstantD;\n    uint public rateConstantE;\n\n    event RateConstantsSet(\n        uint _rateConstantA,\n        uint _rateConstantB,\n        uint _rateConstantC,\n        uint _rateConstantD,\n        uint _rateConstantE\n    );\n\n    constructor(\n        uint _rateConstantA,\n        uint _rateConstantB,\n        uint _rateConstantC,\n        uint _rateConstantD,\n        uint _rateConstantE\n    ) {\n        setRateConstants(_rateConstantA, _rateConstantB, _rateConstantC, _rateConstantD, _rateConstantE);\n    }\n\n    /**\n     * @notice sets the constants used for calculating current rate\n     * @param _rateConstantA value to set for rateA\n     * @param _rateConstantB value to set for rateB\n     * @param _rateConstantC value to set for rateC\n     * @param _rateConstantD value to set for rateD\n     * @param _rateConstantE value to set for rateE\n     **/\n    function setRateConstants(\n        uint _rateConstantA,\n        uint _rateConstantB,\n        uint _rateConstantC,\n        uint _rateConstantD,\n        uint _rateConstantE\n    ) public onlyOwner {\n        require(_rateConstantA > 0 && _rateConstantB > 0 && _rateConstantC > 0, \"Rate constants A, B and C cannot be zero\");\n\n        rateConstantA = _rateConstantA;\n        rateConstantB = _rateConstantB;\n        rateConstantC = _rateConstantC;\n        rateConstantD = _rateConstantD;\n        rateConstantE = _rateConstantE;\n\n        emit RateConstantsSet(_rateConstantA, _rateConstantB, _rateConstantC, _rateConstantD, _rateConstantE);\n    }\n\n    /**\n     * @notice calculates the current percentage of rewards that lenders\n     * receive and borrowers pay. Fee cap of 95% hardcoded.\n     * @dev Equation: y = (A*x/B)^C + x/D + E\n     * @return current rate\n     **/\n    function currentRate(uint _percentage) external view returns (uint) {\n        if (_percentage == 0) {\n            return rateConstantE * 100;\n        }\n        uint x = _percentage;\n        uint y = x.div(rateConstantB).mul(rateConstantA * 100).powu(rateConstantC);\n        if (rateConstantD > 1) {\n            y = y + (x * 100).div(rateConstantD).toUint();\n        }\n        y = y / 1e16 + rateConstantE * 100;\n\n        if (y > 9500) {\n            return 9500;\n        }\n        return y;\n    }\n}\n"
    },
    "@prb/math/contracts/PRBMathUD60x18.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\nimport \"./PRBMath.sol\";\n\n/// @title PRBMathUD60x18\n/// @author Paul Razvan Berg\n/// @notice Smart contract library for advanced fixed-point math that works with uint256 numbers considered to have 18\n/// trailing decimals. We call this number representation unsigned 60.18-decimal fixed-point, since there can be up to 60\n/// digits in the integer part and up to 18 decimals in the fractional part. The numbers are bound by the minimum and the\n/// maximum values permitted by the Solidity type uint256.\nlibrary PRBMathUD60x18 {\n    /// @dev Half the SCALE number.\n    uint256 internal constant HALF_SCALE = 5e17;\n\n    /// @dev log2(e) as an unsigned 60.18-decimal fixed-point number.\n    uint256 internal constant LOG2_E = 1_442695040888963407;\n\n    /// @dev The maximum value an unsigned 60.18-decimal fixed-point number can have.\n    uint256 internal constant MAX_UD60x18 =\n        115792089237316195423570985008687907853269984665640564039457_584007913129639935;\n\n    /// @dev The maximum whole value an unsigned 60.18-decimal fixed-point number can have.\n    uint256 internal constant MAX_WHOLE_UD60x18 =\n        115792089237316195423570985008687907853269984665640564039457_000000000000000000;\n\n    /// @dev How many trailing decimals can be represented.\n    uint256 internal constant SCALE = 1e18;\n\n    /// @notice Calculates the arithmetic average of x and y, rounding down.\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The arithmetic average as an unsigned 60.18-decimal fixed-point number.\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        // The operations can never overflow.\n        unchecked {\n            // The last operand checks if both x and y are odd and if that is the case, we add 1 to the result. We need\n            // to do this because if both numbers are odd, the 0.5 remainder gets truncated twice.\n            result = (x >> 1) + (y >> 1) + (x & y & 1);\n        }\n    }\n\n    /// @notice Yields the least unsigned 60.18 decimal fixed-point number greater than or equal to x.\n    ///\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n    ///\n    /// Requirements:\n    /// - x must be less than or equal to MAX_WHOLE_UD60x18.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number to ceil.\n    /// @param result The least integer greater than or equal to x, as an unsigned 60.18-decimal fixed-point number.\n    function ceil(uint256 x) internal pure returns (uint256 result) {\n        if (x > MAX_WHOLE_UD60x18) {\n            revert PRBMathUD60x18__CeilOverflow(x);\n        }\n        assembly {\n            // Equivalent to \"x % SCALE\" but faster.\n            let remainder := mod(x, SCALE)\n\n            // Equivalent to \"SCALE - remainder\" but faster.\n            let delta := sub(SCALE, remainder)\n\n            // Equivalent to \"x + delta * (remainder > 0 ? 1 : 0)\" but faster.\n            result := add(x, mul(delta, gt(remainder, 0)))\n        }\n    }\n\n    /// @notice Divides two unsigned 60.18-decimal fixed-point numbers, returning a new unsigned 60.18-decimal fixed-point number.\n    ///\n    /// @dev Uses mulDiv to enable overflow-safe multiplication and division.\n    ///\n    /// Requirements:\n    /// - The denominator cannot be zero.\n    ///\n    /// @param x The numerator as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The denominator as an unsigned 60.18-decimal fixed-point number.\n    /// @param result The quotient as an unsigned 60.18-decimal fixed-point number.\n    function div(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        result = PRBMath.mulDiv(x, SCALE, y);\n    }\n\n    /// @notice Returns Euler's number as an unsigned 60.18-decimal fixed-point number.\n    /// @dev See https://en.wikipedia.org/wiki/E_(mathematical_constant).\n    function e() internal pure returns (uint256 result) {\n        result = 2_718281828459045235;\n    }\n\n    /// @notice Calculates the natural exponent of x.\n    ///\n    /// @dev Based on the insight that e^x = 2^(x * log2(e)).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    /// - x must be less than 133.084258667509499441.\n    ///\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function exp(uint256 x) internal pure returns (uint256 result) {\n        // Without this check, the value passed to \"exp2\" would be greater than 192.\n        if (x >= 133_084258667509499441) {\n            revert PRBMathUD60x18__ExpInputTooBig(x);\n        }\n\n        // Do the fixed-point multiplication inline to save gas.\n        unchecked {\n            uint256 doubleScaleProduct = x * LOG2_E;\n            result = exp2((doubleScaleProduct + HALF_SCALE) / SCALE);\n        }\n    }\n\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\n    ///\n    /// @dev See https://ethereum.stackexchange.com/q/79903/24693.\n    ///\n    /// Requirements:\n    /// - x must be 192 or less.\n    /// - The result must fit within MAX_UD60x18.\n    ///\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function exp2(uint256 x) internal pure returns (uint256 result) {\n        // 2^192 doesn't fit within the 192.64-bit format used internally in this function.\n        if (x >= 192e18) {\n            revert PRBMathUD60x18__Exp2InputTooBig(x);\n        }\n\n        unchecked {\n            // Convert x to the 192.64-bit fixed-point format.\n            uint256 x192x64 = (x << 64) / SCALE;\n\n            // Pass x to the PRBMath.exp2 function, which uses the 192.64-bit fixed-point number representation.\n            result = PRBMath.exp2(x192x64);\n        }\n    }\n\n    /// @notice Yields the greatest unsigned 60.18 decimal fixed-point number less than or equal to x.\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n    /// @param x The unsigned 60.18-decimal fixed-point number to floor.\n    /// @param result The greatest integer less than or equal to x, as an unsigned 60.18-decimal fixed-point number.\n    function floor(uint256 x) internal pure returns (uint256 result) {\n        assembly {\n            // Equivalent to \"x % SCALE\" but faster.\n            let remainder := mod(x, SCALE)\n\n            // Equivalent to \"x - remainder * (remainder > 0 ? 1 : 0)\" but faster.\n            result := sub(x, mul(remainder, gt(remainder, 0)))\n        }\n    }\n\n    /// @notice Yields the excess beyond the floor of x.\n    /// @dev Based on the odd function definition https://en.wikipedia.org/wiki/Fractional_part.\n    /// @param x The unsigned 60.18-decimal fixed-point number to get the fractional part of.\n    /// @param result The fractional part of x as an unsigned 60.18-decimal fixed-point number.\n    function frac(uint256 x) internal pure returns (uint256 result) {\n        assembly {\n            result := mod(x, SCALE)\n        }\n    }\n\n    /// @notice Converts a number from basic integer form to unsigned 60.18-decimal fixed-point representation.\n    ///\n    /// @dev Requirements:\n    /// - x must be less than or equal to MAX_UD60x18 divided by SCALE.\n    ///\n    /// @param x The basic integer to convert.\n    /// @param result The same number in unsigned 60.18-decimal fixed-point representation.\n    function fromUint(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            if (x > MAX_UD60x18 / SCALE) {\n                revert PRBMathUD60x18__FromUintOverflow(x);\n            }\n            result = x * SCALE;\n        }\n    }\n\n    /// @notice Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down.\n    ///\n    /// @dev Requirements:\n    /// - x * y must fit within MAX_UD60x18, lest it overflows.\n    ///\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function gm(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        if (x == 0) {\n            return 0;\n        }\n\n        unchecked {\n            // Checking for overflow this way is faster than letting Solidity do it.\n            uint256 xy = x * y;\n            if (xy / x != y) {\n                revert PRBMathUD60x18__GmOverflow(x, y);\n            }\n\n            // We don't need to multiply by the SCALE here because the x*y product had already picked up a factor of SCALE\n            // during multiplication. See the comments within the \"sqrt\" function.\n            result = PRBMath.sqrt(xy);\n        }\n    }\n\n    /// @notice Calculates 1 / x, rounding toward zero.\n    ///\n    /// @dev Requirements:\n    /// - x cannot be zero.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the inverse.\n    /// @return result The inverse as an unsigned 60.18-decimal fixed-point number.\n    function inv(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            // 1e36 is SCALE * SCALE.\n            result = 1e36 / x;\n        }\n    }\n\n    /// @notice Calculates the natural logarithm of x.\n    ///\n    /// @dev Based on the insight that ln(x) = log2(x) / log2(e).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    ///\n    /// Caveats:\n    /// - All from \"log2\".\n    /// - This doesn't return exactly 1 for 2.718281828459045235, for that we would need more fine-grained precision.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the natural logarithm.\n    /// @return result The natural logarithm as an unsigned 60.18-decimal fixed-point number.\n    function ln(uint256 x) internal pure returns (uint256 result) {\n        // Do the fixed-point multiplication inline to save gas. This is overflow-safe because the maximum value that log2(x)\n        // can return is 196205294292027477728.\n        unchecked {\n            result = (log2(x) * SCALE) / LOG2_E;\n        }\n    }\n\n    /// @notice Calculates the common logarithm of x.\n    ///\n    /// @dev First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common\n    /// logarithm based on the insight that log10(x) = log2(x) / log2(10).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    ///\n    /// Caveats:\n    /// - All from \"log2\".\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the common logarithm.\n    /// @return result The common logarithm as an unsigned 60.18-decimal fixed-point number.\n    function log10(uint256 x) internal pure returns (uint256 result) {\n        if (x < SCALE) {\n            revert PRBMathUD60x18__LogInputTooSmall(x);\n        }\n\n        // Note that the \"mul\" in this block is the assembly multiplication operation, not the \"mul\" function defined\n        // in this contract.\n        // prettier-ignore\n        assembly {\n            switch x\n            case 1 { result := mul(SCALE, sub(0, 18)) }\n            case 10 { result := mul(SCALE, sub(1, 18)) }\n            case 100 { result := mul(SCALE, sub(2, 18)) }\n            case 1000 { result := mul(SCALE, sub(3, 18)) }\n            case 10000 { result := mul(SCALE, sub(4, 18)) }\n            case 100000 { result := mul(SCALE, sub(5, 18)) }\n            case 1000000 { result := mul(SCALE, sub(6, 18)) }\n            case 10000000 { result := mul(SCALE, sub(7, 18)) }\n            case 100000000 { result := mul(SCALE, sub(8, 18)) }\n            case 1000000000 { result := mul(SCALE, sub(9, 18)) }\n            case 10000000000 { result := mul(SCALE, sub(10, 18)) }\n            case 100000000000 { result := mul(SCALE, sub(11, 18)) }\n            case 1000000000000 { result := mul(SCALE, sub(12, 18)) }\n            case 10000000000000 { result := mul(SCALE, sub(13, 18)) }\n            case 100000000000000 { result := mul(SCALE, sub(14, 18)) }\n            case 1000000000000000 { result := mul(SCALE, sub(15, 18)) }\n            case 10000000000000000 { result := mul(SCALE, sub(16, 18)) }\n            case 100000000000000000 { result := mul(SCALE, sub(17, 18)) }\n            case 1000000000000000000 { result := 0 }\n            case 10000000000000000000 { result := SCALE }\n            case 100000000000000000000 { result := mul(SCALE, 2) }\n            case 1000000000000000000000 { result := mul(SCALE, 3) }\n            case 10000000000000000000000 { result := mul(SCALE, 4) }\n            case 100000000000000000000000 { result := mul(SCALE, 5) }\n            case 1000000000000000000000000 { result := mul(SCALE, 6) }\n            case 10000000000000000000000000 { result := mul(SCALE, 7) }\n            case 100000000000000000000000000 { result := mul(SCALE, 8) }\n            case 1000000000000000000000000000 { result := mul(SCALE, 9) }\n            case 10000000000000000000000000000 { result := mul(SCALE, 10) }\n            case 100000000000000000000000000000 { result := mul(SCALE, 11) }\n            case 1000000000000000000000000000000 { result := mul(SCALE, 12) }\n            case 10000000000000000000000000000000 { result := mul(SCALE, 13) }\n            case 100000000000000000000000000000000 { result := mul(SCALE, 14) }\n            case 1000000000000000000000000000000000 { result := mul(SCALE, 15) }\n            case 10000000000000000000000000000000000 { result := mul(SCALE, 16) }\n            case 100000000000000000000000000000000000 { result := mul(SCALE, 17) }\n            case 1000000000000000000000000000000000000 { result := mul(SCALE, 18) }\n            case 10000000000000000000000000000000000000 { result := mul(SCALE, 19) }\n            case 100000000000000000000000000000000000000 { result := mul(SCALE, 20) }\n            case 1000000000000000000000000000000000000000 { result := mul(SCALE, 21) }\n            case 10000000000000000000000000000000000000000 { result := mul(SCALE, 22) }\n            case 100000000000000000000000000000000000000000 { result := mul(SCALE, 23) }\n            case 1000000000000000000000000000000000000000000 { result := mul(SCALE, 24) }\n            case 10000000000000000000000000000000000000000000 { result := mul(SCALE, 25) }\n            case 100000000000000000000000000000000000000000000 { result := mul(SCALE, 26) }\n            case 1000000000000000000000000000000000000000000000 { result := mul(SCALE, 27) }\n            case 10000000000000000000000000000000000000000000000 { result := mul(SCALE, 28) }\n            case 100000000000000000000000000000000000000000000000 { result := mul(SCALE, 29) }\n            case 1000000000000000000000000000000000000000000000000 { result := mul(SCALE, 30) }\n            case 10000000000000000000000000000000000000000000000000 { result := mul(SCALE, 31) }\n            case 100000000000000000000000000000000000000000000000000 { result := mul(SCALE, 32) }\n            case 1000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 33) }\n            case 10000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 34) }\n            case 100000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 35) }\n            case 1000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 36) }\n            case 10000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 37) }\n            case 100000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 38) }\n            case 1000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 39) }\n            case 10000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 40) }\n            case 100000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 41) }\n            case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 42) }\n            case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 43) }\n            case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 44) }\n            case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 45) }\n            case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 46) }\n            case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 47) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 48) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 49) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 50) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 51) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 52) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 53) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 54) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 55) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 56) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 57) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 58) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 59) }\n            default {\n                result := MAX_UD60x18\n            }\n        }\n\n        if (result == MAX_UD60x18) {\n            // Do the fixed-point division inline to save gas. The denominator is log2(10).\n            unchecked {\n                result = (log2(x) * SCALE) / 3_321928094887362347;\n            }\n        }\n    }\n\n    /// @notice Calculates the binary logarithm of x.\n    ///\n    /// @dev Based on the iterative approximation algorithm.\n    /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\n    ///\n    /// Requirements:\n    /// - x must be greater than or equal to SCALE, otherwise the result would be negative.\n    ///\n    /// Caveats:\n    /// - The results are nor perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the binary logarithm.\n    /// @return result The binary logarithm as an unsigned 60.18-decimal fixed-point number.\n    function log2(uint256 x) internal pure returns (uint256 result) {\n        if (x < SCALE) {\n            revert PRBMathUD60x18__LogInputTooSmall(x);\n        }\n        unchecked {\n            // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).\n            uint256 n = PRBMath.mostSignificantBit(x / SCALE);\n\n            // The integer part of the logarithm as an unsigned 60.18-decimal fixed-point number. The operation can't overflow\n            // because n is maximum 255 and SCALE is 1e18.\n            result = n * SCALE;\n\n            // This is y = x * 2^(-n).\n            uint256 y = x >> n;\n\n            // If y = 1, the fractional part is zero.\n            if (y == SCALE) {\n                return result;\n            }\n\n            // Calculate the fractional part via the iterative approximation.\n            // The \"delta >>= 1\" part is equivalent to \"delta /= 2\", but shifting bits is faster.\n            for (uint256 delta = HALF_SCALE; delta > 0; delta >>= 1) {\n                y = (y * y) / SCALE;\n\n                // Is y^2 > 2 and so in the range [2,4)?\n                if (y >= 2 * SCALE) {\n                    // Add the 2^(-m) factor to the logarithm.\n                    result += delta;\n\n                    // Corresponds to z/2 on Wikipedia.\n                    y >>= 1;\n                }\n            }\n        }\n    }\n\n    /// @notice Multiplies two unsigned 60.18-decimal fixed-point numbers together, returning a new unsigned 60.18-decimal\n    /// fixed-point number.\n    /// @dev See the documentation for the \"PRBMath.mulDivFixedPoint\" function.\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The product as an unsigned 60.18-decimal fixed-point number.\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        result = PRBMath.mulDivFixedPoint(x, y);\n    }\n\n    /// @notice Returns PI as an unsigned 60.18-decimal fixed-point number.\n    function pi() internal pure returns (uint256 result) {\n        result = 3_141592653589793238;\n    }\n\n    /// @notice Raises x to the power of y.\n    ///\n    /// @dev Based on the insight that x^y = 2^(log2(x) * y).\n    ///\n    /// Requirements:\n    /// - All from \"exp2\", \"log2\" and \"mul\".\n    ///\n    /// Caveats:\n    /// - All from \"exp2\", \"log2\" and \"mul\".\n    /// - Assumes 0^0 is 1.\n    ///\n    /// @param x Number to raise to given power y, as an unsigned 60.18-decimal fixed-point number.\n    /// @param y Exponent to raise x to, as an unsigned 60.18-decimal fixed-point number.\n    /// @return result x raised to power y, as an unsigned 60.18-decimal fixed-point number.\n    function pow(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        if (x == 0) {\n            result = y == 0 ? SCALE : uint256(0);\n        } else {\n            result = exp2(mul(log2(x), y));\n        }\n    }\n\n    /// @notice Raises x (unsigned 60.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the\n    /// famous algorithm \"exponentiation by squaring\".\n    ///\n    /// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring\n    ///\n    /// Requirements:\n    /// - The result must fit within MAX_UD60x18.\n    ///\n    /// Caveats:\n    /// - All from \"mul\".\n    /// - Assumes 0^0 is 1.\n    ///\n    /// @param x The base as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The exponent as an uint256.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function powu(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        // Calculate the first iteration of the loop in advance.\n        result = y & 1 > 0 ? x : SCALE;\n\n        // Equivalent to \"for(y /= 2; y > 0; y /= 2)\" but faster.\n        for (y >>= 1; y > 0; y >>= 1) {\n            x = PRBMath.mulDivFixedPoint(x, x);\n\n            // Equivalent to \"y % 2 == 1\" but faster.\n            if (y & 1 > 0) {\n                result = PRBMath.mulDivFixedPoint(result, x);\n            }\n        }\n    }\n\n    /// @notice Returns 1 as an unsigned 60.18-decimal fixed-point number.\n    function scale() internal pure returns (uint256 result) {\n        result = SCALE;\n    }\n\n    /// @notice Calculates the square root of x, rounding down.\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n    ///\n    /// Requirements:\n    /// - x must be less than MAX_UD60x18 / SCALE.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the square root.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point .\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            if (x > MAX_UD60x18 / SCALE) {\n                revert PRBMathUD60x18__SqrtOverflow(x);\n            }\n            // Multiply x by the SCALE to account for the factor of SCALE that is picked up when multiplying two unsigned\n            // 60.18-decimal fixed-point numbers together (in this case, those two numbers are both the square root).\n            result = PRBMath.sqrt(x * SCALE);\n        }\n    }\n\n    /// @notice Converts a unsigned 60.18-decimal fixed-point number to basic integer form, rounding down in the process.\n    /// @param x The unsigned 60.18-decimal fixed-point number to convert.\n    /// @return result The same number in basic integer form.\n    function toUint(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            result = x / SCALE;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248) {\n        require(value >= type(int248).min && value <= type(int248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return int248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240) {\n        require(value >= type(int240).min && value <= type(int240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return int240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232) {\n        require(value >= type(int232).min && value <= type(int232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return int232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224) {\n        require(value >= type(int224).min && value <= type(int224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return int224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216) {\n        require(value >= type(int216).min && value <= type(int216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return int216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208) {\n        require(value >= type(int208).min && value <= type(int208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return int208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200) {\n        require(value >= type(int200).min && value <= type(int200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return int200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192) {\n        require(value >= type(int192).min && value <= type(int192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return int192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184) {\n        require(value >= type(int184).min && value <= type(int184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return int184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176) {\n        require(value >= type(int176).min && value <= type(int176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return int176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168) {\n        require(value >= type(int168).min && value <= type(int168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return int168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160) {\n        require(value >= type(int160).min && value <= type(int160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return int160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152) {\n        require(value >= type(int152).min && value <= type(int152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return int152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144) {\n        require(value >= type(int144).min && value <= type(int144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return int144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136) {\n        require(value >= type(int136).min && value <= type(int136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return int136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120) {\n        require(value >= type(int120).min && value <= type(int120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return int120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112) {\n        require(value >= type(int112).min && value <= type(int112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return int112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104) {\n        require(value >= type(int104).min && value <= type(int104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return int104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96) {\n        require(value >= type(int96).min && value <= type(int96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return int96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88) {\n        require(value >= type(int88).min && value <= type(int88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return int88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80) {\n        require(value >= type(int80).min && value <= type(int80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return int80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72) {\n        require(value >= type(int72).min && value <= type(int72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return int72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56) {\n        require(value >= type(int56).min && value <= type(int56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return int56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48) {\n        require(value >= type(int48).min && value <= type(int48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return int48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40) {\n        require(value >= type(int40).min && value <= type(int40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return int40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24) {\n        require(value >= type(int24).min && value <= type(int24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return int24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@prb/math/contracts/PRBMath.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\n/// @notice Emitted when the result overflows uint256.\nerror PRBMath__MulDivFixedPointOverflow(uint256 prod1);\n\n/// @notice Emitted when the result overflows uint256.\nerror PRBMath__MulDivOverflow(uint256 prod1, uint256 denominator);\n\n/// @notice Emitted when one of the inputs is type(int256).min.\nerror PRBMath__MulDivSignedInputTooSmall();\n\n/// @notice Emitted when the intermediary absolute result overflows int256.\nerror PRBMath__MulDivSignedOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is MIN_SD59x18.\nerror PRBMathSD59x18__AbsInputTooSmall();\n\n/// @notice Emitted when ceiling a number overflows SD59x18.\nerror PRBMathSD59x18__CeilOverflow(int256 x);\n\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\nerror PRBMathSD59x18__DivInputTooSmall();\n\n/// @notice Emitted when one of the intermediary unsigned results overflows SD59x18.\nerror PRBMathSD59x18__DivOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is greater than 133.084258667509499441.\nerror PRBMathSD59x18__ExpInputTooBig(int256 x);\n\n/// @notice Emitted when the input is greater than 192.\nerror PRBMathSD59x18__Exp2InputTooBig(int256 x);\n\n/// @notice Emitted when flooring a number underflows SD59x18.\nerror PRBMathSD59x18__FloorUnderflow(int256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format overflows SD59x18.\nerror PRBMathSD59x18__FromIntOverflow(int256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format underflows SD59x18.\nerror PRBMathSD59x18__FromIntUnderflow(int256 x);\n\n/// @notice Emitted when the product of the inputs is negative.\nerror PRBMathSD59x18__GmNegativeProduct(int256 x, int256 y);\n\n/// @notice Emitted when multiplying the inputs overflows SD59x18.\nerror PRBMathSD59x18__GmOverflow(int256 x, int256 y);\n\n/// @notice Emitted when the input is less than or equal to zero.\nerror PRBMathSD59x18__LogInputTooSmall(int256 x);\n\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\nerror PRBMathSD59x18__MulInputTooSmall();\n\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\nerror PRBMathSD59x18__MulOverflow(uint256 rAbs);\n\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\nerror PRBMathSD59x18__PowuOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is negative.\nerror PRBMathSD59x18__SqrtNegativeInput(int256 x);\n\n/// @notice Emitted when the calculating the square root overflows SD59x18.\nerror PRBMathSD59x18__SqrtOverflow(int256 x);\n\n/// @notice Emitted when addition overflows UD60x18.\nerror PRBMathUD60x18__AddOverflow(uint256 x, uint256 y);\n\n/// @notice Emitted when ceiling a number overflows UD60x18.\nerror PRBMathUD60x18__CeilOverflow(uint256 x);\n\n/// @notice Emitted when the input is greater than 133.084258667509499441.\nerror PRBMathUD60x18__ExpInputTooBig(uint256 x);\n\n/// @notice Emitted when the input is greater than 192.\nerror PRBMathUD60x18__Exp2InputTooBig(uint256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format format overflows UD60x18.\nerror PRBMathUD60x18__FromUintOverflow(uint256 x);\n\n/// @notice Emitted when multiplying the inputs overflows UD60x18.\nerror PRBMathUD60x18__GmOverflow(uint256 x, uint256 y);\n\n/// @notice Emitted when the input is less than 1.\nerror PRBMathUD60x18__LogInputTooSmall(uint256 x);\n\n/// @notice Emitted when the calculating the square root overflows UD60x18.\nerror PRBMathUD60x18__SqrtOverflow(uint256 x);\n\n/// @notice Emitted when subtraction underflows UD60x18.\nerror PRBMathUD60x18__SubUnderflow(uint256 x, uint256 y);\n\n/// @dev Common mathematical functions used in both PRBMathSD59x18 and PRBMathUD60x18. Note that this shared library\n/// does not always assume the signed 59.18-decimal fixed-point or the unsigned 60.18-decimal fixed-point\n/// representation. When it does not, it is explicitly mentioned in the NatSpec documentation.\nlibrary PRBMath {\n    /// STRUCTS ///\n\n    struct SD59x18 {\n        int256 value;\n    }\n\n    struct UD60x18 {\n        uint256 value;\n    }\n\n    /// STORAGE ///\n\n    /// @dev How many trailing decimals can be represented.\n    uint256 internal constant SCALE = 1e18;\n\n    /// @dev Largest power of two divisor of SCALE.\n    uint256 internal constant SCALE_LPOTD = 262144;\n\n    /// @dev SCALE inverted mod 2^256.\n    uint256 internal constant SCALE_INVERSE =\n        78156646155174841979727994598816262306175212592076161876661_508869554232690281;\n\n    /// FUNCTIONS ///\n\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\n    /// @dev Has to use 192.64-bit fixed-point numbers.\n    /// See https://ethereum.stackexchange.com/a/96594/24693.\n    /// @param x The exponent as an unsigned 192.64-bit fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function exp2(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            // Start from 0.5 in the 192.64-bit fixed-point format.\n            result = 0x800000000000000000000000000000000000000000000000;\n\n            // Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows\n            // because the initial result is 2^191 and all magic factors are less than 2^65.\n            if (x & 0x8000000000000000 > 0) {\n                result = (result * 0x16A09E667F3BCC909) >> 64;\n            }\n            if (x & 0x4000000000000000 > 0) {\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\n            }\n            if (x & 0x2000000000000000 > 0) {\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\n            }\n            if (x & 0x1000000000000000 > 0) {\n                result = (result * 0x10B5586CF9890F62A) >> 64;\n            }\n            if (x & 0x800000000000000 > 0) {\n                result = (result * 0x1059B0D31585743AE) >> 64;\n            }\n            if (x & 0x400000000000000 > 0) {\n                result = (result * 0x102C9A3E778060EE7) >> 64;\n            }\n            if (x & 0x200000000000000 > 0) {\n                result = (result * 0x10163DA9FB33356D8) >> 64;\n            }\n            if (x & 0x100000000000000 > 0) {\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\n            }\n            if (x & 0x80000000000000 > 0) {\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\n            }\n            if (x & 0x40000000000000 > 0) {\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\n            }\n            if (x & 0x20000000000000 > 0) {\n                result = (result * 0x100162F3904051FA1) >> 64;\n            }\n            if (x & 0x10000000000000 > 0) {\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\n            }\n            if (x & 0x8000000000000 > 0) {\n                result = (result * 0x100058BA01FB9F96D) >> 64;\n            }\n            if (x & 0x4000000000000 > 0) {\n                result = (result * 0x10002C5CC37DA9492) >> 64;\n            }\n            if (x & 0x2000000000000 > 0) {\n                result = (result * 0x1000162E525EE0547) >> 64;\n            }\n            if (x & 0x1000000000000 > 0) {\n                result = (result * 0x10000B17255775C04) >> 64;\n            }\n            if (x & 0x800000000000 > 0) {\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\n            }\n            if (x & 0x400000000000 > 0) {\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\n            }\n            if (x & 0x200000000000 > 0) {\n                result = (result * 0x10000162E43F4F831) >> 64;\n            }\n            if (x & 0x100000000000 > 0) {\n                result = (result * 0x100000B1721BCFC9A) >> 64;\n            }\n            if (x & 0x80000000000 > 0) {\n                result = (result * 0x10000058B90CF1E6E) >> 64;\n            }\n            if (x & 0x40000000000 > 0) {\n                result = (result * 0x1000002C5C863B73F) >> 64;\n            }\n            if (x & 0x20000000000 > 0) {\n                result = (result * 0x100000162E430E5A2) >> 64;\n            }\n            if (x & 0x10000000000 > 0) {\n                result = (result * 0x1000000B172183551) >> 64;\n            }\n            if (x & 0x8000000000 > 0) {\n                result = (result * 0x100000058B90C0B49) >> 64;\n            }\n            if (x & 0x4000000000 > 0) {\n                result = (result * 0x10000002C5C8601CC) >> 64;\n            }\n            if (x & 0x2000000000 > 0) {\n                result = (result * 0x1000000162E42FFF0) >> 64;\n            }\n            if (x & 0x1000000000 > 0) {\n                result = (result * 0x10000000B17217FBB) >> 64;\n            }\n            if (x & 0x800000000 > 0) {\n                result = (result * 0x1000000058B90BFCE) >> 64;\n            }\n            if (x & 0x400000000 > 0) {\n                result = (result * 0x100000002C5C85FE3) >> 64;\n            }\n            if (x & 0x200000000 > 0) {\n                result = (result * 0x10000000162E42FF1) >> 64;\n            }\n            if (x & 0x100000000 > 0) {\n                result = (result * 0x100000000B17217F8) >> 64;\n            }\n            if (x & 0x80000000 > 0) {\n                result = (result * 0x10000000058B90BFC) >> 64;\n            }\n            if (x & 0x40000000 > 0) {\n                result = (result * 0x1000000002C5C85FE) >> 64;\n            }\n            if (x & 0x20000000 > 0) {\n                result = (result * 0x100000000162E42FF) >> 64;\n            }\n            if (x & 0x10000000 > 0) {\n                result = (result * 0x1000000000B17217F) >> 64;\n            }\n            if (x & 0x8000000 > 0) {\n                result = (result * 0x100000000058B90C0) >> 64;\n            }\n            if (x & 0x4000000 > 0) {\n                result = (result * 0x10000000002C5C860) >> 64;\n            }\n            if (x & 0x2000000 > 0) {\n                result = (result * 0x1000000000162E430) >> 64;\n            }\n            if (x & 0x1000000 > 0) {\n                result = (result * 0x10000000000B17218) >> 64;\n            }\n            if (x & 0x800000 > 0) {\n                result = (result * 0x1000000000058B90C) >> 64;\n            }\n            if (x & 0x400000 > 0) {\n                result = (result * 0x100000000002C5C86) >> 64;\n            }\n            if (x & 0x200000 > 0) {\n                result = (result * 0x10000000000162E43) >> 64;\n            }\n            if (x & 0x100000 > 0) {\n                result = (result * 0x100000000000B1721) >> 64;\n            }\n            if (x & 0x80000 > 0) {\n                result = (result * 0x10000000000058B91) >> 64;\n            }\n            if (x & 0x40000 > 0) {\n                result = (result * 0x1000000000002C5C8) >> 64;\n            }\n            if (x & 0x20000 > 0) {\n                result = (result * 0x100000000000162E4) >> 64;\n            }\n            if (x & 0x10000 > 0) {\n                result = (result * 0x1000000000000B172) >> 64;\n            }\n            if (x & 0x8000 > 0) {\n                result = (result * 0x100000000000058B9) >> 64;\n            }\n            if (x & 0x4000 > 0) {\n                result = (result * 0x10000000000002C5D) >> 64;\n            }\n            if (x & 0x2000 > 0) {\n                result = (result * 0x1000000000000162E) >> 64;\n            }\n            if (x & 0x1000 > 0) {\n                result = (result * 0x10000000000000B17) >> 64;\n            }\n            if (x & 0x800 > 0) {\n                result = (result * 0x1000000000000058C) >> 64;\n            }\n            if (x & 0x400 > 0) {\n                result = (result * 0x100000000000002C6) >> 64;\n            }\n            if (x & 0x200 > 0) {\n                result = (result * 0x10000000000000163) >> 64;\n            }\n            if (x & 0x100 > 0) {\n                result = (result * 0x100000000000000B1) >> 64;\n            }\n            if (x & 0x80 > 0) {\n                result = (result * 0x10000000000000059) >> 64;\n            }\n            if (x & 0x40 > 0) {\n                result = (result * 0x1000000000000002C) >> 64;\n            }\n            if (x & 0x20 > 0) {\n                result = (result * 0x10000000000000016) >> 64;\n            }\n            if (x & 0x10 > 0) {\n                result = (result * 0x1000000000000000B) >> 64;\n            }\n            if (x & 0x8 > 0) {\n                result = (result * 0x10000000000000006) >> 64;\n            }\n            if (x & 0x4 > 0) {\n                result = (result * 0x10000000000000003) >> 64;\n            }\n            if (x & 0x2 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n            if (x & 0x1 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n\n            // We're doing two things at the same time:\n            //\n            //   1. Multiply the result by 2^n + 1, where \"2^n\" is the integer part and the one is added to account for\n            //      the fact that we initially set the result to 0.5. This is accomplished by subtracting from 191\n            //      rather than 192.\n            //   2. Convert the result to the unsigned 60.18-decimal fixed-point format.\n            //\n            // This works because 2^(191-ip) = 2^ip / 2^191, where \"ip\" is the integer part \"2^n\".\n            result *= SCALE;\n            result >>= (191 - (x >> 64));\n        }\n    }\n\n    /// @notice Finds the zero-based index of the first one in the binary representation of x.\n    /// @dev See the note on msb in the \"Find First Set\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\n    /// @param x The uint256 number for which to find the index of the most significant bit.\n    /// @return msb The index of the most significant bit as an uint256.\n    function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\n        if (x >= 2**128) {\n            x >>= 128;\n            msb += 128;\n        }\n        if (x >= 2**64) {\n            x >>= 64;\n            msb += 64;\n        }\n        if (x >= 2**32) {\n            x >>= 32;\n            msb += 32;\n        }\n        if (x >= 2**16) {\n            x >>= 16;\n            msb += 16;\n        }\n        if (x >= 2**8) {\n            x >>= 8;\n            msb += 8;\n        }\n        if (x >= 2**4) {\n            x >>= 4;\n            msb += 4;\n        }\n        if (x >= 2**2) {\n            x >>= 2;\n            msb += 2;\n        }\n        if (x >= 2**1) {\n            // No need to shift x any more.\n            msb += 1;\n        }\n    }\n\n    /// @notice Calculates floor(x*y÷denominator) with full precision.\n    ///\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\n    ///\n    /// Requirements:\n    /// - The denominator cannot be zero.\n    /// - The result must fit within uint256.\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers.\n    ///\n    /// @param x The multiplicand as an uint256.\n    /// @param y The multiplier as an uint256.\n    /// @param denominator The divisor as an uint256.\n    /// @return result The result as an uint256.\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2^256 + prod0.\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division.\n        if (prod1 == 0) {\n            unchecked {\n                result = prod0 / denominator;\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2^256. Also prevents denominator == 0.\n        if (prod1 >= denominator) {\n            revert PRBMath__MulDivOverflow(prod1, denominator);\n        }\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0].\n        uint256 remainder;\n        assembly {\n            // Compute remainder using mulmod.\n            remainder := mulmod(x, y, denominator)\n\n            // Subtract 256 bit number from 512 bit number.\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n        // See https://cs.stackexchange.com/q/138556/92363.\n        unchecked {\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 lpotdod = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by lpotdod.\n                denominator := div(denominator, lpotdod)\n\n                // Divide [prod1 prod0] by lpotdod.\n                prod0 := div(prod0, lpotdod)\n\n                // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one.\n                lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * lpotdod;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /// @notice Calculates floor(x*y÷1e18) with full precision.\n    ///\n    /// @dev Variant of \"mulDiv\" with constant folding, i.e. in which the denominator is always 1e18. Before returning the\n    /// final result, we add 1 if (x * y) % SCALE >= HALF_SCALE. Without this, 6.6e-19 would be truncated to 0 instead of\n    /// being rounded to 1e-18.  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717.\n    ///\n    /// Requirements:\n    /// - The result must fit within uint256.\n    ///\n    /// Caveats:\n    /// - The body is purposely left uncommented; see the NatSpec comments in \"PRBMath.mulDiv\" to understand how this works.\n    /// - It is assumed that the result can never be type(uint256).max when x and y solve the following two equations:\n    ///     1. x * y = type(uint256).max * SCALE\n    ///     2. (x * y) % SCALE >= SCALE / 2\n    ///\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function mulDivFixedPoint(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        uint256 prod0;\n        uint256 prod1;\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        if (prod1 >= SCALE) {\n            revert PRBMath__MulDivFixedPointOverflow(prod1);\n        }\n\n        uint256 remainder;\n        uint256 roundUpUnit;\n        assembly {\n            remainder := mulmod(x, y, SCALE)\n            roundUpUnit := gt(remainder, 499999999999999999)\n        }\n\n        if (prod1 == 0) {\n            unchecked {\n                result = (prod0 / SCALE) + roundUpUnit;\n                return result;\n            }\n        }\n\n        assembly {\n            result := add(\n                mul(\n                    or(\n                        div(sub(prod0, remainder), SCALE_LPOTD),\n                        mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, SCALE_LPOTD), SCALE_LPOTD), 1))\n                    ),\n                    SCALE_INVERSE\n                ),\n                roundUpUnit\n            )\n        }\n    }\n\n    /// @notice Calculates floor(x*y÷denominator) with full precision.\n    ///\n    /// @dev An extension of \"mulDiv\" for signed numbers. Works by computing the signs and the absolute values separately.\n    ///\n    /// Requirements:\n    /// - None of the inputs can be type(int256).min.\n    /// - The result must fit within int256.\n    ///\n    /// @param x The multiplicand as an int256.\n    /// @param y The multiplier as an int256.\n    /// @param denominator The divisor as an int256.\n    /// @return result The result as an int256.\n    function mulDivSigned(\n        int256 x,\n        int256 y,\n        int256 denominator\n    ) internal pure returns (int256 result) {\n        if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\n            revert PRBMath__MulDivSignedInputTooSmall();\n        }\n\n        // Get hold of the absolute values of x, y and the denominator.\n        uint256 ax;\n        uint256 ay;\n        uint256 ad;\n        unchecked {\n            ax = x < 0 ? uint256(-x) : uint256(x);\n            ay = y < 0 ? uint256(-y) : uint256(y);\n            ad = denominator < 0 ? uint256(-denominator) : uint256(denominator);\n        }\n\n        // Compute the absolute value of (x*y)÷denominator. The result must fit within int256.\n        uint256 rAbs = mulDiv(ax, ay, ad);\n        if (rAbs > uint256(type(int256).max)) {\n            revert PRBMath__MulDivSignedOverflow(rAbs);\n        }\n\n        // Get the signs of x, y and the denominator.\n        uint256 sx;\n        uint256 sy;\n        uint256 sd;\n        assembly {\n            sx := sgt(x, sub(0, 1))\n            sy := sgt(y, sub(0, 1))\n            sd := sgt(denominator, sub(0, 1))\n        }\n\n        // XOR over sx, sy and sd. This is checking whether there are one or three negative signs in the inputs.\n        // If yes, the result should be negative.\n        result = sx ^ sy ^ sd == 0 ? -int256(rAbs) : int256(rAbs);\n    }\n\n    /// @notice Calculates the square root of x, rounding down.\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers.\n    ///\n    /// @param x The uint256 number for which to calculate the square root.\n    /// @return result The result as an uint256.\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\n        if (x == 0) {\n            return 0;\n        }\n\n        // Set the initial guess to the least power of two that is greater than or equal to sqrt(x).\n        uint256 xAux = uint256(x);\n        result = 1;\n        if (xAux >= 0x100000000000000000000000000000000) {\n            xAux >>= 128;\n            result <<= 64;\n        }\n        if (xAux >= 0x10000000000000000) {\n            xAux >>= 64;\n            result <<= 32;\n        }\n        if (xAux >= 0x100000000) {\n            xAux >>= 32;\n            result <<= 16;\n        }\n        if (xAux >= 0x10000) {\n            xAux >>= 16;\n            result <<= 8;\n        }\n        if (xAux >= 0x100) {\n            xAux >>= 8;\n            result <<= 4;\n        }\n        if (xAux >= 0x10) {\n            xAux >>= 4;\n            result <<= 2;\n        }\n        if (xAux >= 0x8) {\n            result <<= 1;\n        }\n\n        // The operations can never overflow because the result is max 2^127 when it enters this block.\n        unchecked {\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1; // Seven iterations should be enough\n            uint256 roundedDownResult = x / result;\n            return result >= roundedDownResult ? roundedDownResult : result;\n        }\n    }\n}\n"
    },
    "contracts/core/PoolRouter.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"./interfaces/IERC677.sol\";\nimport \"./interfaces/IStakingPool.sol\";\nimport \"./interfaces/IDelegatorPool.sol\";\nimport \"../ethStaking/interfaces/IWrappedETH.sol\";\n\nimport \"hardhat/console.sol\";\n\n/**\n * @title PoolRouter\n * @dev Handles staking allowances and acts as a proxy for staking pools\n */\ncontract PoolRouter is Ownable {\n    using SafeERC20 for IERC677;\n\n    enum PoolStatus {\n        OPEN,\n        DRAINING,\n        CLOSED\n    }\n\n    struct Pool {\n        IERC677 token;\n        IStakingPool stakingPool;\n        PoolStatus status;\n        bool reservedModeActive;\n    }\n\n    IERC677 public immutable allowanceToken;\n    IDelegatorPool public delegatorPool;\n\n    mapping(bytes32 => Pool) private pools;\n    mapping(address => uint16) public poolCountByToken;\n    uint public poolCount;\n\n    address[] public tokens;\n    address public wrappedETH;\n\n    uint private reservedMultiplier;\n\n    event StakeToken(address indexed token, address indexed pool, address indexed account, uint amount);\n    event WithdrawToken(address indexed token, address indexed pool, address indexed account, uint amount);\n    event AddPool(address indexed token, address indexed pool);\n    event RemovePool(address indexed token, address indexed pool);\n\n    modifier poolExists(address _token, uint _index) {\n        require(poolCountByToken[_token] > _index, \"Pool does not exist\");\n        _;\n    }\n\n    constructor(address _allowanceToken) {\n        allowanceToken = IERC677(_allowanceToken);\n        reservedMultiplier = 1e4;\n    }\n\n    receive() external payable {}\n\n    /**\n     * @notice Returns a list of all supported tokens\n     * @return list of tokens\n     **/\n    function supportedTokens() external view returns (address[] memory) {\n        return tokens;\n    }\n\n    /**\n     * @notice Returns a pool\n     * @param _token pool token\n     * @param _index pool index\n     */\n    function getPool(address _token, uint16 _index) external view returns (Pool memory) {\n        return pools[_poolKey(_token, _index)];\n    }\n\n    /**\n     * @notice Fetch a list of all pools\n     * @return poolList list of all pools\n     **/\n    function allPools() external view returns (Pool[] memory poolList) {\n        poolList = new Pool[](poolCount);\n\n        uint index = 0;\n        for (uint i = 0; i < tokens.length; i++) {\n            address token = tokens[i];\n            for (uint16 j = 0; j < poolCountByToken[token]; j++) {\n                poolList[index] = pools[_poolKey(token, j)];\n                index++;\n            }\n        }\n    }\n\n    /**\n     * @notice returns whether any pool is in reserved mode\n     * @return reservedModeActive true/false\n     */\n    function isReservedMode() external view returns (bool) {\n        for (uint i = 0; i < tokens.length; i++) {\n            address token = tokens[i];\n            for (uint16 j = 0; j < poolCountByToken[token]; j++) {\n                if (pools[_poolKey(token, j)].reservedModeActive) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @notice returns the allocation multiplier while in reserved mode\n     * @return reservedMultiplier multiplier\n     */\n    function getReservedMultiplier() external view returns (uint) {\n        return reservedMultiplier;\n    }\n\n    /**\n     * @notice returns the percentange utilisation of the pool\n     * @param _token pool token\n     * @param _index pool index\n     * @return poolUtilisation percentage full (0-10000)\n     */\n    function poolUtilisation(address _token, uint16 _index) external view returns (uint) {\n        IStakingPool stakingPool = pools[_poolKey(_token, _index)].stakingPool;\n        uint totalSupply = stakingPool.totalSupply();\n        uint maxDeposits = stakingPool.getMaxDeposits();\n        return (maxDeposits > totalSupply) ? (1e18 * totalSupply) / maxDeposits : 1 ether;\n    }\n\n    /**\n     * @notice ERC677 implementation to receive a token stake\n     * @param _sender of the token transfer\n     * @param _value of the token transfer\n     * @param _calldata pool index\n     **/\n    function onTokenTransfer(\n        address _sender,\n        uint _value,\n        bytes calldata _calldata\n    ) external {\n        require(poolCountByToken[msg.sender] > 0, \"Only callable by supported tokens\");\n\n        uint16 index = SafeCast.toUint16(_bytesToUint(_calldata));\n        require(poolCountByToken[msg.sender] > index, \"Pool does not exist\");\n\n        _stake(msg.sender, index, _sender, _value);\n    }\n\n    /**\n     * @notice stakes tokens in a staking pool\n     * @param _token token to stake\n     * @param _index index of pool to stake in\n     * @param _amount amount to stake\n     **/\n    function stake(\n        address _token,\n        uint16 _index,\n        uint _amount\n    ) external poolExists(_token, _index) {\n        IERC677(_token).safeTransferFrom(msg.sender, address(this), _amount);\n        _stake(_token, _index, msg.sender, _amount);\n    }\n\n    /**\n     * @notice withdraws tokens from a staking pool\n     * @param _token token to withdraw\n     * @param _index pool index\n     * @param _amount amount to withdraw\n     **/\n    function withdraw(\n        address _token,\n        uint16 _index,\n        uint _amount\n    ) external poolExists(_token, _index) {\n        _withdraw(_token, _index, _amount, msg.sender);\n    }\n\n    /**\n     * @notice wraps ETH and stakes wrapped ETH in a staking pool\n     * @param _index index of pool to stake in\n     **/\n    function stakeETH(uint16 _index) external payable poolExists(wrappedETH, _index) {\n        IWrappedETH(wrappedETH).wrap{value: msg.value}();\n        _stake(wrappedETH, _index, msg.sender, msg.value);\n    }\n\n    /**\n     * @notice withdraws wrapped ETH from a staking pool and unwraps\n     * @param _index pool index\n     * @param _amount amount to withdraw\n     **/\n    function withdrawETH(uint16 _index, uint _amount) external poolExists(wrappedETH, _index) {\n        _withdraw(wrappedETH, _index, _amount, address(this));\n        IWrappedETH(wrappedETH).unwrap(_amount);\n        (bool success, ) = payable(msg.sender).call{value: _amount}(\"\");\n        require(success, \"ETH transfer failed\");\n    }\n\n    /**\n     * @notice adds a new pool\n     * @param _token staking token to add\n     * @param _stakingPool token staking pool\n     **/\n    function addPool(\n        address _token,\n        address _stakingPool,\n        PoolStatus _status,\n        bool _reservedModeActive\n    ) external onlyOwner {\n        poolCount++;\n        uint16 tokenPoolCount = poolCountByToken[_token];\n        Pool storage pool = pools[_poolKey(_token, tokenPoolCount)];\n\n        poolCountByToken[_token]++;\n        if (tokenPoolCount == 0) {\n            tokens.push(_token);\n        }\n\n        pool.token = IERC677(_token);\n        pool.stakingPool = IStakingPool(_stakingPool);\n        pool.status = _status;\n        pool.reservedModeActive = _reservedModeActive;\n\n        if (IERC677(_token).allowance(address(this), _stakingPool) == 0) {\n            IERC677(_token).safeApprove(_stakingPool, type(uint).max);\n        }\n\n        IStakingPool(_stakingPool).setPoolIndex(tokenPoolCount);\n\n        emit AddPool(_token, _stakingPool);\n    }\n\n    /**\n     * @notice removes an existing pool\n     * @param _token staking token\n     * @param _index index of pool to remove\n     **/\n    function removePool(address _token, uint16 _index) external onlyOwner poolExists(_token, _index) {\n        Pool storage pool = pools[_poolKey(_token, _index)];\n        require(pool.stakingPool.totalSupply() == 0, \"Can only remove a pool with no active stake\");\n\n        emit RemovePool(_token, address(pool.stakingPool));\n\n        uint16 lastPoolIndex = poolCountByToken[_token] - 1;\n\n        if (_index != lastPoolIndex) {\n            pools[_poolKey(_token, _index)] = pools[_poolKey(_token, lastPoolIndex)];\n            pools[_poolKey(_token, _index)].stakingPool.setPoolIndex(_index);\n        }\n\n        delete pools[_poolKey(_token, lastPoolIndex)];\n        poolCountByToken[_token]--;\n        poolCount--;\n\n        if (poolCountByToken[_token] == 0) {\n            for (uint i = 0; i < tokens.length; i++) {\n                if (tokens[i] == _token) {\n                    tokens[i] = tokens[tokens.length - 1];\n                    tokens.pop();\n                    break;\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice calculates the amount of stake an account can deposit based on it's allowance staked\n     * @param _account account address\n     * @param _token the token address used by the staking pool\n     * @param _index pool index\n     * @return amount that can be deposited\n     **/\n    function canDeposit(\n        address _account,\n        address _token,\n        uint16 _index\n    ) public view poolExists(_token, _index) returns (uint) {\n        IStakingPool stakingPool = pools[_poolKey(_token, _index)].stakingPool;\n        bool reservedModeActive = pools[_poolKey(_token, _index)].reservedModeActive;\n        uint maximumStake = stakingPool.canDeposit();\n\n        return reservedModeActive ? _reservedAllocation(_account, _token, _index, maximumStake) : maximumStake;\n    }\n\n    /**\n     * @notice calculates the amount of stake that can be deposited for an amount of allowance\n     * @param _token the token address used by the staking pool\n     * @param _index pool index\n     * @param _amount amount of allowance\n     * @return amount that can be deposited\n     **/\n    function canDepositByAllowance(\n        address _token,\n        uint16 _index,\n        uint _amount\n    ) public view poolExists(_token, _index) returns (uint) {\n        IStakingPool stakingPool = pools[_poolKey(_token, _index)].stakingPool;\n        bool reservedModeActive = pools[_poolKey(_token, _index)].reservedModeActive;\n        uint maximumStake = stakingPool.canDeposit();\n\n        uint accountMaxStake = (((((1e18 * _amount) / allowanceToken.totalSupply()) * stakingPool.getMaxDeposits()) / 1e18) /\n            1e4) * reservedMultiplier;\n\n        return (!reservedModeActive || accountMaxStake > maximumStake) ? maximumStake : accountMaxStake;\n    }\n\n    /**\n     * @notice sets a pool's status\n     * @param _token pool token\n     * @param _index pool index\n     * @param _status pool status\n     */\n    function setPoolStatus(\n        address _token,\n        uint16 _index,\n        PoolStatus _status\n    ) external poolExists(_token, _index) onlyOwner {\n        require(_status != PoolStatus.CLOSED, \"Cannot set status to CLOSED\");\n        pools[_poolKey(_token, _index)].status = _status;\n    }\n\n    /**\n     * @notice sets a pool's status to CLOSED\n     * @param _token pool token\n     * @param _index pool index\n     */\n    function setPoolStatusClosed(address _token, uint16 _index) external poolExists(_token, _index) onlyOwner {\n        pools[_poolKey(_token, _index)].status = PoolStatus.CLOSED;\n    }\n\n    /**\n     * @notice sets the wrapped ETH token\n     * @dev must be set for ETH staking to work, can only be set once\n     * @param _wrappedETH wrapped ETH token to set\n     **/\n    function setWrappedETH(address _wrappedETH) external onlyOwner {\n        require(wrappedETH == address(0), \"wrappedETH already set\");\n        wrappedETH = _wrappedETH;\n        IERC677(_wrappedETH).safeApprove(_wrappedETH, type(uint).max);\n    }\n\n    /**\n     * @notice sets the delegator pool address\n     * @dev must be set for pool router to work\n     * @param _delegatorPool delegator pool address\n     **/\n    function setDelegatorPool(address _delegatorPool) external onlyOwner {\n        require(address(delegatorPool) == address(0), \"delegatorPool already set\");\n        delegatorPool = IDelegatorPool(_delegatorPool);\n    }\n\n    /**\n     * @notice sets whether a pool is reserved by only the allowance stakers\n     * @param _token pool token\n     * @param _index pool index\n     * @param _reservedModeActive whether it is reserved only\n     **/\n    function setReservedModeActive(\n        address _token,\n        uint16 _index,\n        bool _reservedModeActive\n    ) external onlyOwner {\n        pools[_poolKey(_token, _index)].reservedModeActive = _reservedModeActive;\n    }\n\n    /**\n     * @notice sets the multiplier for stake per allowance when the pool has reserved space for allowance stakers\n     * @param _reservedMultiplier multiplier\n     **/\n    function setReservedSpaceMultiplier(uint _reservedMultiplier) external onlyOwner {\n        require(_reservedMultiplier >= 1e4, \"Invalid reserved space multiplier\");\n        reservedMultiplier = _reservedMultiplier;\n    }\n\n    /**\n     * @notice stakes tokens in a staking pool\n     * @param _token token to stake\n     * @param _index index of pool to stake in\n     * @param _account account to stake for\n     * @param _amount amount to stake\n     **/\n    function _stake(\n        address _token,\n        uint16 _index,\n        address _account,\n        uint _amount\n    ) private {\n        Pool storage pool = pools[_poolKey(_token, _index)];\n\n        require(pool.status == PoolStatus.OPEN, \"Pool is not open\");\n        require(_amount <= canDeposit(_account, _token, _index), \"Not enough allowance staked\");\n\n        pool.stakingPool.stake(_account, _amount);\n\n        emit StakeToken(_token, address(pool.stakingPool), _account, _amount);\n    }\n\n    /**\n     * @notice withdraws tokens from a staking pool\n     * @param _token token to withdraw\n     * @param _index pool index\n     * @param _amount amount to withdraw\n     * @param _receiver address to receive tokens\n     **/\n    function _withdraw(\n        address _token,\n        uint16 _index,\n        uint _amount,\n        address _receiver\n    ) private poolExists(_token, _index) {\n        Pool storage pool = pools[_poolKey(_token, _index)];\n        require(pool.status != PoolStatus.CLOSED, \"Pool is closed\");\n        require(pool.stakingPool.balanceOf(msg.sender) >= _amount, \"Amount exceeds staked balance\");\n\n        pool.stakingPool.withdraw(msg.sender, _receiver, _amount);\n\n        emit WithdrawToken(_token, address(pool.stakingPool), msg.sender, _amount);\n    }\n\n    /**\n     * @notice returns the reserved allocation for the user based on their amount of allocation staked in the delegator pool.\n     * If the user has no allowance staked, the public allocation is returned. The public allocation reduces the more allowance\n     * stakers reserve their space.\n     */\n    function _reservedAllocation(\n        address _account,\n        address _token,\n        uint16 _index,\n        uint _maximumStake\n    ) private view returns (uint) {\n        IStakingPool stakingPool = pools[_poolKey(_token, _index)].stakingPool;\n\n        if (delegatorPool.balanceOf(_account) == 0) {\n            return 0;\n        }\n        uint accountMaxStake = (((((1e18 * delegatorPool.balanceOf(_account)) / allowanceToken.totalSupply()) *\n            stakingPool.getMaxDeposits()) / 1e18) / 1e4) * reservedMultiplier;\n\n        if (stakingPool.balanceOf(_account) >= accountMaxStake) {\n            return 0;\n        }\n        return (accountMaxStake > _maximumStake) ? _maximumStake : accountMaxStake - stakingPool.balanceOf(_account);\n    }\n\n    /**\n     * @notice returns the pool key hash by token and index\n     * @param _token token\n     * @param _index pool index\n     * @return the hashed pool key\n     */\n    function _poolKey(address _token, uint16 _index) private pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_token, _index));\n    }\n\n    /**\n     * @notice converts bytes to uint\n     * @param _bytes to convert\n     * @return uint256 result\n     */\n    function _bytesToUint(bytes memory _bytes) private pure returns (uint256) {\n        uint256 number;\n        for (uint i = 0; i < _bytes.length; i++) {\n            number = number + uint(uint8(_bytes[i])) * (2**(8 * (_bytes.length - (i + 1))));\n        }\n        return number;\n    }\n}\n"
    },
    "contracts/core/interfaces/IDelegatorPool.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"./IERC677.sol\";\n\ninterface IDelegatorPool is IERC677 {\n    function currentRate(address _token, uint16 _index) external view returns (uint256);\n\n    function stakeAllowance(address _account, uint _amount) external;\n}\n"
    },
    "contracts/ethStaking/interfaces/IWrappedETH.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IWrappedETH is IERC20 {\n    function wrap() external payable;\n\n    function unwrap(uint256 _amount) external;\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n\t}\n\n\tfunction logUint(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/ethStaking/KeyValidationOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@chainlink/contracts/src/v0.8/ChainlinkClient.sol\";\n\nimport \"./interfaces/IOperatorController.sol\";\n\n/**\n * @title Key Validation Oracle\n * @notice Handles validator key/signature pair validation\n */\ncontract KeyValidationOracle is Ownable, ChainlinkClient {\n    using Chainlink for Chainlink.Request;\n\n    IOperatorController public nwlOperatorController;\n    IOperatorController public wlOperatorController;\n\n    uint public fee;\n    bytes32 public jobId;\n\n    event SetOracleConfig(address oracleAddress, bytes32 jobId, uint fee);\n\n    constructor(\n        address _nwlOperatorController,\n        address _wlOperatorController,\n        address _chainlinkToken,\n        address _chainlinkOracle,\n        bytes32 _jobId,\n        uint _fee\n    ) {\n        nwlOperatorController = IOperatorController(_nwlOperatorController);\n        wlOperatorController = IOperatorController(_wlOperatorController);\n        setChainlinkToken(_chainlinkToken);\n        setChainlinkOracle(_chainlinkOracle);\n        jobId = _jobId;\n        fee = _fee;\n    }\n\n    /**\n     * @notice ERC677 implementation that accepts a fee and initiates a key pair validation\n     * @param _sender sender of the token transfer\n     * @param _value value of the token transfer\n     * @param _calldata (operatorId - id of operator to validate for,\n     * isWhitelisted - whether or not operator is whitelisted) ABI encoded\n     */\n    function onTokenTransfer(\n        address _sender,\n        uint _value,\n        bytes calldata _calldata\n    ) external {\n        require(msg.sender == chainlinkTokenAddress(), \"Sender is not chainlink token\");\n        require(_value == fee, \"Value is not equal to fee\");\n\n        (uint operatorId, bool isWhitelisted) = abi.decode(_calldata, (uint, bool));\n\n        _initiateKeyPairValidation(_sender, operatorId, isWhitelisted);\n    }\n\n    /**\n     * @notice Reports the results of a validation request\n     * @param _requestId id of chainlink request\n     * @param _operatorId id of operator receiving the validation report\n     * @param _isWhitelisted whether or not operator is whitelisted\n     * @param _success whether or not validation was successful\n     */\n    function reportKeyPairValidation(\n        bytes32 _requestId,\n        uint _operatorId,\n        bool _isWhitelisted,\n        bool _success\n    ) external recordChainlinkFulfillment(_requestId) {\n        if (_isWhitelisted) {\n            wlOperatorController.reportKeyPairValidation(_operatorId, _success);\n        } else {\n            nwlOperatorController.reportKeyPairValidation(_operatorId, _success);\n        }\n    }\n\n    /**\n     * @notice Sets oracle config variables\n     * @param _oracleAddress address of oracle\n     * @param _jobId id of job\n     * @param _fee fee that must be paid for each request\n     */\n    function setOracleConfig(\n        address _oracleAddress,\n        bytes32 _jobId,\n        uint _fee\n    ) external onlyOwner {\n        setChainlinkOracle(_oracleAddress);\n        jobId = _jobId;\n        fee = _fee;\n        emit SetOracleConfig(_oracleAddress, _jobId, _fee);\n    }\n\n    /**\n     * @notice Returns the chainlink oracle address\n     * @return oracleAddress oracle address\n     */\n    function oracleAddress() external view returns (address) {\n        return chainlinkOracleAddress();\n    }\n\n    /**\n     * @notice Constructs and sends a key pair validation request\n     * @param _sender sender of request\n     * @param _operatorId id of operator to validate for\n     * @param _isWhitelisted whether or not operator is whitelisted\n     */\n    function _initiateKeyPairValidation(\n        address _sender,\n        uint _operatorId,\n        bool _isWhitelisted\n    ) private {\n        if (_isWhitelisted) {\n            wlOperatorController.initiateKeyPairValidation(_sender, _operatorId);\n        } else {\n            nwlOperatorController.initiateKeyPairValidation(_sender, _operatorId);\n        }\n\n        Chainlink.Request memory req = buildChainlinkRequest(jobId, address(this), this.reportKeyPairValidation.selector);\n\n        req.add(\"operatorId\", Strings.toString(_operatorId));\n        req.add(\"isWhitelisted\", _isWhitelisted ? \"true\" : \"false\");\n\n        sendChainlinkRequest(req, fee);\n    }\n}\n"
    },
    "contracts/ethStaking/interfaces/IOperatorController.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\ninterface IOperatorController {\n    function initiateKeyPairValidation(address _sender, uint _operatorId) external;\n\n    function reportKeyPairValidation(uint _operatorId, bool _success) external;\n\n    function queueLength() external view returns (uint);\n\n    function totalActiveValidators() external view returns (uint);\n\n    function currentStateHash() external view returns (bytes32);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/ChainlinkClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./Chainlink.sol\";\nimport \"./interfaces/ENSInterface.sol\";\nimport \"./interfaces/LinkTokenInterface.sol\";\nimport \"./interfaces/ChainlinkRequestInterface.sol\";\nimport \"./interfaces/OperatorInterface.sol\";\nimport \"./interfaces/PointerInterface.sol\";\nimport {ENSResolver as ENSResolver_Chainlink} from \"./vendor/ENSResolver.sol\";\n\n/**\n * @title The ChainlinkClient contract\n * @notice Contract writers can inherit this contract in order to create requests for the\n * Chainlink network\n */\nabstract contract ChainlinkClient {\n  using Chainlink for Chainlink.Request;\n\n  uint256 internal constant LINK_DIVISIBILITY = 10**18;\n  uint256 private constant AMOUNT_OVERRIDE = 0;\n  address private constant SENDER_OVERRIDE = address(0);\n  uint256 private constant ORACLE_ARGS_VERSION = 1;\n  uint256 private constant OPERATOR_ARGS_VERSION = 2;\n  bytes32 private constant ENS_TOKEN_SUBNAME = keccak256(\"link\");\n  bytes32 private constant ENS_ORACLE_SUBNAME = keccak256(\"oracle\");\n  address private constant LINK_TOKEN_POINTER = 0xC89bD4E1632D3A43CB03AAAd5262cbe4038Bc571;\n\n  ENSInterface private s_ens;\n  bytes32 private s_ensNode;\n  LinkTokenInterface private s_link;\n  OperatorInterface private s_oracle;\n  uint256 private s_requestCount = 1;\n  mapping(bytes32 => address) private s_pendingRequests;\n\n  event ChainlinkRequested(bytes32 indexed id);\n  event ChainlinkFulfilled(bytes32 indexed id);\n  event ChainlinkCancelled(bytes32 indexed id);\n\n  /**\n   * @notice Creates a request that can hold additional parameters\n   * @param specId The Job Specification ID that the request will be created for\n   * @param callbackAddr address to operate the callback on\n   * @param callbackFunctionSignature function signature to use for the callback\n   * @return A Chainlink Request struct in memory\n   */\n  function buildChainlinkRequest(\n    bytes32 specId,\n    address callbackAddr,\n    bytes4 callbackFunctionSignature\n  ) internal pure returns (Chainlink.Request memory) {\n    Chainlink.Request memory req;\n    return req.initialize(specId, callbackAddr, callbackFunctionSignature);\n  }\n\n  /**\n   * @notice Creates a request that can hold additional parameters\n   * @param specId The Job Specification ID that the request will be created for\n   * @param callbackFunctionSignature function signature to use for the callback\n   * @return A Chainlink Request struct in memory\n   */\n  function buildOperatorRequest(bytes32 specId, bytes4 callbackFunctionSignature)\n    internal\n    view\n    returns (Chainlink.Request memory)\n  {\n    Chainlink.Request memory req;\n    return req.initialize(specId, address(this), callbackFunctionSignature);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the stored oracle address\n   * @dev Calls `chainlinkRequestTo` with the stored oracle address\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendChainlinkRequest(Chainlink.Request memory req, uint256 payment) internal returns (bytes32) {\n    return sendChainlinkRequestTo(address(s_oracle), req, payment);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the specified oracle address\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\n   * send LINK which creates a request on the target oracle contract.\n   * Emits ChainlinkRequested event.\n   * @param oracleAddress The address of the oracle for the request\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendChainlinkRequestTo(\n    address oracleAddress,\n    Chainlink.Request memory req,\n    uint256 payment\n  ) internal returns (bytes32 requestId) {\n    uint256 nonce = s_requestCount;\n    s_requestCount = nonce + 1;\n    bytes memory encodedRequest = abi.encodeWithSelector(\n      ChainlinkRequestInterface.oracleRequest.selector,\n      SENDER_OVERRIDE, // Sender value - overridden by onTokenTransfer by the requesting contract's address\n      AMOUNT_OVERRIDE, // Amount value - overridden by onTokenTransfer by the actual amount of LINK sent\n      req.id,\n      address(this),\n      req.callbackFunctionId,\n      nonce,\n      ORACLE_ARGS_VERSION,\n      req.buf.buf\n    );\n    return _rawRequest(oracleAddress, nonce, payment, encodedRequest);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the stored oracle address\n   * @dev This function supports multi-word response\n   * @dev Calls `sendOperatorRequestTo` with the stored oracle address\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendOperatorRequest(Chainlink.Request memory req, uint256 payment) internal returns (bytes32) {\n    return sendOperatorRequestTo(address(s_oracle), req, payment);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the specified oracle address\n   * @dev This function supports multi-word response\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\n   * send LINK which creates a request on the target oracle contract.\n   * Emits ChainlinkRequested event.\n   * @param oracleAddress The address of the oracle for the request\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendOperatorRequestTo(\n    address oracleAddress,\n    Chainlink.Request memory req,\n    uint256 payment\n  ) internal returns (bytes32 requestId) {\n    uint256 nonce = s_requestCount;\n    s_requestCount = nonce + 1;\n    bytes memory encodedRequest = abi.encodeWithSelector(\n      OperatorInterface.operatorRequest.selector,\n      SENDER_OVERRIDE, // Sender value - overridden by onTokenTransfer by the requesting contract's address\n      AMOUNT_OVERRIDE, // Amount value - overridden by onTokenTransfer by the actual amount of LINK sent\n      req.id,\n      req.callbackFunctionId,\n      nonce,\n      OPERATOR_ARGS_VERSION,\n      req.buf.buf\n    );\n    return _rawRequest(oracleAddress, nonce, payment, encodedRequest);\n  }\n\n  /**\n   * @notice Make a request to an oracle\n   * @param oracleAddress The address of the oracle for the request\n   * @param nonce used to generate the request ID\n   * @param payment The amount of LINK to send for the request\n   * @param encodedRequest data encoded for request type specific format\n   * @return requestId The request ID\n   */\n  function _rawRequest(\n    address oracleAddress,\n    uint256 nonce,\n    uint256 payment,\n    bytes memory encodedRequest\n  ) private returns (bytes32 requestId) {\n    requestId = keccak256(abi.encodePacked(this, nonce));\n    s_pendingRequests[requestId] = oracleAddress;\n    emit ChainlinkRequested(requestId);\n    require(s_link.transferAndCall(oracleAddress, payment, encodedRequest), \"unable to transferAndCall to oracle\");\n  }\n\n  /**\n   * @notice Allows a request to be cancelled if it has not been fulfilled\n   * @dev Requires keeping track of the expiration value emitted from the oracle contract.\n   * Deletes the request from the `pendingRequests` mapping.\n   * Emits ChainlinkCancelled event.\n   * @param requestId The request ID\n   * @param payment The amount of LINK sent for the request\n   * @param callbackFunc The callback function specified for the request\n   * @param expiration The time of the expiration for the request\n   */\n  function cancelChainlinkRequest(\n    bytes32 requestId,\n    uint256 payment,\n    bytes4 callbackFunc,\n    uint256 expiration\n  ) internal {\n    OperatorInterface requested = OperatorInterface(s_pendingRequests[requestId]);\n    delete s_pendingRequests[requestId];\n    emit ChainlinkCancelled(requestId);\n    requested.cancelOracleRequest(requestId, payment, callbackFunc, expiration);\n  }\n\n  /**\n   * @notice the next request count to be used in generating a nonce\n   * @dev starts at 1 in order to ensure consistent gas cost\n   * @return returns the next request count to be used in a nonce\n   */\n  function getNextRequestCount() internal view returns (uint256) {\n    return s_requestCount;\n  }\n\n  /**\n   * @notice Sets the stored oracle address\n   * @param oracleAddress The address of the oracle contract\n   */\n  function setChainlinkOracle(address oracleAddress) internal {\n    s_oracle = OperatorInterface(oracleAddress);\n  }\n\n  /**\n   * @notice Sets the LINK token address\n   * @param linkAddress The address of the LINK token contract\n   */\n  function setChainlinkToken(address linkAddress) internal {\n    s_link = LinkTokenInterface(linkAddress);\n  }\n\n  /**\n   * @notice Sets the Chainlink token address for the public\n   * network as given by the Pointer contract\n   */\n  function setPublicChainlinkToken() internal {\n    setChainlinkToken(PointerInterface(LINK_TOKEN_POINTER).getAddress());\n  }\n\n  /**\n   * @notice Retrieves the stored address of the LINK token\n   * @return The address of the LINK token\n   */\n  function chainlinkTokenAddress() internal view returns (address) {\n    return address(s_link);\n  }\n\n  /**\n   * @notice Retrieves the stored address of the oracle contract\n   * @return The address of the oracle contract\n   */\n  function chainlinkOracleAddress() internal view returns (address) {\n    return address(s_oracle);\n  }\n\n  /**\n   * @notice Allows for a request which was created on another contract to be fulfilled\n   * on this contract\n   * @param oracleAddress The address of the oracle contract that will fulfill the request\n   * @param requestId The request ID used for the response\n   */\n  function addChainlinkExternalRequest(address oracleAddress, bytes32 requestId) internal notPendingRequest(requestId) {\n    s_pendingRequests[requestId] = oracleAddress;\n  }\n\n  /**\n   * @notice Sets the stored oracle and LINK token contracts with the addresses resolved by ENS\n   * @dev Accounts for subnodes having different resolvers\n   * @param ensAddress The address of the ENS contract\n   * @param node The ENS node hash\n   */\n  function useChainlinkWithENS(address ensAddress, bytes32 node) internal {\n    s_ens = ENSInterface(ensAddress);\n    s_ensNode = node;\n    bytes32 linkSubnode = keccak256(abi.encodePacked(s_ensNode, ENS_TOKEN_SUBNAME));\n    ENSResolver_Chainlink resolver = ENSResolver_Chainlink(s_ens.resolver(linkSubnode));\n    setChainlinkToken(resolver.addr(linkSubnode));\n    updateChainlinkOracleWithENS();\n  }\n\n  /**\n   * @notice Sets the stored oracle contract with the address resolved by ENS\n   * @dev This may be called on its own as long as `useChainlinkWithENS` has been called previously\n   */\n  function updateChainlinkOracleWithENS() internal {\n    bytes32 oracleSubnode = keccak256(abi.encodePacked(s_ensNode, ENS_ORACLE_SUBNAME));\n    ENSResolver_Chainlink resolver = ENSResolver_Chainlink(s_ens.resolver(oracleSubnode));\n    setChainlinkOracle(resolver.addr(oracleSubnode));\n  }\n\n  /**\n   * @notice Ensures that the fulfillment is valid for this contract\n   * @dev Use if the contract developer prefers methods instead of modifiers for validation\n   * @param requestId The request ID for fulfillment\n   */\n  function validateChainlinkCallback(bytes32 requestId)\n    internal\n    recordChainlinkFulfillment(requestId)\n  // solhint-disable-next-line no-empty-blocks\n  {\n\n  }\n\n  /**\n   * @dev Reverts if the sender is not the oracle of the request.\n   * Emits ChainlinkFulfilled event.\n   * @param requestId The request ID for fulfillment\n   */\n  modifier recordChainlinkFulfillment(bytes32 requestId) {\n    require(msg.sender == s_pendingRequests[requestId], \"Source must be the oracle of the request\");\n    delete s_pendingRequests[requestId];\n    emit ChainlinkFulfilled(requestId);\n    _;\n  }\n\n  /**\n   * @dev Reverts if the request is already pending\n   * @param requestId The request ID for fulfillment\n   */\n  modifier notPendingRequest(bytes32 requestId) {\n    require(s_pendingRequests[requestId] == address(0), \"Request is already pending\");\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/Chainlink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {CBORChainlink} from \"./vendor/CBORChainlink.sol\";\nimport {BufferChainlink} from \"./vendor/BufferChainlink.sol\";\n\n/**\n * @title Library for common Chainlink functions\n * @dev Uses imported CBOR library for encoding to buffer\n */\nlibrary Chainlink {\n  uint256 internal constant defaultBufferSize = 256; // solhint-disable-line const-name-snakecase\n\n  using CBORChainlink for BufferChainlink.buffer;\n\n  struct Request {\n    bytes32 id;\n    address callbackAddress;\n    bytes4 callbackFunctionId;\n    uint256 nonce;\n    BufferChainlink.buffer buf;\n  }\n\n  /**\n   * @notice Initializes a Chainlink request\n   * @dev Sets the ID, callback address, and callback function signature on the request\n   * @param self The uninitialized request\n   * @param jobId The Job Specification ID\n   * @param callbackAddr The callback address\n   * @param callbackFunc The callback function signature\n   * @return The initialized request\n   */\n  function initialize(\n    Request memory self,\n    bytes32 jobId,\n    address callbackAddr,\n    bytes4 callbackFunc\n  ) internal pure returns (Chainlink.Request memory) {\n    BufferChainlink.init(self.buf, defaultBufferSize);\n    self.id = jobId;\n    self.callbackAddress = callbackAddr;\n    self.callbackFunctionId = callbackFunc;\n    return self;\n  }\n\n  /**\n   * @notice Sets the data for the buffer without encoding CBOR on-chain\n   * @dev CBOR can be closed with curly-brackets {} or they can be left off\n   * @param self The initialized request\n   * @param data The CBOR data\n   */\n  function setBuffer(Request memory self, bytes memory data) internal pure {\n    BufferChainlink.init(self.buf, data.length);\n    BufferChainlink.append(self.buf, data);\n  }\n\n  /**\n   * @notice Adds a string value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The string value to add\n   */\n  function add(\n    Request memory self,\n    string memory key,\n    string memory value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeString(value);\n  }\n\n  /**\n   * @notice Adds a bytes value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The bytes value to add\n   */\n  function addBytes(\n    Request memory self,\n    string memory key,\n    bytes memory value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeBytes(value);\n  }\n\n  /**\n   * @notice Adds a int256 value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The int256 value to add\n   */\n  function addInt(\n    Request memory self,\n    string memory key,\n    int256 value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeInt(value);\n  }\n\n  /**\n   * @notice Adds a uint256 value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The uint256 value to add\n   */\n  function addUint(\n    Request memory self,\n    string memory key,\n    uint256 value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeUInt(value);\n  }\n\n  /**\n   * @notice Adds an array of strings to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param values The array of string values to add\n   */\n  function addStringArray(\n    Request memory self,\n    string memory key,\n    string[] memory values\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.startArray();\n    for (uint256 i = 0; i < values.length; i++) {\n      self.buf.encodeString(values[i]);\n    }\n    self.buf.endSequence();\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n  function approve(address spender, uint256 value) external returns (bool success);\n\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  function decimals() external view returns (uint8 decimalPlaces);\n\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n\n  function name() external view returns (string memory tokenName);\n\n  function symbol() external view returns (string memory tokenSymbol);\n\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n\n  function transfer(address to, uint256 value) external returns (bool success);\n\n  function transferAndCall(\n    address to,\n    uint256 value,\n    bytes calldata data\n  ) external returns (bool success);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool success);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/ChainlinkRequestInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ChainlinkRequestInterface {\n  function oracleRequest(\n    address sender,\n    uint256 requestPrice,\n    bytes32 serviceAgreementID,\n    address callbackAddress,\n    bytes4 callbackFunctionId,\n    uint256 nonce,\n    uint256 dataVersion,\n    bytes calldata data\n  ) external;\n\n  function cancelOracleRequest(\n    bytes32 requestId,\n    uint256 payment,\n    bytes4 callbackFunctionId,\n    uint256 expiration\n  ) external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/ENSInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ENSInterface {\n  // Logged when the owner of a node assigns a new owner to a subnode.\n  event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n  // Logged when the owner of a node transfers ownership to a new account.\n  event Transfer(bytes32 indexed node, address owner);\n\n  // Logged when the resolver for a node changes.\n  event NewResolver(bytes32 indexed node, address resolver);\n\n  // Logged when the TTL of a node changes\n  event NewTTL(bytes32 indexed node, uint64 ttl);\n\n  function setSubnodeOwner(\n    bytes32 node,\n    bytes32 label,\n    address owner\n  ) external;\n\n  function setResolver(bytes32 node, address resolver) external;\n\n  function setOwner(bytes32 node, address owner) external;\n\n  function setTTL(bytes32 node, uint64 ttl) external;\n\n  function owner(bytes32 node) external view returns (address);\n\n  function resolver(bytes32 node) external view returns (address);\n\n  function ttl(bytes32 node) external view returns (uint64);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/OperatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./OracleInterface.sol\";\nimport \"./ChainlinkRequestInterface.sol\";\n\ninterface OperatorInterface is OracleInterface, ChainlinkRequestInterface {\n  function operatorRequest(\n    address sender,\n    uint256 payment,\n    bytes32 specId,\n    bytes4 callbackFunctionId,\n    uint256 nonce,\n    uint256 dataVersion,\n    bytes calldata data\n  ) external;\n\n  function fulfillOracleRequest2(\n    bytes32 requestId,\n    uint256 payment,\n    address callbackAddress,\n    bytes4 callbackFunctionId,\n    uint256 expiration,\n    bytes calldata data\n  ) external returns (bool);\n\n  function ownerTransferAndCall(\n    address to,\n    uint256 value,\n    bytes calldata data\n  ) external returns (bool success);\n\n  function distributeFunds(address payable[] calldata receivers, uint256[] calldata amounts) external payable;\n\n  function getAuthorizedSenders() external returns (address[] memory);\n\n  function setAuthorizedSenders(address[] calldata senders) external;\n\n  function getForwarder() external returns (address);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/PointerInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface PointerInterface {\n  function getAddress() external view returns (address);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vendor/ENSResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract ENSResolver {\n  function addr(bytes32 node) public view virtual returns (address);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vendor/BufferChainlink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @dev A library for working with mutable byte buffers in Solidity.\n *\n * Byte buffers are mutable and expandable, and provide a variety of primitives\n * for writing to them. At any time you can fetch a bytes object containing the\n * current contents of the buffer. The bytes object should not be stored between\n * operations, as it may change due to resizing of the buffer.\n */\nlibrary BufferChainlink {\n  /**\n   * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n   *      a capacity. The capacity may be longer than the current value, in\n   *      which case it can be extended without the need to allocate more memory.\n   */\n  struct buffer {\n    bytes buf;\n    uint256 capacity;\n  }\n\n  /**\n   * @dev Initializes a buffer with an initial capacity.\n   * @param buf The buffer to initialize.\n   * @param capacity The number of bytes of space to allocate the buffer.\n   * @return The buffer, for chaining.\n   */\n  function init(buffer memory buf, uint256 capacity) internal pure returns (buffer memory) {\n    if (capacity % 32 != 0) {\n      capacity += 32 - (capacity % 32);\n    }\n    // Allocate space for the buffer data\n    buf.capacity = capacity;\n    assembly {\n      let ptr := mload(0x40)\n      mstore(buf, ptr)\n      mstore(ptr, 0)\n      mstore(0x40, add(32, add(ptr, capacity)))\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Initializes a new buffer from an existing bytes object.\n   *      Changes to the buffer may mutate the original value.\n   * @param b The bytes object to initialize the buffer with.\n   * @return A new buffer.\n   */\n  function fromBytes(bytes memory b) internal pure returns (buffer memory) {\n    buffer memory buf;\n    buf.buf = b;\n    buf.capacity = b.length;\n    return buf;\n  }\n\n  function resize(buffer memory buf, uint256 capacity) private pure {\n    bytes memory oldbuf = buf.buf;\n    init(buf, capacity);\n    append(buf, oldbuf);\n  }\n\n  function max(uint256 a, uint256 b) private pure returns (uint256) {\n    if (a > b) {\n      return a;\n    }\n    return b;\n  }\n\n  /**\n   * @dev Sets buffer length to 0.\n   * @param buf The buffer to truncate.\n   * @return The original buffer, for chaining..\n   */\n  function truncate(buffer memory buf) internal pure returns (buffer memory) {\n    assembly {\n      let bufptr := mload(buf)\n      mstore(bufptr, 0)\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The start offset to write to.\n   * @param data The data to append.\n   * @param len The number of bytes to copy.\n   * @return The original buffer, for chaining.\n   */\n  function write(\n    buffer memory buf,\n    uint256 off,\n    bytes memory data,\n    uint256 len\n  ) internal pure returns (buffer memory) {\n    require(len <= data.length);\n\n    if (off + len > buf.capacity) {\n      resize(buf, max(buf.capacity, len + off) * 2);\n    }\n\n    uint256 dest;\n    uint256 src;\n    assembly {\n      // Memory address of the buffer data\n      let bufptr := mload(buf)\n      // Length of existing buffer data\n      let buflen := mload(bufptr)\n      // Start address = buffer address + offset + sizeof(buffer length)\n      dest := add(add(bufptr, 32), off)\n      // Update buffer length if we're extending it\n      if gt(add(len, off), buflen) {\n        mstore(bufptr, add(len, off))\n      }\n      src := add(data, 32)\n    }\n\n    // Copy word-length chunks while possible\n    for (; len >= 32; len -= 32) {\n      assembly {\n        mstore(dest, mload(src))\n      }\n      dest += 32;\n      src += 32;\n    }\n\n    // Copy remaining bytes\n    unchecked {\n      uint256 mask = (256**(32 - len)) - 1;\n      assembly {\n        let srcpart := and(mload(src), not(mask))\n        let destpart := and(mload(dest), mask)\n        mstore(dest, or(destpart, srcpart))\n      }\n    }\n\n    return buf;\n  }\n\n  /**\n   * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @param len The number of bytes to copy.\n   * @return The original buffer, for chaining.\n   */\n  function append(\n    buffer memory buf,\n    bytes memory data,\n    uint256 len\n  ) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, data, len);\n  }\n\n  /**\n   * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, data, data.length);\n  }\n\n  /**\n   * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\n   *      capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write the byte at.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function writeUint8(\n    buffer memory buf,\n    uint256 off,\n    uint8 data\n  ) internal pure returns (buffer memory) {\n    if (off >= buf.capacity) {\n      resize(buf, buf.capacity * 2);\n    }\n\n    assembly {\n      // Memory address of the buffer data\n      let bufptr := mload(buf)\n      // Length of existing buffer data\n      let buflen := mload(bufptr)\n      // Address = buffer address + sizeof(buffer length) + off\n      let dest := add(add(bufptr, off), 32)\n      mstore8(dest, data)\n      // Update buffer length if we extended it\n      if eq(off, buflen) {\n        mstore(bufptr, add(buflen, 1))\n      }\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\n   *      capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function appendUint8(buffer memory buf, uint8 data) internal pure returns (buffer memory) {\n    return writeUint8(buf, buf.buf.length, data);\n  }\n\n  /**\n   * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\n   *      exceed the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write at.\n   * @param data The data to append.\n   * @param len The number of bytes to write (left-aligned).\n   * @return The original buffer, for chaining.\n   */\n  function write(\n    buffer memory buf,\n    uint256 off,\n    bytes32 data,\n    uint256 len\n  ) private pure returns (buffer memory) {\n    if (len + off > buf.capacity) {\n      resize(buf, (len + off) * 2);\n    }\n\n    unchecked {\n      uint256 mask = (256**len) - 1;\n      // Right-align data\n      data = data >> (8 * (32 - len));\n      assembly {\n        // Memory address of the buffer data\n        let bufptr := mload(buf)\n        // Address = buffer address + sizeof(buffer length) + off + len\n        let dest := add(add(bufptr, off), len)\n        mstore(dest, or(and(mload(dest), not(mask)), data))\n        // Update buffer length if we extended it\n        if gt(add(off, len), mload(bufptr)) {\n          mstore(bufptr, add(off, len))\n        }\n      }\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\n   *      capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write at.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function writeBytes20(\n    buffer memory buf,\n    uint256 off,\n    bytes20 data\n  ) internal pure returns (buffer memory) {\n    return write(buf, off, bytes32(data), 20);\n  }\n\n  /**\n   * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chhaining.\n   */\n  function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, bytes32(data), 20);\n  }\n\n  /**\n   * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, data, 32);\n  }\n\n  /**\n   * @dev Writes an integer to the buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write at.\n   * @param data The data to append.\n   * @param len The number of bytes to write (right-aligned).\n   * @return The original buffer, for chaining.\n   */\n  function writeInt(\n    buffer memory buf,\n    uint256 off,\n    uint256 data,\n    uint256 len\n  ) private pure returns (buffer memory) {\n    if (len + off > buf.capacity) {\n      resize(buf, (len + off) * 2);\n    }\n\n    uint256 mask = (256**len) - 1;\n    assembly {\n      // Memory address of the buffer data\n      let bufptr := mload(buf)\n      // Address = buffer address + off + sizeof(buffer length) + len\n      let dest := add(add(bufptr, off), len)\n      mstore(dest, or(and(mload(dest), not(mask)), data))\n      // Update buffer length if we extended it\n      if gt(add(off, len), mload(bufptr)) {\n        mstore(bufptr, add(off, len))\n      }\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n   * exceed the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer.\n   */\n  function appendInt(\n    buffer memory buf,\n    uint256 data,\n    uint256 len\n  ) internal pure returns (buffer memory) {\n    return writeInt(buf, buf.buf.length, data, len);\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vendor/CBORChainlink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.19;\n\nimport {BufferChainlink} from \"./BufferChainlink.sol\";\n\nlibrary CBORChainlink {\n  using BufferChainlink for BufferChainlink.buffer;\n\n  uint8 private constant MAJOR_TYPE_INT = 0;\n  uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\n  uint8 private constant MAJOR_TYPE_BYTES = 2;\n  uint8 private constant MAJOR_TYPE_STRING = 3;\n  uint8 private constant MAJOR_TYPE_ARRAY = 4;\n  uint8 private constant MAJOR_TYPE_MAP = 5;\n  uint8 private constant MAJOR_TYPE_TAG = 6;\n  uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\n\n  uint8 private constant TAG_TYPE_BIGNUM = 2;\n  uint8 private constant TAG_TYPE_NEGATIVE_BIGNUM = 3;\n\n  function encodeFixedNumeric(BufferChainlink.buffer memory buf, uint8 major, uint64 value) private pure {\n    if(value <= 23) {\n      buf.appendUint8(uint8((major << 5) | value));\n    } else if (value <= 0xFF) {\n      buf.appendUint8(uint8((major << 5) | 24));\n      buf.appendInt(value, 1);\n    } else if (value <= 0xFFFF) {\n      buf.appendUint8(uint8((major << 5) | 25));\n      buf.appendInt(value, 2);\n    } else if (value <= 0xFFFFFFFF) {\n      buf.appendUint8(uint8((major << 5) | 26));\n      buf.appendInt(value, 4);\n    } else {\n      buf.appendUint8(uint8((major << 5) | 27));\n      buf.appendInt(value, 8);\n    }\n  }\n\n  function encodeIndefiniteLengthType(BufferChainlink.buffer memory buf, uint8 major) private pure {\n    buf.appendUint8(uint8((major << 5) | 31));\n  }\n\n  function encodeUInt(BufferChainlink.buffer memory buf, uint value) internal pure {\n    if(value > 0xFFFFFFFFFFFFFFFF) {\n      encodeBigNum(buf, value);\n    } else {\n      encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(value));\n    }\n  }\n\n  function encodeInt(BufferChainlink.buffer memory buf, int value) internal pure {\n    if(value < -0x10000000000000000) {\n      encodeSignedBigNum(buf, value);\n    } else if(value > 0xFFFFFFFFFFFFFFFF) {\n      encodeBigNum(buf, uint(value));\n    } else if(value >= 0) {\n      encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(uint256(value)));\n    } else {\n      encodeFixedNumeric(buf, MAJOR_TYPE_NEGATIVE_INT, uint64(uint256(-1 - value)));\n    }\n  }\n\n  function encodeBytes(BufferChainlink.buffer memory buf, bytes memory value) internal pure {\n    encodeFixedNumeric(buf, MAJOR_TYPE_BYTES, uint64(value.length));\n    buf.append(value);\n  }\n\n  function encodeBigNum(BufferChainlink.buffer memory buf, uint value) internal pure {\n    buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_BIGNUM));\n    encodeBytes(buf, abi.encode(value));\n  }\n\n  function encodeSignedBigNum(BufferChainlink.buffer memory buf, int input) internal pure {\n    buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_NEGATIVE_BIGNUM));\n    encodeBytes(buf, abi.encode(uint256(-1 - input)));\n  }\n\n  function encodeString(BufferChainlink.buffer memory buf, string memory value) internal pure {\n    encodeFixedNumeric(buf, MAJOR_TYPE_STRING, uint64(bytes(value).length));\n    buf.append(bytes(value));\n  }\n\n  function startArray(BufferChainlink.buffer memory buf) internal pure {\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\n  }\n\n  function startMap(BufferChainlink.buffer memory buf) internal pure {\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\n  }\n\n  function endSequence(BufferChainlink.buffer memory buf) internal pure {\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/OracleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface OracleInterface {\n  function fulfillOracleRequest(\n    bytes32 requestId,\n    uint256 payment,\n    address callbackAddress,\n    bytes4 callbackFunctionId,\n    uint256 expiration,\n    bytes32 data\n  ) external returns (bool);\n\n  function isAuthorizedSender(address node) external view returns (bool);\n\n  function withdraw(address recipient, uint256 amount) external;\n\n  function withdrawable() external view returns (uint256);\n}\n"
    },
    "contracts/ethStaking/interfaces/IWLOperatorController.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"./IOperatorController.sol\";\n\ninterface IWLOperatorController is IOperatorController {\n    function assignNextValidators(\n        uint[] calldata _operatorIds,\n        uint[] calldata _validatorCounts,\n        uint _totalValidatorCount\n    ) external returns (bytes memory keys, bytes memory signatures);\n\n    function getNextValidators(uint _validatorCount)\n        external\n        view\n        returns (\n            uint[] memory operatorIds,\n            uint[] memory validatorCounts,\n            uint totalValidatorCount,\n            bytes memory keys\n        );\n}\n"
    },
    "contracts/ethStaking/EthStakingStrategy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport \"solidity-bytes-utils/contracts/BytesLib.sol\";\n\nimport \"../core/base/Strategy.sol\";\nimport \"./interfaces/IWrappedETH.sol\";\nimport \"./interfaces/IWLOperatorController.sol\";\nimport \"./interfaces/INWLOperatorController.sol\";\nimport \"./interfaces/IDepositContract.sol\";\nimport \"./interfaces/IRewardsReceiver.sol\";\n\n/**\n * @title ETH Staking Strategy\n * @notice Handles Ethereum staking deposits/withdrawals\n */\ncontract EthStakingStrategy is Strategy {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    uint public constant PUBKEY_LENGTH = 48;\n    uint public constant SIGNATURE_LENGTH = 96;\n\n    uint public constant DEPOSIT_AMOUNT = 32 ether;\n    uint internal constant DEPOSIT_AMOUNT_UNIT = 1 gwei;\n\n    uint internal constant BASIS_POINTS = 10000;\n\n    IDepositContract public depositContract;\n    IWLOperatorController public wlOperatorController;\n    INWLOperatorController public nwlOperatorController;\n    IRewardsReceiver public rewardsReceiver;\n    address public beaconOracle;\n    address public depositController;\n\n    bytes32 public withdrawalCredentials;\n\n    uint public operatorFeeBasisPoints;\n\n    uint public depositedValidators;\n    uint public beaconValidators;\n    uint public beaconBalance;\n    uint public nwlLostOperatorStakes;\n\n    int public depositChange;\n    uint public totalDeposits;\n    uint public bufferedETH;\n\n    uint private maxDeposits;\n    uint private minDeposits;\n\n    event DepositEther(uint nwlValidatorCount, uint wlValidatorCount);\n    event ReportBeaconState(uint beaconValidators, uint beaconBalance, uint nwlLostOperatorStakes);\n    event SetMaxDeposits(uint max);\n    event SetMinDeposits(uint min);\n    event SetDepositController(address controller);\n    event SetRewardsReceiver(address rewardsReceiver);\n    event SetBeaconOracle(address oracle);\n    event SetWLOperatorController(address controller);\n    event SetNWLOperatorController(address controller);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address _wETH,\n        address _stakingPool,\n        uint _maxDeposits,\n        uint _minDeposits,\n        address _depositContract,\n        bytes32 _withdrawalCredentials,\n        uint _operatorFeeBasisPoints\n    ) public initializer {\n        __Strategy_init(_wETH, _stakingPool);\n        depositContract = IDepositContract(_depositContract);\n        withdrawalCredentials = _withdrawalCredentials;\n        operatorFeeBasisPoints = _operatorFeeBasisPoints;\n        maxDeposits = _maxDeposits;\n        minDeposits = _minDeposits;\n    }\n\n    receive() external payable {}\n\n    /**\n     * @notice Updates the number of validators in the beacon validator set and their total balance\n     * @dev periodically called by the Oracle contract\n     * @param _beaconValidators number of validators in the beacon state\n     * @param _beaconBalance summed balance of all validators\n     * @param _nwlLostOperatorStakes sum of all lost non-whitelisted operator stakes (max of 16 ETH per nwl validator -\n     * the first 16 ETH lost for each nwl validator is staked by the operator, not this pool)\n     */\n    function reportBeaconState(\n        uint _beaconValidators,\n        uint _beaconBalance,\n        uint _nwlLostOperatorStakes\n    ) external {\n        require(msg.sender == beaconOracle, \"Sender is not beacon oracle\");\n        require(_beaconValidators <= depositedValidators, \"Reported more validators than deposited\");\n        require(_beaconValidators >= beaconValidators, \"Reported less validators than tracked\");\n\n        uint newValidators = _beaconValidators - beaconValidators;\n        int rewardBase = int(newValidators * DEPOSIT_AMOUNT + beaconBalance + nwlLostOperatorStakes);\n\n        beaconBalance = _beaconBalance;\n        beaconValidators = _beaconValidators;\n        nwlLostOperatorStakes = _nwlLostOperatorStakes;\n\n        int change = int(_beaconBalance) - rewardBase + int(_nwlLostOperatorStakes);\n        if (change > 0) {\n            uint rewards = rewardsReceiver.withdraw();\n            if (rewards > 0) {\n                IWrappedETH(address(token)).wrap{value: rewards}();\n                bufferedETH += rewards;\n                change += int(rewards);\n            }\n        }\n\n        depositChange += change;\n        emit ReportBeaconState(_beaconValidators, _beaconBalance, _nwlLostOperatorStakes);\n    }\n\n    /**\n     * @notice unwraps wETH and deposits ETH into the DepositContract\n     * @dev always deposits for non-whitelisted validators first, followed by whitelisted only if there\n     * are no non-whitelisted remaining in the queue\n     * @param _nwlTotalValidatorCount sum of all validators to assign non-whitelisted operators\n     * @param _wlTotalValidatorCount sum of all validators to assign whitelisted operators\n     * @param _wlOperatorIds ids of whitelisted operators that should be assigned validators\n     * @param _wlValidatorCounts number of validators to assign each whitelisted operator\n     */\n    function depositEther(\n        uint _nwlTotalValidatorCount,\n        uint _wlTotalValidatorCount,\n        uint[] calldata _wlOperatorIds,\n        uint[] calldata _wlValidatorCounts\n    ) external {\n        require(msg.sender == depositController, \"Sender is not deposit controller\");\n\n        uint totalDepositAmount = (DEPOSIT_AMOUNT * _wlTotalValidatorCount + (DEPOSIT_AMOUNT / 2) * _nwlTotalValidatorCount);\n        require(totalDepositAmount > 0, \"Cannot deposit 0\");\n        require(bufferedETH >= totalDepositAmount, \"Insufficient balance for deposit\");\n\n        bytes memory nwlPubkeys;\n        bytes memory nwlSignatures;\n\n        if (_nwlTotalValidatorCount > 0) {\n            (nwlPubkeys, nwlSignatures) = nwlOperatorController.assignNextValidators(_nwlTotalValidatorCount);\n\n            require(\n                nwlPubkeys.length / PUBKEY_LENGTH == _nwlTotalValidatorCount,\n                \"Incorrect non-whitelisted pubkeys length\"\n            );\n            require(\n                nwlSignatures.length / SIGNATURE_LENGTH == _nwlTotalValidatorCount,\n                \"Incorrect non-whitelisted signatures length\"\n            );\n            require(nwlPubkeys.length % PUBKEY_LENGTH == 0, \"Invalid non-whitelisted pubkeys\");\n            require(nwlSignatures.length % SIGNATURE_LENGTH == 0, \"Invalid non-whitelisted signatures\");\n        }\n\n        bytes memory wlPubkeys;\n        bytes memory wlSignatures;\n\n        if (_wlTotalValidatorCount > 0) {\n            require(nwlOperatorController.queueLength() == 0, \"Non-whitelisted queue must be empty to assign whitelisted\");\n\n            (wlPubkeys, wlSignatures) = wlOperatorController.assignNextValidators(\n                _wlOperatorIds,\n                _wlValidatorCounts,\n                _wlTotalValidatorCount\n            );\n\n            require(wlPubkeys.length / PUBKEY_LENGTH == _wlTotalValidatorCount, \"Incorrect whitelisted pubkeys length\");\n            require(\n                wlSignatures.length / SIGNATURE_LENGTH == _wlTotalValidatorCount,\n                \"Incorrect whitelisted signatures length\"\n            );\n            require(wlPubkeys.length % PUBKEY_LENGTH == 0, \"Invalid whitelisted pubkeys\");\n            require(wlSignatures.length % SIGNATURE_LENGTH == 0, \"Invalid whitelisted signatures\");\n        }\n\n        IWrappedETH(address(token)).unwrap(totalDepositAmount);\n\n        for (uint i = 0; i < _nwlTotalValidatorCount; i++) {\n            bytes memory pubkey = BytesLib.slice(nwlPubkeys, i * PUBKEY_LENGTH, PUBKEY_LENGTH);\n            bytes memory signature = BytesLib.slice(nwlSignatures, i * SIGNATURE_LENGTH, SIGNATURE_LENGTH);\n            _deposit(pubkey, signature);\n        }\n\n        for (uint i = 0; i < _wlTotalValidatorCount; i++) {\n            bytes memory pubkey = BytesLib.slice(wlPubkeys, i * PUBKEY_LENGTH, PUBKEY_LENGTH);\n            bytes memory signature = BytesLib.slice(wlSignatures, i * SIGNATURE_LENGTH, SIGNATURE_LENGTH);\n            _deposit(pubkey, signature);\n        }\n\n        bufferedETH -= totalDepositAmount;\n        depositedValidators += _nwlTotalValidatorCount + _wlTotalValidatorCount;\n        emit DepositEther(_nwlTotalValidatorCount, _wlTotalValidatorCount);\n    }\n\n    /**\n     * @notice deposits wETH from StakingPool into this strategy\n     * @param _amount amount of wETH to deposit\n     */\n    function deposit(uint _amount) external onlyStakingPool {\n        require(_amount <= canDeposit(), \"Insufficient deposit room\");\n        token.transferFrom(address(stakingPool), address(this), _amount);\n        totalDeposits += _amount;\n        bufferedETH += _amount;\n    }\n\n    /**\n     * @notice withdraws ETH\n     * @dev not implemented yet\n     * @param _amount amount of ETH to withdraw\n     */\n    function withdraw(uint _amount) external onlyStakingPool {\n        revert(\"Not implemented yet\");\n    }\n\n    /**\n     * @notice withdraws ETH to non-whitelisted operator\n     * @dev not implemented yet\n     * @param _receiver receiver of ETH\n     * @param _amount amount of ETH to withdraw\n     */\n    function nwlWithdraw(address _receiver, uint _amount) external {\n        require(msg.sender == address(nwlOperatorController), \"Sender is not non-whitelisted operator controller\");\n        revert(\"Not implemented yet\");\n    }\n\n    /**\n     * @notice updates deposit accounting and calculates reward distribution\n     */\n    function updateDeposits() external onlyStakingPool returns (address[] memory receivers, uint[] memory amounts) {\n        if (depositChange > 0) {\n            uint rewards = uint(depositChange);\n\n            uint nwlOperatorDeposits = nwlOperatorController.totalActiveStake();\n            uint nwlOperatorRewardsBasisPoints = (BASIS_POINTS * nwlOperatorDeposits) /\n                (totalDeposits + nwlOperatorDeposits);\n\n            uint activeWLValidators = wlOperatorController.totalActiveValidators();\n            uint activeNWLValidators = nwlOperatorController.totalActiveValidators();\n\n            uint operatorFee = (rewards * operatorFeeBasisPoints) / BASIS_POINTS;\n            uint wlOperatorFee = (operatorFee * activeWLValidators) / (activeNWLValidators + activeWLValidators);\n            uint nwlOperatorFee = operatorFee - wlOperatorFee + (rewards * nwlOperatorRewardsBasisPoints) / BASIS_POINTS;\n\n            receivers = new address[](2);\n            amounts = new uint[](2);\n\n            receivers[0] = address(wlOperatorController);\n            receivers[1] = address(nwlOperatorController);\n            amounts[0] = wlOperatorFee;\n            amounts[1] = nwlOperatorFee;\n        }\n        totalDeposits = uint(int(totalDeposits) + depositChange);\n        depositChange = 0;\n    }\n\n    /**\n     * @notice sets the whitelisted operator controller\n     * @param _wlOperatorController controller address\n     */\n    function setWLOperatorController(address _wlOperatorController) external onlyOwner {\n        wlOperatorController = IWLOperatorController(_wlOperatorController);\n        emit SetWLOperatorController(_wlOperatorController);\n    }\n\n    /**\n     * @notice sets the non-whitelisted operator controller\n     * @param _nwlOperatorController controller address\n     */\n    function setNWLOperatorController(address _nwlOperatorController) external onlyOwner {\n        nwlOperatorController = INWLOperatorController(_nwlOperatorController);\n        emit SetNWLOperatorController(_nwlOperatorController);\n    }\n\n    /**\n     * @notice sets the beacon oracle\n     * @param _beaconOracle oracle address\n     */\n    function setBeaconOracle(address _beaconOracle) external onlyOwner {\n        beaconOracle = _beaconOracle;\n        emit SetBeaconOracle(_beaconOracle);\n    }\n\n    /**\n     * @notice returns the total amount of deposits in this strategy\n     * @return total deposits\n     */\n    function getTotalDeposits() public view override returns (uint) {\n        return totalDeposits;\n    }\n\n    /**\n     * @notice returns the maximum that can be deposited into the strategy\n     * @return max deposit\n     */\n    function getMaxDeposits() public view override returns (uint) {\n        return maxDeposits;\n    }\n\n    /**\n     * @notice returns the minimum that must remain the strategy\n     * @return min deposit\n     */\n    function getMinDeposits() public view override returns (uint) {\n        return minDeposits;\n    }\n\n    /**\n     * @notice sets the maximum that can be deposited into the strategy\n     * @param _maxDeposits maximum deposits\n     */\n    function setMaxDeposits(uint256 _maxDeposits) external onlyOwner {\n        maxDeposits = _maxDeposits;\n        emit SetMaxDeposits(_maxDeposits);\n    }\n\n    /**\n     * @notice sets the minimum that can be deposited into the strategy\n     * @param _minDeposits minimum deposits\n     */\n    function setMinDeposits(uint256 _minDeposits) external onlyOwner {\n        minDeposits = _minDeposits;\n        emit SetMinDeposits(_minDeposits);\n    }\n\n    /**\n     * @notice sets the deposit controller\n     * @param _depositController deposit controller address\n     */\n    function setDepositController(address _depositController) external onlyOwner {\n        depositController = _depositController;\n        emit SetDepositController(_depositController);\n    }\n\n    /**\n     * @notice sets the rewards receiver\n     * @param _rewardsReceiver rewards receiver address\n     */\n    function setRewardsReceiver(address _rewardsReceiver) external onlyOwner {\n        rewardsReceiver = IRewardsReceiver(_rewardsReceiver);\n        emit SetRewardsReceiver(_rewardsReceiver);\n    }\n\n    /**\n     * @dev invokes a single deposit call to the DepositContract\n     * @param _pubkey validator to deposit for\n     * @param _signature signature of the deposit call\n     */\n    function _deposit(bytes memory _pubkey, bytes memory _signature) internal {\n        require(withdrawalCredentials != 0, \"Empty withdrawal credentials\");\n\n        uint depositValue = DEPOSIT_AMOUNT;\n        uint depositAmount = depositValue / DEPOSIT_AMOUNT_UNIT;\n\n        bytes32 pubkeyRoot = sha256(abi.encodePacked(_pubkey, bytes16(0)));\n        bytes32 signatureRoot = sha256(\n            abi.encodePacked(\n                sha256(BytesLib.slice(_signature, 0, 64)),\n                sha256(abi.encodePacked(BytesLib.slice(_signature, 64, SIGNATURE_LENGTH - 64), bytes32(0)))\n            )\n        );\n        bytes32 depositDataRoot = sha256(\n            abi.encodePacked(\n                sha256(abi.encodePacked(pubkeyRoot, withdrawalCredentials)),\n                sha256(abi.encodePacked(_toLittleEndian64(uint64(depositAmount)), bytes24(0), signatureRoot))\n            )\n        );\n\n        uint targetBalance = address(this).balance - depositValue;\n\n        depositContract.deposit{value: depositValue}(\n            _pubkey,\n            abi.encodePacked(withdrawalCredentials),\n            _signature,\n            depositDataRoot\n        );\n\n        require(address(this).balance == targetBalance, \"Deposit failed\");\n    }\n\n    /**\n     * @dev converts value to little endian bytes\n     * @param _value number to convert\n     */\n    function _toLittleEndian64(uint64 _value) internal pure returns (bytes memory ret) {\n        ret = new bytes(8);\n        bytes8 bytesValue = bytes8(_value);\n        ret[0] = bytesValue[7];\n        ret[1] = bytesValue[6];\n        ret[2] = bytesValue[5];\n        ret[3] = bytesValue[4];\n        ret[4] = bytesValue[3];\n        ret[5] = bytesValue[2];\n        ret[6] = bytesValue[1];\n        ret[7] = bytesValue[0];\n    }\n}\n"
    },
    "contracts/ethStaking/interfaces/INWLOperatorController.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"./IOperatorController.sol\";\n\ninterface INWLOperatorController is IOperatorController {\n    function assignNextValidators(uint _totalValidatorCount) external returns (bytes memory keys, bytes memory signatures);\n\n    function totalActiveStake() external view returns (uint);\n\n    function getNextValidators(uint _validatorCount) external view returns (bytes memory keys);\n}\n"
    },
    "contracts/ethStaking/interfaces/IDepositContract.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\ninterface IDepositContract {\n    /// @notice Submit a Phase 0 DepositData object.\n    /// @param pubkey A BLS12-381 public key.\n    /// @param withdrawal_credentials Commitment to a public key for withdrawals.\n    /// @param signature A BLS12-381 signature.\n    /// @param deposit_data_root The SHA-256 hash of the SSZ-encoded DepositData object.\n    /// Used as a protection against malformed input.\n    function deposit(\n        bytes calldata pubkey,\n        bytes calldata withdrawal_credentials,\n        bytes calldata signature,\n        bytes32 deposit_data_root\n    ) external payable;\n\n    /// @notice Query the current deposit root hash.\n    /// @return The deposit root hash.\n    function get_deposit_root() external view returns (bytes32);\n}\n"
    },
    "contracts/ethStaking/interfaces/IRewardsReceiver.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\ninterface IRewardsReceiver {\n    function withdraw() external returns (uint);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "contracts/core/test/StrategyMockV2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./StrategyMock.sol\";\n\n/**\n * @title Strategy Mock V2\n * @notice Mocks contract upgrade for testing\n */\ncontract StrategyMockV2 is StrategyMock {\n    function contractVersion() external pure returns (uint) {\n        return 2;\n    }\n}\n"
    },
    "contracts/core/test/StrategyMock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"../base/Strategy.sol\";\nimport \"../RewardsPool.sol\";\n\n/**\n * @title Strategy Mock\n * @notice Mocks contract for testing\n */\ncontract StrategyMock is Strategy {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    uint private maxDeposits;\n    uint private minDeposits;\n\n    uint private totalDeposits;\n    uint public feeBasisPoints;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address _token,\n        address _stakingPool,\n        uint _maxDeposits,\n        uint _minDeposits\n    ) public initializer {\n        __Strategy_init(_token, _stakingPool);\n        feeBasisPoints = 0;\n        maxDeposits = _maxDeposits;\n        minDeposits = _minDeposits;\n    }\n\n    // should return the change in deposits since updateRewards was last called (can be positive or negative)\n    function depositChange() public view returns (int) {\n        return int(token.balanceOf(address(this))) - int(totalDeposits);\n    }\n\n    function deposit(uint256 _amount) external onlyStakingPool {\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n        totalDeposits += _amount;\n        // Deposit into earning protocol/node\n    }\n\n    function withdraw(uint256 _amount) external onlyStakingPool {\n        require(_amount <= canWithdraw(), \"Total deposits must remain >= minimum\");\n        totalDeposits -= _amount;\n        //Withdraw from earning protocol/node\n        token.safeTransfer(msg.sender, _amount);\n    }\n\n    function updateDeposits() external onlyStakingPool returns (address[] memory receivers, uint[] memory amounts) {\n        int256 balanceChange = depositChange();\n        if (balanceChange > 0) {\n            totalDeposits += uint(balanceChange);\n            if (feeBasisPoints > 0) {\n                receivers = new address[](1);\n                amounts = new uint[](1);\n                receivers[0] = owner();\n                amounts[0] = (feeBasisPoints * uint(balanceChange)) / 10000;\n            }\n        } else if (balanceChange < 0) {\n            totalDeposits -= uint(balanceChange * -1);\n        }\n    }\n\n    function setFeeBasisPoints(uint _feeBasisPoints) external {\n        feeBasisPoints = _feeBasisPoints;\n    }\n\n    function simulateSlash(uint _amount) external {\n        token.safeTransfer(msg.sender, _amount);\n    }\n\n    function getTotalDeposits() public view override returns (uint) {\n        return totalDeposits;\n    }\n\n    function getMaxDeposits() public view override returns (uint) {\n        return maxDeposits;\n    }\n\n    function getMinDeposits() public view override returns (uint) {\n        return minDeposits;\n    }\n\n    function setMaxDeposits(uint256 _maxDeposits) external onlyOwner {\n        maxDeposits = _maxDeposits;\n    }\n\n    function setMinDeposits(uint256 _minDeposits) external onlyOwner {\n        minDeposits = _minDeposits;\n    }\n\n    function createRewardsPool(address _token) public {\n        RewardsPool rewardsPool = new RewardsPool(address(stakingPool), _token);\n        IRewardsPoolController rewardsPoolController = IRewardsPoolController(address(stakingPool));\n        rewardsPoolController.addToken(_token, address(rewardsPool));\n    }\n}\n"
    },
    "contracts/core/RewardsPool.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./interfaces/IRewardsPoolController.sol\";\n\n/**\n * @title RewardsPool\n * @notice Handles reward distribution for a single asset\n * @dev rewards can only be positive (user balances can only increase)\n */\ncontract RewardsPool {\n    using SafeERC20 for IERC677;\n\n    IERC677 public immutable token;\n    IRewardsPoolController public immutable controller;\n\n    uint public rewardPerToken;\n    uint public totalRewards;\n    mapping(address => uint) public userRewardPerTokenPaid;\n    mapping(address => uint) public userRewards;\n\n    event Withdraw(address indexed account, uint amount);\n    event DistributeRewards(address indexed sender, uint256 amountStaked, uint256 amount);\n\n    constructor(address _controller, address _token) {\n        controller = IRewardsPoolController(_controller);\n        token = IERC677(_token);\n    }\n\n    /**\n     * @notice returns an account's total withdrawable rewards (principal balance + newly earned rewards)\n     * @param _account account to return rewards for\n     * @return account's total unclaimed rewards\n     **/\n    function withdrawableRewards(address _account) public view virtual returns (uint) {\n        return\n            (controller.staked(_account) * (rewardPerToken - userRewardPerTokenPaid[_account])) /\n            1e18 +\n            userRewards[_account];\n    }\n\n    /**\n     * @notice withdraws an account's earned rewards\n     **/\n    function withdraw() external {\n        _withdraw(msg.sender);\n    }\n\n    /**\n     * @notice withdraws an account's earned rewards\n     * @dev used by PoolOwners\n     * @param _account account to withdraw for\n     **/\n    function withdraw(address _account) external {\n        require(msg.sender == address(controller), \"Controller only\");\n        _withdraw(_account);\n    }\n\n    /**\n     * @notice ERC677 implementation that proxies reward distribution\n     **/\n    function onTokenTransfer(\n        address,\n        uint256,\n        bytes calldata\n    ) external {\n        require(msg.sender == address(token), \"Only callable by token\");\n        distributeRewards();\n    }\n\n    /**\n     * @notice distributes new rewards that have been deposited\n     **/\n    function distributeRewards() public virtual {\n        require(controller.totalStaked() > 0, \"Cannot distribute when nothing is staked\");\n        uint256 toDistribute = token.balanceOf(address(this)) - totalRewards;\n        totalRewards += toDistribute;\n        _updateRewardPerToken(toDistribute);\n        emit DistributeRewards(msg.sender, controller.totalStaked(), toDistribute);\n    }\n\n    /**\n     * @notice updates an account's principal reward balance\n     * @param _account account to update for\n     **/\n    function updateReward(address _account) public virtual {\n        uint newRewards = withdrawableRewards(_account) - userRewards[_account];\n        if (newRewards > 0) {\n            userRewards[_account] += newRewards;\n        }\n        userRewardPerTokenPaid[_account] = rewardPerToken;\n    }\n\n    /**\n     * @notice withdraws rewards for an account\n     * @param _account account to withdraw for\n     **/\n    function _withdraw(address _account) internal virtual {\n        uint256 toWithdraw = withdrawableRewards(_account);\n        if (toWithdraw > 0) {\n            updateReward(_account);\n            userRewards[_account] -= toWithdraw;\n            totalRewards -= toWithdraw;\n            token.safeTransfer(_account, toWithdraw);\n            emit Withdraw(_account, toWithdraw);\n        }\n    }\n\n    /**\n     * @notice updates rewardPerToken\n     * @param _reward deposited reward amount\n     **/\n    function _updateRewardPerToken(uint _reward) internal {\n        uint totalStaked = controller.totalStaked();\n        require(totalStaked > 0, \"Staked amount must be > 0\");\n        rewardPerToken += ((_reward * 1e18) / totalStaked);\n    }\n}\n"
    },
    "contracts/core/interfaces/IRewardsPoolController.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"./IERC677.sol\";\n\ninterface IRewardsPoolController {\n    /**\n     * @notice returns an account's stake balance for use by reward pools\n     * controlled by this contract\n     * @return account's balance\n     */\n    function staked(address _account) external view returns (uint);\n\n    /**\n     * @notice returns the total staked amount for use by reward pools\n     * controlled by this contract\n     * @return total staked amount\n     */\n    function totalStaked() external view returns (uint);\n\n    /**\n     * @notice adds a new token\n     * @param _token token to add\n     * @param _rewardsPool token rewards pool to add\n     **/\n    function addToken(address _token, address _rewardsPool) external;\n}\n"
    },
    "contracts/core/base/RewardsPoolController.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../interfaces/IRewardsPoolController.sol\";\nimport \"../interfaces/IRewardsPool.sol\";\nimport \"../RewardsPool.sol\";\nimport \"../tokens/base/ERC677.sol\";\n\n/**\n * @title Rewards Pool Controller\n * @notice Acts as a proxy for any number of rewards pools\n */\nabstract contract RewardsPoolController is Ownable, IRewardsPoolController, ERC677 {\n    using SafeERC20 for IERC20;\n\n    mapping(address => IRewardsPool) public tokenPools;\n    address[] private tokens;\n\n    mapping(address => address) public rewardRedirects;\n    mapping(address => uint) public redirectedStakes;\n    mapping(address => address) public redirectApprovals;\n\n    event WithdrawRewards(address indexed account);\n    event AddToken(address indexed token, address rewardsPool);\n    event RemoveToken(address indexed token, address rewardsPool);\n\n    event RedirectApproval(address indexed approver, address indexed to);\n    event RedirectApprovalRevoked(address indexed approver, address indexed from);\n    event RewardsRedirected(address indexed from, address indexed to, address indexed by);\n\n    modifier updateRewards(address _account) {\n        _updateRewards(_account);\n        _;\n    }\n\n    constructor(string memory _derivativeTokenName, string memory _derivativeTokenSymbol)\n        ERC677(_derivativeTokenName, _derivativeTokenSymbol, 0)\n    {}\n\n    /**\n     * @notice returns a list of configs for all supported tokens\n     * @return list of token configs\n     **/\n    function supportedTokens() external view returns (address[] memory) {\n        return tokens;\n    }\n\n    /**\n     * @notice returns true/false to whether a given token is supported\n     * @param _token token address\n     * @return is token supported\n     **/\n    function isTokenSupported(address _token) public view returns (bool) {\n        return address(tokenPools[_token]) != address(0) ? true : false;\n    }\n\n    /**\n     * @notice get all token balances of supported tokens within the controller\n     * @return list of tokens with a list of token balances\n     **/\n    function tokenBalances() external view returns (address[] memory, uint[] memory) {\n        uint[] memory balances = new uint[](tokens.length);\n\n        for (uint i = 0; i < tokens.length; i++) {\n            balances[i] = IERC20(tokens[i]).balanceOf(address(this));\n        }\n\n        return (tokens, balances);\n    }\n\n    function onTokenTransfer(\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual {\n        if (isTokenSupported(msg.sender)) {\n            distributeToken(msg.sender);\n        }\n    }\n\n    /**\n     * @notice returns an account's staked amount for use by reward pools\n     * controlled by this contract. If rewards are redirected, it returns the sum of the amount\n     * staked by all of the accounts that have redirected rewards.\n     * @dev required by RewardsPoolController\n     * @return account's staked amount\n     */\n    function staked(address _account) external view virtual returns (uint) {\n        return (rewardRedirects[_account] == address(0) ? balanceOf(_account) : 0) + redirectedStakes[_account];\n    }\n\n    /**\n     * @notice returns the total staked amount for use by reward pools\n     * controlled by this contract\n     * @dev required by RewardsPoolController\n     * @return total staked amount\n     */\n    function totalStaked() external view virtual returns (uint) {\n        return totalSupply();\n    }\n\n    /**\n     * @notice returns the address that receives rewards for an account\n     * @param _account address to query\n     */\n    function rewardsAddress(address _account) external view returns (address) {\n        return rewardRedirects[_account] != address(0) ? rewardRedirects[_account] : _account;\n    }\n\n    /**\n     * @dev updates the rewards of the sender and previousRedirect, also updates redirected staked amounts\n     * if rewards are redirected\n     * @param _from account sending from\n     * @param _to account sending to\n     * @param _amount amount being sent\n     */\n    function _transfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal virtual override updateRewards(_from) updateRewards(_to) {\n        address rewardRedirectFrom = rewardRedirects[_from];\n        address rewardRedirectTo = rewardRedirects[_to];\n\n        if (rewardRedirectFrom != address(0)) {\n            _updateRewards(rewardRedirectFrom);\n            redirectedStakes[rewardRedirectFrom] -= _amount;\n        }\n        if (rewardRedirectTo != address(0)) {\n            _updateRewards(rewardRedirectTo);\n            redirectedStakes[rewardRedirectTo] += _amount;\n        }\n\n        super._transfer(_from, _to, _amount);\n    }\n\n    /**\n     * @notice redirect rewards to a specific address. Supports multiple addresses redirecting to the same previousRedirect.\n     * To stop redirecting rewards, set _to as the current wallet.\n     * @param _to account to redirect rewards to\n     */\n    function redirectRewards(address _to) external {\n        _redirectRewards(msg.sender, _to);\n    }\n\n    /**\n     * @notice redirect rewards for an account with approval\n     * @param _from account to redirect rewards for\n     * @param _to account to redirect rewards to\n     */\n    function redirectRewardsFrom(address _from, address _to) external {\n        require(redirectApprovals[_from] == msg.sender, \"Approval required to redirect rewards\");\n        delete (redirectApprovals[_from]);\n        _redirectRewards(_from, _to);\n    }\n\n    /**\n     * @notice approve a reward redirect\n     * @param _to account to approve\n     */\n    function approveRedirect(address _to) external {\n        redirectApprovals[msg.sender] = _to;\n        emit RedirectApproval(msg.sender, _to);\n    }\n\n    /**\n     * @notice revoke a redirect approval\n     */\n    function revokeRedirectApproval() external {\n        address revokedFrom = redirectApprovals[msg.sender];\n        delete (redirectApprovals[msg.sender]);\n        emit RedirectApprovalRevoked(msg.sender, revokedFrom);\n    }\n\n    /**\n     * @notice distributes token balances to their equivalent reward pools\n     * @param _tokens list of token addresses\n     */\n    function distributeTokens(address[] memory _tokens) public {\n        for (uint i = 0; i < _tokens.length; i++) {\n            distributeToken(_tokens[i]);\n        }\n    }\n\n    /**\n     * @notice distributes a token balance to its equivalent reward pool\n     * @param _token token address\n     */\n    function distributeToken(address _token) public {\n        require(isTokenSupported(_token), \"Token not supported\");\n\n        IERC20 token = IERC20(_token);\n        uint balance = token.balanceOf(address(this));\n        require(balance > 0, \"Cannot distribute zero balance\");\n\n        token.safeTransfer(address(tokenPools[_token]), balance);\n        tokenPools[_token].distributeRewards();\n    }\n\n    /**\n     * @notice returns a list of withdrawable rewards for an account\n     * @param _account account to return reward amounts for\n     * @return list of withdrawable reward amounts\n     **/\n    function withdrawableRewards(address _account) external view returns (uint[] memory) {\n        uint[] memory withdrawable = new uint[](tokens.length);\n\n        for (uint i = 0; i < tokens.length; i++) {\n            withdrawable[i] = tokenPools[tokens[i]].withdrawableRewards(_account);\n        }\n\n        return withdrawable;\n    }\n\n    /**\n     * @notice withdraws an account's earned rewards for a list of tokens\n     * @param _tokens list of token addresses to withdraw rewards from\n     **/\n    function withdrawRewards(address[] memory _tokens) public {\n        for (uint i = 0; i < _tokens.length; i++) {\n            tokenPools[_tokens[i]].withdraw(msg.sender);\n        }\n        emit WithdrawRewards(msg.sender);\n    }\n\n    /**\n     * @notice adds a new token\n     * @param _token token to add\n     * @param _rewardsPool token rewards pool to add\n     **/\n    function addToken(address _token, address _rewardsPool) public onlyOwner {\n        require(!isTokenSupported(_token), \"Token is already supported\");\n\n        tokenPools[_token] = IRewardsPool(_rewardsPool);\n        tokens.push(_token);\n\n        if (IERC20(_token).balanceOf(address(this)) > 0) {\n            distributeToken(_token);\n        }\n\n        emit AddToken(_token, _rewardsPool);\n    }\n\n    /**\n     * @notice removes a supported token\n     * @param _token address of token\n     **/\n    function removeToken(address _token) external onlyOwner {\n        require(isTokenSupported(_token), \"Token is not supported\");\n\n        IRewardsPool rewardsPool = tokenPools[_token];\n        delete (tokenPools[_token]);\n        for (uint i = 0; i < tokens.length; i++) {\n            if (tokens[i] == _token) {\n                tokens[i] = tokens[tokens.length - 1];\n                tokens.pop();\n                break;\n            }\n        }\n\n        emit RemoveToken(_token, address(rewardsPool));\n    }\n\n    /**\n     * @notice redirect rewards to a specific account from an account\n     * @param _from account that's redirecting rewards\n     * @param _to account to redirect rewards to\n     */\n    function _redirectRewards(address _from, address _to) internal updateRewards(_from) updateRewards(_to) {\n        require(_to != address(0), \"Cannot burn rewards\");\n        require(rewardRedirects[_from] != _to, \"Cannot redirect rewards to the same address\");\n        require(rewardRedirects[_from] == address(0) ? (_from != _to) : true, \"Cannot redirect to self\");\n\n        uint balanceFrom = balanceOf(_from);\n        require(balanceFrom > 0, \"A balance is required to redirect rewards\");\n\n        address previousRedirect = rewardRedirects[_from];\n        if (previousRedirect != address(0)) {\n            _updateRewards(previousRedirect);\n            redirectedStakes[previousRedirect] -= balanceFrom;\n        }\n\n        if (_to == _from) {\n            delete (rewardRedirects[_from]);\n        } else {\n            rewardRedirects[_from] = _to;\n            redirectedStakes[_to] += balanceFrom;\n        }\n\n        emit RewardsRedirected(_from, _to, msg.sender);\n    }\n\n    /**\n     * @dev triggers a reward update for a given account\n     * @param _account account to update rewards for\n     */\n    function _updateRewards(address _account) internal {\n        for (uint i = 0; i < tokens.length; i++) {\n            tokenPools[tokens[i]].updateReward(_account);\n        }\n    }\n}\n"
    },
    "contracts/core/tokens/base/ERC677.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"../../interfaces/IERC677Receiver.sol\";\nimport \"../../interfaces/IERC677.sol\";\n\ncontract ERC677 is IERC677, ERC20 {\n    constructor(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        uint _totalSupply\n    ) ERC20(_tokenName, _tokenSymbol) {\n        _mint(msg.sender, _totalSupply * (10**uint256(decimals())));\n    }\n\n    function transferAndCall(\n        address _to,\n        uint256 _value,\n        bytes calldata _data\n    ) public override returns (bool) {\n        super.transfer(_to, _value);\n        if (isContract(_to)) {\n            contractFallback(msg.sender, _to, _value, _data);\n        }\n        return true;\n    }\n\n    function contractFallback(\n        address _sender,\n        address _to,\n        uint256 _value,\n        bytes calldata _data\n    ) internal {\n        IERC677Receiver receiver = IERC677Receiver(_to);\n        receiver.onTokenTransfer(_sender, _value, _data);\n    }\n\n    function isContract(address _addr) internal view returns (bool hasCode) {\n        uint256 length;\n        assembly {\n            length := extcodesize(_addr)\n        }\n        return length > 0;\n    }\n}\n"
    },
    "contracts/core/interfaces/IERC677Receiver.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\ninterface IERC677Receiver {\n    function onTokenTransfer(\n        address _sender,\n        uint256 _value,\n        bytes calldata _data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/core/test/RewardsPoolControllerMock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../base/RewardsPoolController.sol\";\n\n/**\n * @title Rewards Pool Controler Mock\n * @notice Mocks contract for testing\n */\ncontract RewardsPoolControllerMock is RewardsPoolController {\n    using SafeERC20 for IERC20;\n\n    IERC20 public token;\n\n    uint public stakedTotal;\n    mapping(address => uint) public stakeBalances;\n\n    constructor(\n        address _token,\n        string memory _derivativeTokenName,\n        string memory _derivativeTokenSymbol\n    ) RewardsPoolController(_derivativeTokenName, _derivativeTokenSymbol) {\n        token = IERC20(_token);\n    }\n\n    function staked(address _account) external view override returns (uint) {\n        return stakeBalances[_account];\n    }\n\n    function totalStaked() external view override returns (uint) {\n        return stakedTotal;\n    }\n\n    function stake(uint _amount) external updateRewards(msg.sender) {\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n        stakeBalances[msg.sender] += _amount;\n        stakedTotal += _amount;\n    }\n\n    function withdraw(uint _amount) external updateRewards(msg.sender) {\n        stakeBalances[msg.sender] -= _amount;\n        stakedTotal -= _amount;\n        token.safeTransfer(msg.sender, _amount);\n    }\n}\n"
    },
    "contracts/ethStaking/WrappedETH.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title WrappedETH\n * @dev Handles wrapping and unwrapping of ETH\n */\ncontract WrappedETH is ERC20 {\n    event Wrap(address account, uint256 amount);\n    event Unwrap(address account, uint256 amount);\n\n    constructor() ERC20(\"Wrapped ETH\", \"WETH\") {}\n\n    function wrap() external payable {\n        _mint(msg.sender, msg.value);\n        emit Wrap(msg.sender, msg.value);\n    }\n\n    function unwrap(uint256 _amount) external {\n        _burn(msg.sender, _amount);\n        Address.sendValue(payable(msg.sender), _amount);\n        emit Unwrap(msg.sender, _amount);\n    }\n}\n"
    },
    "contracts/linkStaking/test/StakingMock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../interfaces/IStaking.sol\";\nimport \"../../core/interfaces/IERC677.sol\";\nimport \"../../core/interfaces/IERC677Receiver.sol\";\n\n/**\n * @title Staking Mock\n * @dev Mocks contract for testing\n */\ncontract StakingMock is IStaking, IERC677Receiver {\n    IERC677 public token;\n\n    mapping(address => uint) public stakedBalances;\n    address public migration;\n\n    uint public baseReward;\n    uint public delegationReward;\n\n    bool public active;\n    bool public paused;\n\n    constructor(address _token) {\n        token = IERC677(_token);\n        active = true;\n    }\n\n    function onTokenTransfer(\n        address _sender,\n        uint256 _value,\n        bytes calldata\n    ) external {\n        require(msg.sender == address(token), \"has to be token\");\n        stakedBalances[_sender] += _value;\n    }\n\n    function getCommunityStakerLimits() external pure returns (uint256, uint256) {\n        return (10 ether, 7000 ether);\n    }\n\n    function getOperatorLimits() external pure returns (uint256, uint256) {\n        return (10 ether, 50000 ether);\n    }\n\n    function getMaxPoolSize() external pure returns (uint256) {\n        return 25000000 ether;\n    }\n\n    function getTotalStakedAmount() external view returns (uint256) {\n        return token.balanceOf(address(this));\n    }\n\n    function setActive(bool _active) external {\n        active = _active;\n    }\n\n    function isActive() external view returns (bool) {\n        return active;\n    }\n\n    function isOperator(address) external pure returns (bool) {\n        return true;\n    }\n\n    function getStake(address staker) external view returns (uint256) {\n        return stakedBalances[staker];\n    }\n\n    function setMigration(address _migration) external {\n        migration = _migration;\n    }\n\n    function migrate(bytes calldata) external {\n        token.transferAndCall(migration, stakedBalances[msg.sender], \"0x0\");\n    }\n\n    function setBaseReward(uint _amount) external {\n        baseReward = _amount;\n    }\n\n    function getBaseReward(address) external view returns (uint256) {\n        return baseReward;\n    }\n\n    function setDelegationReward(uint _amount) external {\n        delegationReward = _amount;\n    }\n\n    function getDelegationReward(address) external view returns (uint256) {\n        return delegationReward;\n    }\n\n    function getMigrationTarget() external view returns (address) {\n        return migration;\n    }\n\n    function setPaused(bool _paused) external {\n        paused = _paused;\n    }\n\n    function isPaused() external view returns (bool) {\n        return paused;\n    }\n\n    function raiseAlert() external {\n        token.transfer(msg.sender, 100 ether);\n    }\n}\n"
    },
    "contracts/core/tokens/base/VirtualERC677.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"./VirtualERC20.sol\";\nimport \"../../interfaces/IERC677.sol\";\nimport \"../../interfaces/IERC677Receiver.sol\";\n\ncontract VirtualERC677 is IERC677, VirtualERC20 {\n    constructor(string memory tokenName, string memory tokenSymbol) VirtualERC20(tokenName, tokenSymbol) {}\n\n    function transferAndCall(\n        address _to,\n        uint256 _value,\n        bytes calldata _data\n    ) public override returns (bool success) {\n        super.transfer(_to, _value);\n        if (isContract(_to)) {\n            contractFallback(msg.sender, _to, _value, _data);\n        }\n        return true;\n    }\n\n    function transferAndCallFrom(\n        address _sender,\n        address _to,\n        uint256 _value,\n        bytes memory _data\n    ) internal returns (bool) {\n        _transfer(_sender, _to, _value);\n        if (isContract(_to)) {\n            contractFallback(_sender, _to, _value, _data);\n        }\n        return true;\n    }\n\n    function contractFallback(\n        address _sender,\n        address _to,\n        uint256 _value,\n        bytes memory _data\n    ) private {\n        IERC677Receiver receiver = IERC677Receiver(_to);\n        receiver.onTokenTransfer(_sender, _value, _data);\n    }\n\n    function isContract(address _addr) private view returns (bool hasCode) {\n        uint256 length;\n        assembly {\n            length := extcodesize(_addr)\n        }\n        return length > 0;\n    }\n}\n"
    },
    "contracts/core/tokens/base/VirtualERC20.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract VirtualERC20 is IERC20, Context {\n    using Address for address;\n\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    constructor(string memory tokenName, string memory tokenSymbol) {\n        _name = tokenName;\n        _symbol = tokenSymbol;\n        _decimals = 18;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint256) {\n        return _decimals;\n    }\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        require(_allowances[sender][_msgSender()] >= amount, \"ERC20: transfer amount exceeds allowance\");\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()] - amount);\n        return true;\n    }\n\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply + amount;\n        _balances[account] = _balances[account] + amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n        require(_balances[account] >= amount, \"ERC20: burn amount exceeds balance\");\n\n        _balances[account] = _balances[account] - amount;\n        _totalSupply = _totalSupply - amount;\n        emit Transfer(account, address(0), amount);\n    }\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(_balances[sender] >= amount, \"ERC20: transfer amount exceeds balance\");\n\n        _balances[sender] = _balances[sender] - amount;\n        _balances[recipient] = _balances[recipient] + amount;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n}\n"
    },
    "contracts/core/test/v1/RewardsPoolV1.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"../../tokens/base/VirtualERC677.sol\";\n\n/**\n * @title RewardsPool\n * @dev Handles rewards distribution of an asset based on a staking derivative token\n * that represents a user's staked balance\n */\ncontract RewardsPoolV1 is VirtualERC677, ReentrancyGuard {\n    using SafeERC20 for IERC677;\n\n    IERC677 public stakingDerivative;\n    IERC677 public rewardsToken;\n    uint256 public rewardPerToken;\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n\n    event Withdrawn(address indexed user, uint256 amount);\n\n    constructor(\n        address _stakingDerivative,\n        address _rewardsToken,\n        string memory _tokenName,\n        string memory _tokenSymbol\n    ) VirtualERC677(_tokenName, _tokenSymbol) {\n        rewardsToken = IERC677(_rewardsToken);\n        stakingDerivative = IERC677(_stakingDerivative);\n    }\n\n    /**\n     * @dev calculates a user's total unclaimed rewards (principal balance + newly earned rewards)\n     * @param _account user to calculate rewards for\n     * @return user's total unclaimed rewards\n     **/\n    function balanceOf(address _account) public view virtual override(IERC20, VirtualERC20) returns (uint256) {\n        return\n            (stakingDerivative.balanceOf(_account) * (rewardPerToken - userRewardPerTokenPaid[_account])) /\n            1e18 +\n            super.balanceOf(_account);\n    }\n\n    /**\n     * @dev updates a user's principal reward balance\n     * @param _account user to update for\n     **/\n    function updateReward(address _account) external nonReentrant {\n        _updateReward(_account);\n    }\n\n    /**\n     * @dev withdraws a user's earned rewards\n     * @param _amount amount to withdraw\n     **/\n    function withdraw(uint256 _amount) public virtual nonReentrant {\n        _withdraw(msg.sender, _amount);\n        rewardsToken.safeTransfer(msg.sender, _amount);\n    }\n\n    /**\n     * @dev updates rewardPerToken\n     * @param _reward deposited reward amount\n     **/\n    function _updateRewardPerToken(uint256 _reward) internal {\n        require(stakingDerivative.totalSupply() > 0, \"Staked amount must be > 0\");\n        rewardPerToken = rewardPerToken + ((_reward * 1e18) / stakingDerivative.totalSupply());\n    }\n\n    /**\n     * @dev updates a user's principal reward balance\n     * @param _account user to update for\n     **/\n    function _updateReward(address _account) internal virtual {\n        uint256 toMint = balanceOf(_account) - super.balanceOf(_account);\n        if (toMint > 0) {\n            _mint(_account, toMint);\n        }\n        userRewardPerTokenPaid[_account] = rewardPerToken;\n    }\n\n    /**\n     * @dev performs accounting updates for a user withdrawal\n     * @param _sender user to withdraw for\n     * @param _amount amount to withdraw\n     **/\n    function _withdraw(address _sender, uint256 _amount) internal {\n        _updateReward(_sender);\n        _burn(_sender, _amount);\n        emit Withdrawn(_sender, _amount);\n    }\n\n    /**\n     * @dev transfers unclaimed rewards from one user to another\n     * @param _from user to transfer from\n     * @param _to user to transfer to\n     * @param _amount amount to transfer\n     **/\n    function _transfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal virtual override {\n        _updateReward(_from);\n        super._transfer(_from, _to, _amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/core/test/v1/PoolOwnersV1.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../../interfaces/IERC677.sol\";\n\ninterface IOwnersRewardsPool is IERC20 {\n    function updateReward(address _account) external;\n\n    function depositReward(uint256 _reward) external;\n\n    function withdraw(address _account) external;\n\n    function withdraw() external;\n}\n\ninterface IPoolAllowance is IERC20 {\n    function mintAllowance(address _account, uint256 _amount) external;\n\n    function burnAllowance(address _account, uint256 _amount) external;\n}\n\n/**\n * @title Pool Owners\n * @dev Handles owners token staking, allowance token distribution, & owners rewards assets\n */\ncontract PoolOwnersV1 is ReentrancyGuard, Ownable {\n    using SafeERC20 for IERC677;\n\n    IERC677 public stakingToken;\n    uint256 public totalStaked;\n    mapping(address => uint256) private stakedBalances;\n\n    uint16 public totalRewardTokens;\n    mapping(uint16 => address) public rewardTokens;\n    mapping(address => address) public rewardPools;\n    mapping(address => address) public allowanceTokens;\n    mapping(address => mapping(address => uint256)) private mintedAllowanceTokens;\n\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardsWithdrawn(address indexed user);\n    event AllowanceMinted(address indexed user);\n    event RewardTokenAdded(address indexed token, address allowanceToken, address rewardsPool);\n    event RewardTokenRemoved(address indexed token);\n\n    constructor(address _stakingToken) {\n        stakingToken = IERC677(_stakingToken);\n    }\n\n    modifier updateRewards(address _account) {\n        for (uint16 i = 0; i < totalRewardTokens; i++) {\n            IOwnersRewardsPool(rewardPools[rewardTokens[i]]).updateReward(_account);\n        }\n        _;\n    }\n\n    /**\n     * @dev returns a user's staked balance\n     * @param _account user to return balance for\n     * @return user's staked balance\n     **/\n    function balanceOf(address _account) public view returns (uint256) {\n        return stakedBalances[_account];\n    }\n\n    /**\n     * @dev returns how many allowance tokens have been minted for a user\n     * @param _allowanceToken allowance token to return minted amount for\n     * @param _account user to return minted amount for\n     * @return total allowance tokens a user has minted\n     **/\n    function mintedAllowance(address _allowanceToken, address _account) public view returns (uint256) {\n        return mintedAllowanceTokens[_allowanceToken][_account];\n    }\n\n    /**\n     * @dev returns total amount staked\n     * @return total amount staked\n     **/\n    function totalSupply() public view returns (uint256) {\n        return totalStaked;\n    }\n\n    /**\n     * @dev ERC677 implementation that proxies staking\n     * @param _sender of the token transfer\n     * @param _value of the token transfer\n     **/\n    function onTokenTransfer(\n        address _sender,\n        uint256 _value,\n        bytes calldata\n    ) external nonReentrant {\n        require(msg.sender == address(stakingToken), \"Sender must be staking token\");\n        _stake(_sender, _value);\n    }\n\n    /**\n     * @dev stakes owners tokens & mints staking allowance tokens in return\n     * @param _amount amount to stake\n     **/\n    function stake(uint256 _amount) external nonReentrant {\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n        _stake(msg.sender, _amount);\n    }\n\n    /**\n     * @dev burns staking allowance tokens and withdraws staked owners tokens\n     * @param _amount amount to withdraw\n     **/\n    function withdraw(uint256 _amount) public nonReentrant updateRewards(msg.sender) {\n        stakedBalances[msg.sender] = stakedBalances[msg.sender] - _amount;\n        totalStaked -= _amount;\n        _burnAllowance(msg.sender);\n        stakingToken.safeTransfer(msg.sender, _amount);\n        emit Withdrawn(msg.sender, _amount);\n    }\n\n    /**\n     * @dev withdraws user's earned rewards for a all assets\n     **/\n    function withdrawAllRewards() public nonReentrant {\n        for (uint16 i = 0; i < totalRewardTokens; i++) {\n            _withdrawReward(rewardTokens[i], msg.sender);\n        }\n        emit RewardsWithdrawn(msg.sender);\n    }\n\n    /**\n     * @dev withdraws users earned rewards for all assets and withdraws their owners tokens\n     **/\n    function exit() external {\n        withdraw(balanceOf(msg.sender));\n        withdrawAllRewards();\n    }\n\n    /**\n     * @dev mints a user's unclaimed allowance tokens (used if a new asset is added\n     * after a user has already staked)\n     **/\n    function mintAllowance() external nonReentrant {\n        _mintAllowance(msg.sender);\n        emit AllowanceMinted(msg.sender);\n    }\n\n    /**\n     * @dev adds a new asset\n     * @param _token asset to add\n     * @param _allowanceToken asset pool allowance token to add\n     * @param _rewardPool asset reward pool to add\n     **/\n    function addRewardToken(\n        address _token,\n        address _allowanceToken,\n        address _rewardPool\n    ) external onlyOwner {\n        require(rewardPools[_token] == address(0), \"Reward token already exists\");\n        rewardTokens[totalRewardTokens] = _token;\n        allowanceTokens[_token] = _allowanceToken;\n        rewardPools[_token] = _rewardPool;\n        totalRewardTokens++;\n        emit RewardTokenAdded(_token, _allowanceToken, _rewardPool);\n    }\n\n    /**\n     * @dev removes an existing asset\n     * @param _index index of asset to remove\n     **/\n    function removeRewardToken(uint16 _index) external onlyOwner {\n        require(_index < totalRewardTokens, \"Reward token does not exist\");\n        address token = rewardTokens[_index];\n        if (totalRewardTokens > 1) {\n            rewardTokens[_index] = rewardTokens[totalRewardTokens - 1];\n        }\n        delete rewardTokens[totalRewardTokens - 1];\n        delete allowanceTokens[token];\n        delete rewardPools[token];\n        totalRewardTokens--;\n        emit RewardTokenRemoved(token);\n    }\n\n    /**\n     * @dev stakes owners tokens & mints staking allowance tokens in return\n     * @param _amount amount to stake\n     **/\n    function _stake(address _sender, uint256 _amount) private updateRewards(_sender) {\n        stakedBalances[_sender] = stakedBalances[_sender] + _amount;\n        totalStaked += _amount;\n        _mintAllowance(_sender);\n        emit Staked(_sender, _amount);\n    }\n\n    /**\n     * @dev withdraws rewards for a specific asset & account\n     * @param _token asset to withdraw\n     * @param _account user to withdraw for\n     **/\n    function _withdrawReward(address _token, address _account) private {\n        require(rewardPools[_token] != address(0), \"Reward token does not exist\");\n        IOwnersRewardsPool(rewardPools[_token]).withdraw(_account);\n    }\n\n    /**\n     * @dev mints allowance tokens based on a user's staked balance\n     * @param _account user to mint tokens for\n     **/\n    function _mintAllowance(address _account) private {\n        uint256 stakedAmount = balanceOf(_account);\n        for (uint16 i = 0; i < totalRewardTokens; i++) {\n            address token = allowanceTokens[rewardTokens[i]];\n            uint256 minted = mintedAllowance(token, _account);\n            if (minted < stakedAmount) {\n                IPoolAllowance(token).mintAllowance(_account, stakedAmount - minted);\n                mintedAllowanceTokens[token][_account] = stakedAmount;\n            }\n        }\n    }\n\n    /**\n     * @dev burns allowance tokens based on a user's staked balance\n     * @param _account user to burn tokens for\n     **/\n    function _burnAllowance(address _account) private {\n        uint256 stakedAmount = balanceOf(_account);\n        for (uint16 i = 0; i < totalRewardTokens; i++) {\n            address token = allowanceTokens[rewardTokens[i]];\n            uint256 minted = mintedAllowance(token, _account);\n            if (minted > stakedAmount) {\n                IPoolAllowance(token).burnAllowance(_account, minted - stakedAmount);\n                mintedAllowanceTokens[token][_account] = stakedAmount;\n            }\n        }\n    }\n}\n"
    },
    "contracts/core/test/v1/OwnersRewardsPoolV1.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./RewardsPoolV1.sol\";\n\n/**\n * @title OwnersRewardsPool\n * @dev Handles distribution of pool owners rewards\n */\ncontract OwnersRewardsPoolV1 is RewardsPoolV1 {\n    using SafeERC20 for IERC677;\n\n    address public poolOwners;\n    uint256 public distributedRewards;\n\n    event RewardDistributed(address indexed sender, uint256 amountStaked, uint256 amount);\n\n    constructor(\n        address _poolOwners,\n        address _rewardsToken,\n        string memory _dTokenName,\n        string memory _dTokenSymbol\n    ) RewardsPoolV1(_poolOwners, _rewardsToken, _dTokenName, _dTokenSymbol) {\n        poolOwners = _poolOwners;\n    }\n\n    /**\n     * @dev withdraws a user's earned rewards\n     * @param _amount amount to withdraw\n     **/\n    function withdraw(uint256 _amount) public virtual override {\n        uint256 toWithdraw = _amount;\n\n        if (_amount == type(uint256).max) {\n            toWithdraw = balanceOf(msg.sender);\n        }\n\n        distributedRewards -= toWithdraw;\n        super.withdraw(toWithdraw);\n    }\n\n    /**\n     * @dev withdraws all of a user's earned rewards\n     * @param _account user to withdraw for\n     **/\n    function withdraw(address _account) external virtual nonReentrant {\n        require(msg.sender == poolOwners, \"PoolOwners only\");\n\n        uint256 toWithdraw = balanceOf(_account);\n\n        if (toWithdraw > 0) {\n            _updateReward(_account);\n            _burn(_account, toWithdraw);\n            distributedRewards -= toWithdraw;\n            rewardsToken.safeTransfer(_account, toWithdraw);\n            emit Withdrawn(_account, toWithdraw);\n        }\n    }\n\n    /**\n     * @dev ERC677 implementation that automatically calls distributeRewards\n     * @param _sender of the token transfer\n     * @param _value of the token transfer\n     **/\n    function onTokenTransfer(\n        address _sender,\n        uint256 _value,\n        bytes calldata\n    ) external nonReentrant {\n        require(msg.sender == address(rewardsToken), \"Sender must be rewards token\");\n        distributeRewards();\n    }\n\n    /**\n     * @dev distributes new rewards that have been deposited\n     **/\n    function distributeRewards() public {\n        require(stakingDerivative.totalSupply() > 0, \"Cannot distribute when nothing is staked\");\n        uint256 toDistribute = rewardsToken.balanceOf(address(this)) - distributedRewards;\n        distributedRewards += toDistribute;\n        _updateRewardPerToken(toDistribute);\n        emit RewardDistributed(msg.sender, stakingDerivative.totalSupply(), toDistribute);\n    }\n}\n"
    },
    "contracts/core/base/StakingRewardsPool.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../tokens/base/VirtualERC677.sol\";\n\n/**\n * @title StakingRewardsPool\n * @notice Handles staking and reward distribution for a single asset\n * @dev Rewards can be positive or negative (user balances can increase and decrease)\n */\nabstract contract StakingRewardsPool is VirtualERC677 {\n    using SafeERC20 for IERC677;\n\n    IERC677 public immutable token;\n\n    mapping(address => uint) private shares;\n    uint public totalShares;\n\n    constructor(\n        address _token,\n        string memory _derivativeTokenName,\n        string memory _derivativeTokenSymbol\n    ) VirtualERC677(_derivativeTokenName, _derivativeTokenSymbol) {\n        token = IERC677(_token);\n    }\n\n    /**\n     * @notice returns the total supply of staking derivative tokens\n     * @return total supply\n     */\n    function totalSupply() public view override(IERC20, VirtualERC20) returns (uint) {\n        return _totalStaked();\n    }\n\n    /**\n     * @notice returns an account's stake balance\n     * @param _account account to return balance for\n     * @return account's stake balance\n     **/\n    function balanceOf(address _account) public view override(IERC20, VirtualERC20) returns (uint) {\n        uint balance = getStakeByShares(shares[_account]);\n        if (balance < 100) {\n            return 0;\n        } else {\n            return balance;\n        }\n    }\n\n    /**\n     * @notice returns an account's share balance\n     * @param _account account to return balance for\n     * @return account's share balance\n     **/\n    function sharesOf(address _account) public view returns (uint) {\n        return shares[_account];\n    }\n\n    /**\n     * @notice returns the amount of shares that corresponds to a staked amount\n     * @param _amount staked amount\n     * @return amount of shares\n     **/\n    function getSharesByStake(uint256 _amount) public view returns (uint256) {\n        uint totalStaked = _totalStaked();\n        if (totalStaked == 0) {\n            return 0;\n        } else {\n            return (_amount * totalShares) / totalStaked;\n        }\n    }\n\n    /**\n     * @notice returns the amount of stake that corresponds to an amount of shares\n     * @param _amount shares amount\n     * @return amount of stake\n     **/\n    function getStakeByShares(uint256 _amount) public view returns (uint256) {\n        if (totalShares == 0) {\n            return 0;\n        } else {\n            return (_amount * _totalStaked()) / totalShares;\n        }\n    }\n\n    /**\n     * @notice returns the total amount of assets staked in the pool\n     * @return total staked amount\n     */\n    function _totalStaked() internal view virtual returns (uint);\n\n    /**\n     * @notice transfers a stake balance from one account to another\n     * @param _sender account to transfer from\n     * @param _recipient account to transfer to\n     * @param _amount amount to transfer\n     **/\n    function _transfer(\n        address _sender,\n        address _recipient,\n        uint _amount\n    ) internal override {\n        uint sharesToTransfer = getSharesByStake(_amount);\n\n        require(_sender != address(0), \"Transfer from the zero address\");\n        require(_recipient != address(0), \"Transfer to the zero address\");\n        require(shares[_sender] >= sharesToTransfer, \"Transfer amount exceeds balance\");\n\n        shares[_sender] -= sharesToTransfer;\n        shares[_recipient] += sharesToTransfer;\n\n        emit Transfer(_sender, _recipient, _amount);\n    }\n\n    /**\n     * @notice mints new shares to an account\n     * @dev takes a stake amount and calculates the amount of shares it corresponds to\n     * @param _recipient account to mint shares for\n     * @param _amount stake amount\n     **/\n    function _mint(address _recipient, uint _amount) internal override {\n        uint sharesToMint = getSharesByStake(_amount);\n        if (sharesToMint == 0) {\n            sharesToMint = _amount;\n        }\n\n        _mintShares(_recipient, sharesToMint);\n    }\n\n    /**\n     * @notice mints new shares to an account\n     * @param _recipient account to mint shares for\n     * @param _amount shares amount\n     **/\n    function _mintShares(address _recipient, uint _amount) internal {\n        require(_recipient != address(0), \"Mint to the zero address\");\n\n        totalShares += _amount;\n        shares[_recipient] += _amount;\n    }\n\n    /**\n     * @notice burns shares belonging to an account\n     * @dev takes a stake amount and calculates the amount of shares it corresponds to\n     * @param _account account to burn shares for\n     * @param _amount stake amount\n     **/\n    function _burn(address _account, uint _amount) internal override {\n        uint sharesToBurn = getSharesByStake(_amount);\n\n        require(_account != address(0), \"Burn from the zero address\");\n        require(shares[_account] >= sharesToBurn, \"Burn amount exceeds balance\");\n\n        totalShares -= sharesToBurn;\n        shares[_account] -= sharesToBurn;\n    }\n}\n"
    },
    "contracts/core/StakingPool.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./base/StakingRewardsPool.sol\";\nimport \"./interfaces/IStrategy.sol\";\nimport \"./interfaces/IWrappedSDToken.sol\";\nimport \"./interfaces/IDelegatorPool.sol\";\n\n/**\n * @title Staking Pool\n * @notice Allows users to stake an asset and receive derivative tokens 1:1, then deposits staked\n * assets into strategy contracts to earn returns\n */\ncontract StakingPool is StakingRewardsPool, Ownable {\n    using SafeERC20 for IERC677;\n\n    struct Fee {\n        address receiver;\n        uint basisPoints;\n    }\n\n    address[] private strategies;\n    uint public totalStaked;\n    uint public liquidityBuffer;\n\n    Fee[] private fees;\n\n    address public immutable poolRouter;\n    address public immutable delegatorPool;\n    uint16 public poolIndex;\n\n    event Stake(address indexed account, uint amount);\n    event Withdraw(address indexed account, uint amount);\n    event UpdateStrategyRewards(address indexed account, uint totalStaked, int rewardsAmount, uint totalFees);\n\n    constructor(\n        address _token,\n        string memory _derivativeTokenName,\n        string memory _derivativeTokenSymbol,\n        Fee[] memory _fees,\n        address _poolRouter,\n        address _delegatorPool\n    ) StakingRewardsPool(_token, _derivativeTokenName, _derivativeTokenSymbol) {\n        for (uint i = 0; i < _fees.length; i++) {\n            fees.push(_fees[i]);\n        }\n        poolRouter = _poolRouter;\n        delegatorPool = _delegatorPool;\n    }\n\n    modifier onlyRouter() {\n        require(poolRouter == msg.sender, \"PoolRouter only\");\n        _;\n    }\n\n    /**\n     * @notice returns a list of all active strategies\n     * @return list of strategies\n     */\n    function getStrategies() external view returns (address[] memory) {\n        return strategies;\n    }\n\n    /**\n     * @notice returns a list of all fees\n     * @return list of fees\n     */\n    function getFees() external view returns (Fee[] memory) {\n        return fees;\n    }\n\n    /**\n     * @notice stakes asset tokens and mints derivative tokens\n     * @param _account account to stake for\n     * @param _amount amount to stake\n     **/\n    function stake(address _account, uint _amount) external onlyRouter {\n        require(strategies.length > 0, \"Must be > 0 strategies to stake\");\n\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n        depositLiquidity();\n\n        _mint(_account, _amount);\n        totalStaked += _amount;\n\n        emit Stake(_account, _amount);\n    }\n\n    /**\n     * @notice withdraws asset tokens and burns derivative tokens\n     * @dev will withdraw from strategies if not enough liquidity\n     * @param _account account to withdraw for\n     * @param _receiver address to receive withdrawal\n     * @param _amount amount to withdraw\n     **/\n    function withdraw(\n        address _account,\n        address _receiver,\n        uint _amount\n    ) external onlyRouter {\n        uint toWithdraw = _amount;\n        if (_amount == type(uint).max) {\n            toWithdraw = balanceOf(_account);\n        }\n\n        uint balance = token.balanceOf(address(this));\n        if (toWithdraw > balance) {\n            _withdrawLiquidity(toWithdraw - balance);\n        }\n        require(token.balanceOf(address(this)) >= toWithdraw, \"Not enough liquidity available to withdraw\");\n\n        _burn(_account, toWithdraw);\n        totalStaked -= toWithdraw;\n        token.safeTransfer(_receiver, toWithdraw);\n\n        emit Withdraw(_account, toWithdraw);\n    }\n\n    /**\n     * @notice deposits assets in a strategy\n     * @param _index index of strategy to deposit in\n     * @param _amount amount to deposit\n     **/\n    function strategyDeposit(uint _index, uint _amount) external onlyOwner {\n        require(_index < strategies.length, \"Strategy does not exist\");\n        IStrategy(strategies[_index]).deposit(_amount);\n    }\n\n    /**\n     * @notice withdraws assets from a strategy\n     * @param _index index of strategy to withdraw from\n     * @param _amount amount to withdraw\n     **/\n    function strategyWithdraw(uint _index, uint _amount) external onlyOwner {\n        require(_index < strategies.length, \"Strategy does not exist\");\n        IStrategy(strategies[_index]).withdraw(_amount);\n    }\n\n    /**\n     * @notice returns the maximum amount that can be staked via the pool\n     * @return the overall staking limit\n     **/\n    function getMaxDeposits() public view returns (uint256) {\n        uint256 max;\n\n        for (uint i = 0; i < strategies.length; i++) {\n            IStrategy strategy = IStrategy(strategies[i]);\n            max += strategy.getMaxDeposits();\n        }\n        if (liquidityBuffer > 0) {\n            max += (max * liquidityBuffer) / 10000;\n        }\n        return max;\n    }\n\n    /**\n     * @notice returns the minimum amount that must remain the pool\n     * @return min deposit\n     */\n    function getMinDeposits() public view returns (uint256) {\n        uint256 min;\n\n        for (uint i = 0; i < strategies.length; i++) {\n            IStrategy strategy = IStrategy(strategies[i]);\n            min += strategy.getMinDeposits();\n        }\n\n        return min;\n    }\n\n    /**\n     * @notice returns the available deposit room for this pool\n     * @return available deposit room\n     */\n    function canDeposit() external view returns (uint256) {\n        uint max = getMaxDeposits();\n\n        if (max <= totalStaked) {\n            return 0;\n        } else {\n            return max - totalStaked;\n        }\n    }\n\n    /**\n     * @notice returns the available withdrawal room for this pool\n     * @return available withdrawal room\n     */\n    function canWithdraw() external view returns (uint256) {\n        uint min = getMinDeposits();\n\n        if (min >= totalStaked) {\n            return 0;\n        } else {\n            return totalStaked - min;\n        }\n    }\n\n    /**\n     * @notice adds a new strategy\n     * @param _strategy address of strategy to add\n     **/\n    function addStrategy(address _strategy) external onlyOwner {\n        require(!_strategyExists(_strategy), \"Strategy already exists\");\n        token.safeApprove(_strategy, type(uint).max);\n        strategies.push(_strategy);\n    }\n\n    /**\n     * @notice removes a strategy\n     * @param _index index of strategy to remove\n     **/\n    function removeStrategy(uint _index) external onlyOwner {\n        require(_index < strategies.length, \"Strategy does not exist\");\n\n        uint[] memory idxs = new uint[](1);\n        idxs[0] = _index;\n        updateStrategyRewards(idxs);\n\n        IStrategy strategy = IStrategy(strategies[_index]);\n        uint totalStrategyDeposits = strategy.getTotalDeposits();\n        if (totalStrategyDeposits > 0) {\n            require(strategy.canWithdraw() == totalStrategyDeposits, \"Strategy contains deposits that cannot be withdrawn\");\n            strategy.withdraw(totalStrategyDeposits);\n        }\n\n        for (uint i = _index; i < strategies.length - 1; i++) {\n            strategies[i] = strategies[i + 1];\n        }\n        strategies.pop();\n        token.safeApprove(address(strategy), 0);\n    }\n\n    /**\n     * @notice reorders strategies\n     * @param _newOrder array containing strategy indexes in a new order\n     **/\n    function reorderStrategies(uint[] calldata _newOrder) external onlyOwner {\n        require(_newOrder.length == strategies.length, \"newOrder.length must = strategies.length\");\n\n        address[] memory strategyAddresses = new address[](strategies.length);\n        for (uint i = 0; i < strategies.length; i++) {\n            strategyAddresses[i] = strategies[i];\n        }\n\n        for (uint i = 0; i < strategies.length; i++) {\n            require(strategyAddresses[_newOrder[i]] != address(0), \"all indices must be valid\");\n            strategies[i] = strategyAddresses[_newOrder[i]];\n            strategyAddresses[_newOrder[i]] = address(0);\n        }\n    }\n\n    /**\n     * @notice adds a new fee\n     * @param _receiver receiver of fee\n     * @param _feeBasisPoints fee in basis points\n     **/\n    function addFee(address _receiver, uint _feeBasisPoints) external onlyOwner {\n        fees.push(Fee(_receiver, _feeBasisPoints));\n    }\n\n    /**\n     * @notice updates an existing fee\n     * @param _index index of fee\n     * @param _receiver receiver of fee\n     * @param _feeBasisPoints fee in basis points\n     **/\n    function updateFee(\n        uint _index,\n        address _receiver,\n        uint _feeBasisPoints\n    ) external onlyOwner {\n        require(_index < fees.length, \"Fee does not exist\");\n\n        if (_feeBasisPoints == 0) {\n            fees[_index] = fees[fees.length - 1];\n            fees.pop();\n        } else {\n            fees[_index].receiver = _receiver;\n            fees[_index].basisPoints = _feeBasisPoints;\n        }\n    }\n\n    /**\n     * @notice Sets the liquidity buffer. The liquidity buffer will increase the max staking limit\n     * of the pool by always keeping a % of the staked token as liquid within the pool. The buffer\n     * has the effect of diluting yield, but promotes pool liquidity with any lock-in that would prevent\n     * the un-wind of allowance.\n     * @param _liquidityBufferBasisPoints basis points to use for the liquidity buffer\n     **/\n    function setLiquidityBuffer(uint _liquidityBufferBasisPoints) external onlyOwner {\n        liquidityBuffer = _liquidityBufferBasisPoints;\n    }\n\n    /**\n     * @notice updates and distributes rewards based on balance changes in strategies\n     * @param _strategyIdxs indexes of strategies to update rewards for\n     **/\n    function updateStrategyRewards(uint[] memory _strategyIdxs) public {\n        int totalRewards;\n        uint totalFeeAmounts;\n        uint totalFeeCount;\n        address[][] memory receivers = new address[][](strategies.length + 1);\n        uint[][] memory feeAmounts = new uint[][](strategies.length + 1);\n\n        for (uint i = 0; i < _strategyIdxs.length; i++) {\n            IStrategy strategy = IStrategy(strategies[_strategyIdxs[i]]);\n            int rewards = strategy.depositChange();\n            if (rewards != 0) {\n                (address[] memory strategyReceivers, uint[] memory strategyFeeAmounts) = strategy.updateDeposits();\n                totalRewards += rewards;\n                if (rewards > 0) {\n                    receivers[i] = (strategyReceivers);\n                    feeAmounts[i] = (strategyFeeAmounts);\n                    totalFeeCount += receivers[i].length;\n                    for (uint j = 0; j < strategyReceivers.length; j++) {\n                        totalFeeAmounts += strategyFeeAmounts[j];\n                    }\n                }\n            }\n        }\n\n        if (totalRewards != 0) {\n            totalStaked = uint(int(totalStaked) + totalRewards);\n        }\n\n        if (totalRewards > 0) {\n            uint currentRate = IDelegatorPool(delegatorPool).currentRate(address(token), poolIndex);\n            uint feesLength = currentRate > 0 ? fees.length + 1 : fees.length;\n\n            receivers[receivers.length - 1] = new address[](feesLength);\n            feeAmounts[feeAmounts.length - 1] = new uint[](feesLength);\n            totalFeeCount += feesLength;\n\n            for (uint i = 0; i < fees.length; i++) {\n                receivers[receivers.length - 1][i] = fees[i].receiver;\n                feeAmounts[feeAmounts.length - 1][i] = (uint(totalRewards) * fees[i].basisPoints) / 10000;\n                totalFeeAmounts += feeAmounts[feeAmounts.length - 1][i];\n            }\n\n            if (currentRate > 0) {\n                receivers[receivers.length - 1][fees.length] = delegatorPool;\n                feeAmounts[feeAmounts.length - 1][fees.length] = (uint(totalRewards) * currentRate) / 10000;\n                totalFeeAmounts += feeAmounts[feeAmounts.length - 1][fees.length];\n            }\n        }\n\n        if (totalFeeAmounts > 0) {\n            uint sharesToMint = (totalFeeAmounts * totalShares) / (totalStaked - totalFeeAmounts);\n            _mintShares(address(this), sharesToMint);\n\n            uint feesPaidCount;\n            for (uint i = 0; i < receivers.length; i++) {\n                for (uint j = 0; j < receivers[i].length; j++) {\n                    if (feesPaidCount == totalFeeCount - 1) {\n                        transferAndCallFrom(address(this), receivers[i][j], balanceOf(address(this)), \"0x00\");\n                    } else {\n                        transferAndCallFrom(address(this), receivers[i][j], feeAmounts[i][j], \"0x00\");\n                        feesPaidCount++;\n                    }\n                }\n            }\n        }\n\n        emit UpdateStrategyRewards(msg.sender, totalStaked, totalRewards, totalFeeAmounts);\n    }\n\n    /**\n     * @notice deposits available liquidity into strategies by order of priority\n     * @dev deposits into strategies[0] until its limit is reached, then strategies[1], and so on\n     **/\n    function depositLiquidity() public {\n        uint toDeposit = token.balanceOf(address(this));\n        if (toDeposit > 0) {\n            for (uint i = 0; i < strategies.length; i++) {\n                IStrategy strategy = IStrategy(strategies[i]);\n                uint canDeposit = strategy.canDeposit();\n                if (canDeposit >= toDeposit) {\n                    strategy.deposit(toDeposit);\n                    break;\n                } else if (canDeposit > 0) {\n                    strategy.deposit(canDeposit);\n                    toDeposit -= canDeposit;\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice sets the index of this pool as stored in the pool router\n     * @param _poolIndex index of pool\n     */\n    function setPoolIndex(uint16 _poolIndex) external onlyRouter {\n        poolIndex = _poolIndex;\n    }\n\n    /**\n     * @notice returns the total amount of assets staked in the pool\n     * @return the total staked amount\n     */\n    function _totalStaked() internal view override returns (uint) {\n        return totalStaked;\n    }\n\n    /**\n     * @notice withdraws liquidity from strategies in opposite order of priority\n     * @dev withdraws from strategies[strategies.length - 1], then strategies[strategies.length - 2], and so on\n     * until withdraw amount is reached\n     * @param _amount amount to withdraw\n     **/\n    function _withdrawLiquidity(uint _amount) private {\n        uint toWithdraw = _amount;\n\n        for (uint i = strategies.length; i > 0; i--) {\n            IStrategy strategy = IStrategy(strategies[i - 1]);\n            uint canWithdraw = strategy.canWithdraw();\n\n            if (canWithdraw >= toWithdraw) {\n                strategy.withdraw(toWithdraw);\n                break;\n            } else if (canWithdraw > 0) {\n                strategy.withdraw(canWithdraw);\n                toWithdraw -= canWithdraw;\n            }\n        }\n    }\n\n    /**\n     * @notice checks whether or not a strategy exists\n     * @param _strategy address of strategy\n     * @return true if strategy exists, false otherwise\n     **/\n    function _strategyExists(address _strategy) private view returns (bool) {\n        for (uint i = 0; i < strategies.length; i++) {\n            if (strategies[i] == _strategy) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"
    },
    "contracts/core/interfaces/IWrappedSDToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"./IERC677.sol\";\n\ninterface IWrappedSDToken is IERC677 {\n    /**\n     * @notice wraps tokens\n     * @param _amount amount of unwrapped tokens to wrap\n     */\n    function wrap(uint _amount) external;\n\n    /**\n     * @notice unwraps tokens\n     * @param _amount amount of wrapped tokens to unwrap\n     */\n    function unwrap(uint _amount) external;\n\n    /**\n     * @notice Returns amount of unwrapped tokens for an amount of wrapped tokens\n     * @param _amount amount of wrapped tokens\n     * @return amount of unwrapped tokens\n     */\n    function getUnderlyingByWrapped(uint _amount) external view returns (uint);\n\n    function sdToken() external view returns (address);\n}\n"
    },
    "contracts/core/test/PoolRouterMock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../interfaces/IDelegatorPool.sol\";\n\n/**\n * @title Pool Router Mock\n * @dev Mocks contract for testing\n */\ncontract PoolRouterMock {\n    using SafeERC20 for IERC20;\n\n    address public delegatorPool;\n    address public allowanceToken;\n    address public token;\n\n    uint16 public index;\n    uint public totalRewards;\n\n    bool public reservedMode;\n\n    uint public poolUtilisationPercentage;\n\n    constructor(\n        address _allowanceToken,\n        address _token,\n        uint16 _index\n    ) {\n        allowanceToken = _allowanceToken;\n        token = _token;\n        index = _index;\n    }\n\n    function maxAllowanceInUse() public view returns (uint) {\n        return 20 ether;\n    }\n\n    function allowanceInUse(address _token, uint16 _index) public view returns (uint) {\n        if (_token != token || _index != index) {\n            return 0;\n        }\n\n        return 10 ether;\n    }\n\n    function setReservedMode(bool _reservedMode) external {\n        reservedMode = _reservedMode;\n    }\n\n    function isReservedMode() external view returns (bool) {\n        return reservedMode;\n    }\n\n    function getReservedMultiplier() external view returns (uint) {\n        return 10000;\n    }\n\n    function setPoolUtilisation(uint _poolUtilisationPercentage) external {\n        poolUtilisationPercentage = _poolUtilisationPercentage;\n    }\n\n    function poolUtilisation(address _token, uint16 _index) external view returns (uint) {\n        return poolUtilisationPercentage;\n    }\n\n    function onTokenTransfer(\n        address _sender,\n        uint _value,\n        bytes calldata _calldata\n    ) external {\n        require(msg.sender == allowanceToken, \"Unauthorized\");\n        IDelegatorPool(delegatorPool).stakeAllowance(_sender, _value);\n    }\n\n    function setDelegatorPool(address _delegatorPool) external {\n        delegatorPool = _delegatorPool;\n        IERC20(allowanceToken).safeApprove(_delegatorPool, type(uint).max);\n    }\n}\n"
    },
    "contracts/core/RewardsPoolWSD.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./interfaces/IRewardsPoolController.sol\";\nimport \"./interfaces/IWrappedSDToken.sol\";\nimport \"./RewardsPool.sol\";\n\n/**\n * @title RewardsPoolWSD\n * @notice Handles reward distribution for a single wrapped staking derivative token\n * @dev rewards can only be positive (user balances can only increase)\n */\ncontract RewardsPoolWSD is RewardsPool {\n    using SafeERC20 for IERC677;\n\n    IWrappedSDToken public wsdToken;\n\n    constructor(\n        address _controller,\n        address _token,\n        address _wsdToken\n    ) RewardsPool(_controller, _token) {\n        wsdToken = IWrappedSDToken(_wsdToken);\n    }\n\n    /**\n     * @notice returns an account's total unwrapped withdrawable rewards (principal balance + newly earned rewards)\n     * @param _account account to return rewards for\n     * @return account's total unclaimed rewards\n     **/\n    function withdrawableRewards(address _account) public view override returns (uint) {\n        return wsdToken.getUnderlyingByWrapped(super.withdrawableRewards(_account));\n    }\n\n    /**\n     * @notice returns an account's total wrapped withdrawable rewards (principal balance + newly earned rewards)\n     * @param _account account to return rewards for\n     * @return account's total unclaimed rewards\n     **/\n    function withdrawableRewardsWrapped(address _account) public view returns (uint) {\n        return super.withdrawableRewards(_account);\n    }\n\n    /**\n     * @notice distributes new rewards that have been deposited\n     **/\n    function distributeRewards() public override {\n        require(controller.totalStaked() > 0, \"Cannot distribute when nothing is staked\");\n\n        uint balance = token.balanceOf(address(this));\n        token.transferAndCall(address(wsdToken), balance, \"0x00\");\n\n        uint256 toDistribute = wsdToken.balanceOf(address(this)) - totalRewards;\n        totalRewards += toDistribute;\n        _updateRewardPerToken(toDistribute);\n\n        emit DistributeRewards(msg.sender, controller.totalStaked(), balance);\n    }\n\n    /**\n     * @notice updates an account's principal reward balance\n     * @param _account account to update for\n     **/\n    function updateReward(address _account) public override {\n        uint newRewards = withdrawableRewardsWrapped(_account) - userRewards[_account];\n        if (newRewards > 0) {\n            userRewards[_account] += newRewards;\n        }\n        userRewardPerTokenPaid[_account] = rewardPerToken;\n    }\n\n    /**\n     * @notice withdraws rewards for an account\n     * @param _account account to withdraw for\n     **/\n    function _withdraw(address _account) internal override {\n        uint256 toWithdraw = withdrawableRewardsWrapped(_account);\n        uint toWithdrawUnwrapped = wsdToken.getUnderlyingByWrapped(toWithdraw);\n\n        if (toWithdraw > 0) {\n            updateReward(_account);\n            userRewards[_account] -= toWithdraw;\n            totalRewards -= toWithdraw;\n\n            wsdToken.unwrap(toWithdraw);\n            token.safeTransfer(_account, toWithdrawUnwrapped);\n\n            emit Withdraw(_account, toWithdrawUnwrapped);\n        }\n    }\n}\n"
    },
    "contracts/linkStaking/interfaces/IStakingStrategy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"../../core/interfaces/IStrategy.sol\";\n\ninterface IStakingStrategy is IStrategy {\n    function migrate(bytes calldata data) external;\n}\n"
    },
    "contracts/core/tokens/WrappedSDToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"./base/ERC677.sol\";\nimport \"../interfaces/IStakingRewardsPool.sol\";\n\n/**\n * @title Wrapped Staking Derivative Token\n * @notice Wraps rebasing derivative tokens with a normal ERC20 token\n */\ncontract WrappedSDToken is ERC677 {\n    IStakingRewardsPool public immutable sdToken;\n\n    constructor(\n        address _stakingRewardsPool,\n        string memory _name,\n        string memory _symbol\n    ) ERC677(_name, _symbol, 0) {\n        sdToken = IStakingRewardsPool(_stakingRewardsPool);\n    }\n\n    /**\n     * @notice ERC677 implementation that proxies wrapping\n     * @param _sender of the token transfer\n     * @param _value of the token transfer\n     **/\n    function onTokenTransfer(\n        address _sender,\n        uint _value,\n        bytes calldata\n    ) external {\n        require(msg.sender == address(sdToken), \"Sender must be staking derivative token\");\n        _wrap(_sender, _value);\n    }\n\n    /**\n     * @notice wraps tokens\n     * @param _amount amount of unwrapped tokens to wrap\n     */\n    function wrap(uint _amount) external {\n        sdToken.transferFrom(msg.sender, address(this), _amount);\n        _wrap(msg.sender, _amount);\n    }\n\n    /**\n     * @notice unwraps tokens\n     * @param _amount amount of wrapped tokens to unwrap\n     */\n    function unwrap(uint _amount) external {\n        require(_amount > 0, \"Amount must be > 0\");\n        uint256 unwrappedAmount = sdToken.getStakeByShares(_amount);\n        _burn(msg.sender, _amount);\n        sdToken.transfer(msg.sender, unwrappedAmount);\n    }\n\n    /**\n     * @notice Returns amount of wrapped tokens for an amount of unwrapped tokens\n     * @param _amount amount of unwrapped tokens\n     * @return amount of wrapped tokens\n     */\n    function getWrappedByUnderlying(uint _amount) external view returns (uint) {\n        return sdToken.getSharesByStake(_amount);\n    }\n\n    /**\n     * @notice Returns amount of unwrapped tokens for an amount of wrapped tokens\n     * @param _amount amount of wrapped tokens\n     * @return amount of unwrapped tokens\n     */\n    function getUnderlyingByWrapped(uint _amount) external view returns (uint) {\n        return sdToken.getStakeByShares(_amount);\n    }\n\n    /**\n     * @notice wraps tokens\n     * @param _account account to wrap tokens for\n     * @param _amount amount of unwrapped tokens to wrap\n     */\n    function _wrap(address _account, uint _amount) private {\n        require(_amount > 0, \"Amount must be > 0\");\n        uint256 wrappedAmount = sdToken.getSharesByStake(_amount);\n        _mint(_account, wrappedAmount);\n    }\n}\n"
    },
    "contracts/core/SlashingKeeper.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"@chainlink/contracts/src/v0.8/KeeperCompatible.sol\";\n\nimport \"./interfaces/IStakingPool.sol\";\nimport \"./interfaces/IStrategy.sol\";\n\n/**\n * @title Slashing Keeper\n * @notice Updates strategy rewards if any losses have been inucurred\n */\ncontract SlashingKeeper is KeeperCompatibleInterface {\n    IStakingPool public stakingPool;\n\n    constructor(address _stakingPool) {\n        stakingPool = IStakingPool(_stakingPool);\n    }\n\n    /**\n     * @notice returns whether or not rewards should be updated and the strategies to update\n     * @return upkeepNeeded whether or not rewards should be updated\n     * @return performData abi encoded list of strategy indexes to update\n     **/\n    function checkUpkeep(bytes calldata _checkData) external view override returns (bool, bytes memory) {\n        address[] memory strategies = stakingPool.getStrategies();\n        bool[] memory strategiesToUpdate = new bool[](strategies.length);\n        uint totalStrategiesToUpdate;\n\n        for (uint i = 0; i < strategies.length; i++) {\n            IStrategy strategy = IStrategy(strategies[i]);\n            if (strategy.depositChange() < 0) {\n                strategiesToUpdate[i] = true;\n                totalStrategiesToUpdate++;\n            }\n        }\n\n        if (totalStrategiesToUpdate > 0) {\n            uint[] memory strategyIdxs = new uint[](totalStrategiesToUpdate);\n            uint strategiesAdded;\n\n            for (uint i = 0; i < strategiesToUpdate.length; i++) {\n                if (strategiesToUpdate[i]) {\n                    strategyIdxs[strategiesAdded] = i;\n                    strategiesAdded++;\n                }\n            }\n\n            return (true, abi.encode(strategyIdxs));\n        }\n\n        return (false, \"0x00\");\n    }\n\n    /**\n     * @notice Updates rewards\n     * @param _performData abi encoded list of strategy indexes to update\n     */\n    function performUpkeep(bytes calldata _performData) external override {\n        address[] memory strategies = stakingPool.getStrategies();\n        uint[] memory strategiesToUpdate = abi.decode(_performData, (uint[]));\n        require(strategiesToUpdate.length > 0, \"No strategies to update\");\n\n        for (uint i = 0; i < strategiesToUpdate.length; i++) {\n            require(IStrategy(strategies[strategiesToUpdate[i]]).depositChange() < 0, \"Deposit change is >= 0\");\n        }\n        stakingPool.updateStrategyRewards(strategiesToUpdate);\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/KeeperCompatible.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./KeeperBase.sol\";\nimport \"./interfaces/KeeperCompatibleInterface.sol\";\n\nabstract contract KeeperCompatible is KeeperBase, KeeperCompatibleInterface {}\n"
    },
    "@chainlink/contracts/src/v0.8/KeeperBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract KeeperBase {\n  error OnlySimulatedBackend();\n\n  /**\n   * @notice method that allows it to be simulated via eth_call by checking that\n   * the sender is the zero address.\n   */\n  function preventExecution() internal view {\n    if (tx.origin != address(0)) {\n      revert OnlySimulatedBackend();\n    }\n  }\n\n  /**\n   * @notice modifier that allows it to be simulated via eth_call by checking\n   * that the sender is the zero address.\n   */\n  modifier cannotExecute() {\n    preventExecution();\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/KeeperCompatibleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface KeeperCompatibleInterface {\n  /**\n   * @notice method that is simulated by the keepers to see if any work actually\n   * needs to be performed. This method does does not actually need to be\n   * executable, and since it is only ever simulated it can consume lots of gas.\n   * @dev To ensure that it is never called, you may want to add the\n   * cannotExecute modifier from KeeperBase to your implementation of this\n   * method.\n   * @param checkData specified in the upkeep registration so it is always the\n   * same for a registered upkeep. This can easily be broken down into specific\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\n   * same contract and easily differentiated by the contract.\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\n   * performUpkeep or not.\n   * @return performData bytes that the keeper should call performUpkeep with, if\n   * upkeep is needed. If you would like to encode data to decode later, try\n   * `abi.encode`.\n   */\n  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\n\n  /**\n   * @notice method that is actually executed by the keepers, via the registry.\n   * The data returned by the checkUpkeep simulation will be passed into\n   * this method to actually be executed.\n   * @dev The input to this method should not be trusted, and the caller of the\n   * method should not even be restricted to any single registry. Anyone should\n   * be able call it, and the input should be validated, there is no guarantee\n   * that the data passed in is the performData returned from checkUpkeep. This\n   * could happen due to malicious keepers, racing keepers, or simply a state\n   * change while the performUpkeep transaction is waiting for confirmation.\n   * Always validate the data passed in.\n   * @param performData is the data which was passed back from the checkData\n   * simulation. If it is encoded, it can easily be decoded into other types by\n   * calling `abi.decode`. This data should not be trusted, and should be\n   * validated against the contract's current state.\n   */\n  function performUpkeep(bytes calldata performData) external;\n}\n"
    },
    "contracts/core/tokens/StakingAllowance.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./base/ERC677.sol\";\n\n/**\n * @title Allowance token for staking fair-access\n * @notice Allows for an elastic supply where allowance is calculated by balance & supply\n */\ncontract StakingAllowance is ERC677, Ownable {\n    constructor(string memory _name, string memory _symbol) ERC677(_name, _symbol, 0) {}\n\n    /**\n     * @dev Mints a given amount of tokens to an account\n     * @param _account address to mint to\n     * @param _amount amount of tokens to mint\n     **/\n    function mint(address _account, uint256 _amount) public onlyOwner {\n        _mint(_account, _amount);\n    }\n\n    /**\n     * @dev Mints a given amount of tokens to a contract on behalf of an account via ERC677\n     * @param _contract to send tokens to\n     * @param _account address to mint to\n     * @param _amount amount of tokens to mint\n     **/\n    function mintToContract(\n        address _contract,\n        address _account,\n        uint256 _amount,\n        bytes calldata _calldata\n    ) public onlyOwner {\n        _mint(msg.sender, _amount);\n        transferAndCallWithSender(_account, _contract, _amount, _calldata);\n    }\n\n    /**\n     * @dev Burns a given amount of tokens from the sender\n     * @param _amount amount of tokens to burn\n     **/\n    function burn(uint256 _amount) public {\n        _burn(msg.sender, _amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     */\n    function burnFrom(address account, uint256 amount) public {\n        _spendAllowance(account, msg.sender, amount);\n        _burn(account, amount);\n    }\n\n    /**\n     * @dev re-implementation of ERC677 transferAndCall but with the ability to specify a custom sender,\n     * needed as the allowance mint needs to be minted on behalf of an address and send to a contract fallback.\n     * @param _sender the specified sender of the tokens, the party who 'receives' them into a contract\n     * @param _to the contract to send the minted tokens to\n     * @param _value the token amount\n     * @param _data the calldata included in the transfer\n     */\n    function transferAndCallWithSender(\n        address _sender,\n        address _to,\n        uint256 _value,\n        bytes calldata _data\n    ) private returns (bool) {\n        require(isContract(_to), \"to address has to be a contract\");\n        super.transfer(_to, _value);\n        contractFallback(_sender, _to, _value, _data);\n        return true;\n    }\n}\n"
    },
    "contracts/core/test/v1/PoolAllowanceV1.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"../../tokens/base/ERC677.sol\";\n\n/**\n * @title Pool Allowance\n * @dev Pool staking allowance token\n */\ncontract PoolAllowanceV1 is ERC677 {\n    address public poolOwners;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _poolOwners\n    ) ERC677(_name, _symbol, 0) {\n        poolOwners = _poolOwners;\n    }\n\n    modifier onlyPoolOwners() {\n        require(poolOwners == msg.sender, \"PoolOwners only\");\n        _;\n    }\n\n    /**\n     * @dev mints allowance tokens\n     * @param _account address to mint tokens for\n     * @param _amount amount to mint\n     **/\n    function mintAllowance(address _account, uint256 _amount) external onlyPoolOwners {\n        _mint(_account, _amount);\n    }\n\n    /**\n     * @dev burns allowance tokens\n     * @param _account address to burn tokens from\n     * @param _amount amount to burn\n     **/\n    function burnAllowance(address _account, uint256 _amount) external onlyPoolOwners {\n        _burn(_account, _amount);\n    }\n}\n"
    },
    "contracts/core/test/WrappedSDTokenMock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"../tokens/base/ERC677.sol\";\n\n/**\n * @title Wrapped Staking Derivative Token\n * @notice Mocks contract for testing\n */\ncontract WrappedSDTokenMock is ERC677 {\n    IERC20 public immutable sdToken;\n    uint multiplier;\n\n    constructor(address _sdToken) ERC677(\"test\", \"test\", 0) {\n        sdToken = IERC20(_sdToken);\n        multiplier = 2;\n    }\n\n    /**\n     * @notice ERC677 implementation that proxies wrapping\n     * @param _sender of the token transfer\n     * @param _value of the token transfer\n     **/\n    function onTokenTransfer(\n        address _sender,\n        uint _value,\n        bytes calldata\n    ) external {\n        require(msg.sender == address(sdToken), \"Sender must be staking derivative token\");\n        uint256 wrappedAmount = getWrappedByUnderlying(_value);\n        _mint(_sender, wrappedAmount);\n    }\n\n    /**\n     * @notice unwraps tokens\n     * @param _amount amount of wrapped tokens to unwrap\n     */\n    function unwrap(uint _amount) external {\n        require(_amount > 0, \"Amount must be > 0\");\n        uint256 unwrappedAmount = getUnderlyingByWrapped(_amount);\n        _burn(msg.sender, _amount);\n        sdToken.transfer(msg.sender, unwrappedAmount);\n    }\n\n    /**\n     * @notice Returns amount of wrapped tokens for an amount of unwrapped tokens\n     * @param _amount amount of unwrapped tokens\n     * @return amount of wrapped tokens\n     */\n    function getWrappedByUnderlying(uint _amount) public view returns (uint) {\n        return _amount / multiplier;\n    }\n\n    /**\n     * @notice Returns amount of unwrapped tokens for an amount of wrapped tokens\n     * @param _amount amount of wrapped tokens\n     * @return amount of unwrapped tokens\n     */\n    function getUnderlyingByWrapped(uint _amount) public view returns (uint) {\n        return _amount * multiplier;\n    }\n\n    function setMultiplier(uint _multiplier) external {\n        multiplier = _multiplier;\n    }\n}\n"
    },
    "contracts/core/DelegatorPool.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./base/RewardsPoolController.sol\";\nimport \"./interfaces/IPoolRouter.sol\";\nimport \"./interfaces/IFeeCurve.sol\";\n\n/**\n * @title Delegator Pool\n * @notice Allows users to stake allowance tokens, stakers receive a percentage of earned rewards\n */\ncontract DelegatorPool is RewardsPoolController {\n    using SafeERC20 for IERC20;\n\n    struct VestingSchedule {\n        uint totalAmount;\n        uint64 startTimestamp;\n        uint64 durationSeconds;\n    }\n\n    IERC20 public immutable allowanceToken;\n    IPoolRouter public immutable poolRouter;\n    IFeeCurve public feeCurve;\n\n    mapping(address => VestingSchedule) private vestingSchedules;\n\n    event AllowanceStaked(address indexed user, uint amount);\n    event AllowanceWithdrawn(address indexed user, uint amount);\n\n    constructor(\n        address _allowanceToken,\n        string memory _dTokenName,\n        string memory _dTokenSymbol,\n        address _poolRouter,\n        address _feeCurve\n    ) RewardsPoolController(_dTokenName, _dTokenSymbol) {\n        allowanceToken = IERC20(_allowanceToken);\n        poolRouter = IPoolRouter(_poolRouter);\n        feeCurve = IFeeCurve(_feeCurve);\n    }\n\n    /**\n     * @notice ERC677 implementation to stake allowance or distribute rewards\n     * @param _sender of the stake\n     * @param _value of the token transfer\n     **/\n    function onTokenTransfer(\n        address _sender,\n        uint _value,\n        bytes calldata _calldata\n    ) external override {\n        require(\n            msg.sender == address(allowanceToken) || isTokenSupported(msg.sender),\n            \"Sender must be allowance or rewards token\"\n        );\n\n        if (msg.sender == address(allowanceToken)) {\n            _stakeAllowance(_sender, _value);\n\n            if (_calldata.length > 1) {\n                (uint64 startTimestamp, uint64 durationSeconds) = abi.decode(_calldata, (uint64, uint64));\n                _setVestingSchedule(_sender, _value, startTimestamp, durationSeconds);\n            }\n        } else {\n            distributeToken(msg.sender);\n        }\n    }\n\n    /**\n     * @notice returns an accounts balance minus the amount of tokens that are currently vesting\n     * @param _account account\n     * @return balance accounts balance\n     */\n    function balanceOf(address _account) public view virtual override(ERC20, IERC20) returns (uint256) {\n        return super.balanceOf(_account) - (vestingSchedules[_account].totalAmount - _vestedTokens(_account));\n    }\n\n    /**\n     * @notice receipt tokens within the delegator pool cannot be transferred\n     */\n    function _transfer(\n        address,\n        address,\n        uint256\n    ) internal virtual override {\n        revert(\"Token cannot be transferred\");\n    }\n\n    /**\n     * @notice returns an account's staked amount for use by reward pools\n     * controlled by this contract. Overridden as the the staked amount needs to include any vesting tokens.\n     * @dev required by RewardsPoolController\n     * @return account's staked amount\n     */\n    function staked(address _account) external view override returns (uint) {\n        return (rewardRedirects[_account] == address(0) ? super.balanceOf(_account) : 0) + redirectedStakes[_account];\n    }\n\n    /**\n     * @notice returns the current fee rate based on the % of allowance token borrowed\n     * @param _token the token address of the pool\n     * @param _index the pool index\n     * @return current rate\n     **/\n    function currentRate(address _token, uint16 _index) public view returns (uint) {\n        return feeCurve.currentRate(poolRouter.poolUtilisation(_token, _index));\n    }\n\n    /**\n     * @notice returns the current fee rate based on a specified percentage\n     * @dev 1 ether = 100%, 0.5 ether = 50% etc\n     * @param _percentageBorrowed the percentage borrowed for fee calculation\n     * @return current rate\n     **/\n    function currentRateAt(uint _percentageBorrowed) public view returns (uint) {\n        return feeCurve.currentRate(_percentageBorrowed);\n    }\n\n    /**\n     * @notice withdraws lent allowance tokens if there are enough available\n     * @param _amount amount to withdraw\n     **/\n    function withdrawAllowance(uint _amount) external updateRewards(msg.sender) {\n        require(!poolRouter.isReservedMode(), \"Allowance cannot be withdrawn when pools are reserved\");\n        require(balanceOf(msg.sender) >= _amount, \"Withdrawal amount exceeds balance\");\n\n        uint toWithdraw = _amount;\n        if (_amount == type(uint).max) {\n            toWithdraw = balanceOf(msg.sender);\n        }\n\n        VestingSchedule memory vestingSchedule = vestingSchedules[msg.sender];\n        if (\n            vestingSchedule.startTimestamp != 0 &&\n            block.timestamp > vestingSchedule.startTimestamp + vestingSchedule.durationSeconds\n        ) {\n            delete vestingSchedules[msg.sender];\n        }\n\n        _burn(msg.sender, toWithdraw);\n        allowanceToken.safeTransfer(msg.sender, toWithdraw);\n\n        emit AllowanceWithdrawn(msg.sender, toWithdraw);\n    }\n\n    /**\n     * @notice returns the vesting schedule of a given account\n     * @param _account account\n     * @return vestingSchedule account's vesting schedule\n     */\n    function getVestingSchedule(address _account) external view returns (VestingSchedule memory) {\n        return vestingSchedules[_account];\n    }\n\n    /**\n     * @notice sets the fee curve interface\n     * @param _feeCurve interface\n     */\n    function setFeeCurve(address _feeCurve) external onlyOwner {\n        require(_feeCurve != address(0), \"Invalid fee curve address\");\n        feeCurve = IFeeCurve(_feeCurve);\n    }\n\n    /**\n     * @notice stakes allowance tokens\n     * @param _amount amount to stake\n     **/\n    function _stakeAllowance(address _sender, uint _amount) private updateRewards(_sender) {\n        _mint(_sender, _amount);\n        emit AllowanceStaked(_sender, _amount);\n    }\n\n    /**\n     * @notice sets an account's derivative token vesting schedule. If a schedule already exists:\n     * - If the new start timestamp is after the previous schedule, the schedule is overwritten and any remaining vesting tokens go into the new schedule\n     * - Will release any tokens that have vested but not transferred\n     * - If the start timestamp is before the current schedule, the current schedule is used\n     */\n    function _setVestingSchedule(\n        address _account,\n        uint _amount,\n        uint64 _startTimestamp,\n        uint64 _durationSeconds\n    ) internal {\n        require(_startTimestamp > 0, \"Start timestamp cannot be 0\");\n        require(_durationSeconds > 0, \"Seconds duration cannot be 0\");\n\n        VestingSchedule storage vestingSchedule = vestingSchedules[_account];\n        if (_startTimestamp > vestingSchedule.startTimestamp) {\n            if (vestingSchedule.startTimestamp != 0) {\n                vestingSchedule.totalAmount -= _vestedTokens(_account);\n            }\n            vestingSchedule.startTimestamp = _startTimestamp;\n            vestingSchedule.durationSeconds = _durationSeconds;\n        }\n        vestingSchedule.totalAmount += _amount;\n    }\n\n    /**\n     * @notice Returns the amount of tokens that are currently vested for an account\n     */\n    function _vestedTokens(address _account) internal view virtual returns (uint256) {\n        VestingSchedule memory vestingSchedule = vestingSchedules[_account];\n        uint totalAmount = vestingSchedule.totalAmount;\n        uint64 startTimestamp = vestingSchedule.startTimestamp;\n        uint64 timestamp = uint64(block.timestamp);\n\n        if (totalAmount == 0 || timestamp < startTimestamp) {\n            return 0;\n        } else if (timestamp > startTimestamp + vestingSchedule.durationSeconds) {\n            return totalAmount;\n        } else {\n            return ((totalAmount * (timestamp - startTimestamp)) / vestingSchedule.durationSeconds);\n        }\n    }\n}\n"
    },
    "contracts/core/interfaces/IPoolRouter.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\ninterface IPoolRouter {\n    function isReservedMode() external view returns (bool);\n\n    function getReservedMultiplier() external view returns (uint);\n\n    function poolUtilisation(address _token, uint16 _index) external view returns (uint);\n}\n"
    },
    "contracts/core/interfaces/IFeeCurve.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\ninterface IFeeCurve {\n    function currentRate(uint _percentageBorrowed) external view returns (uint);\n}\n"
    },
    "contracts/core/tokens/LPLMigration.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title LPL Migration\n * @dev Migrates LPL tokens to SDL\n */\ncontract LPLMigration {\n    using SafeERC20 for IERC20;\n\n    uint public constant MIGRATION_RATIO = 2;\n\n    address public lplToken;\n    address public sdlToken;\n\n    event LPLMigrated(address indexed sender, uint256 amount);\n\n    constructor(address _lplToken, address _sdlToken) {\n        lplToken = _lplToken;\n        sdlToken = _sdlToken;\n    }\n\n    /**\n     * @dev swaps LPL tokens for SDL tokens\n     * @param _sender address that is migrating\n     * @param _value amount to migrate\n     **/\n    function onTokenTransfer(\n        address _sender,\n        uint256 _value,\n        bytes memory\n    ) public {\n        require(msg.sender == lplToken, \"Sender must be LPL token\");\n        IERC20(sdlToken).safeTransfer(_sender, _value / MIGRATION_RATIO);\n        emit LPLMigrated(_sender, _value);\n    }\n}\n"
    },
    "contracts/ethStaking/DepositController.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./interfaces/IDepositContract.sol\";\nimport \"./interfaces/IEthStakingStrategy.sol\";\nimport \"./interfaces/INWLOperatorController.sol\";\nimport \"./interfaces/IWLOperatorController.sol\";\n\n/**\n * @title Deposit Controller\n * @notice Initiates ETH deposits and handles pre-deposit security checks\n */\ncontract DepositController is Ownable {\n    uint public constant PUBKEY_LENGTH = 48;\n\n    IDepositContract public depositContract;\n    IEthStakingStrategy public ethStakingStrategy;\n    INWLOperatorController public nwlOperatorController;\n    IWLOperatorController public wlOperatorController;\n\n    constructor(\n        address _depositContract,\n        address _ethStakingStrategy,\n        address _nwlOperatorController,\n        address _wlOperatorController\n    ) {\n        depositContract = IDepositContract(_depositContract);\n        ethStakingStrategy = IEthStakingStrategy(_ethStakingStrategy);\n        nwlOperatorController = INWLOperatorController(_nwlOperatorController);\n        wlOperatorController = IWLOperatorController(_wlOperatorController);\n    }\n\n    /**\n     * @notice initiates ether deposit\n     * @dev params should be passed along from getNextValidators\n     * @param _depositRoot deposit contract deposit root at time of key verification\n     * @param _nwlStateHash current state hash of nwl operator controller at time of key verification\n     * @param _wlStateHash current state hash of wl operator controller at time of key verification\n     * @param _nwlTotalValidatorCount sum of all validators to assign non-whitelisted operators\n     * @param _wlTotalValidatorCount sum of all validators to assign whitelisted operators\n     * @param _wlOperatorIds ids of whitelisted operators that should be assigned validators\n     * @param _wlValidatorCounts number of validators to assign each whitelisted operator\n     */\n    function depositEther(\n        bytes32 _depositRoot,\n        bytes32 _nwlStateHash,\n        bytes32 _wlStateHash,\n        uint _nwlTotalValidatorCount,\n        uint _wlTotalValidatorCount,\n        uint[] calldata _wlOperatorIds,\n        uint[] calldata _wlValidatorCounts\n    ) external onlyOwner {\n        bytes32 depositRoot = depositContract.get_deposit_root();\n        bytes32 nwlStateHash = nwlOperatorController.currentStateHash();\n        bytes32 wlStateHash = wlOperatorController.currentStateHash();\n\n        require(_depositRoot == depositRoot, \"depositRoot has changed\");\n        require(_nwlStateHash == nwlStateHash, \"nwlStateHash has changed\");\n        require(_wlStateHash == wlStateHash, \"wlStateHash has changed\");\n\n        ethStakingStrategy.depositEther(_nwlTotalValidatorCount, _wlTotalValidatorCount, _wlOperatorIds, _wlValidatorCounts);\n    }\n\n    /**\n     * @notice returns next set of validators and current state of contracts\n     * @dev returned keys should be verified off-chain, then depositEther should be called\n     * @param _totalValidatorCount total number of validators to assign\n     * @return depositRoot deposit contract deposit root\n     * @return nwlStateHash current state hash of nwl operator controller\n     * @return wlStateHash current state hash of wl operator controller\n     * @return nwlTotalValidatorCount sum of all validators to assign non-whitelisted operators\n     * @return wlTotalValidatorCount sum of all validators to assign whitelisted operators\n     * @return wlOperatorIds ids of whitelisted operators that should be assigned validators\n     * @return wlValidatorCounts number of validators to assign each whitelisted operator\n     * @return nwlKeys nwl validator keys to be assigned\n     * @return wlKeys wl validator keys to be assigned\n     */\n    function getNextValidators(uint _totalValidatorCount)\n        external\n        view\n        returns (\n            bytes32 depositRoot,\n            bytes32 nwlStateHash,\n            bytes32 wlStateHash,\n            uint nwlTotalValidatorCount,\n            uint wlTotalValidatorCount,\n            uint[] memory wlOperatorIds,\n            uint[] memory wlValidatorCounts,\n            bytes memory nwlKeys,\n            bytes memory wlKeys\n        )\n    {\n        uint nwlQueueLength = nwlOperatorController.queueLength();\n        uint wlQueueLength = wlOperatorController.queueLength();\n\n        require(_totalValidatorCount <= nwlQueueLength + wlQueueLength, \"not enough validators in queue\");\n\n        depositRoot = depositContract.get_deposit_root();\n        nwlStateHash = nwlOperatorController.currentStateHash();\n        wlStateHash = wlOperatorController.currentStateHash();\n\n        nwlTotalValidatorCount = nwlQueueLength >= _totalValidatorCount ? _totalValidatorCount : nwlQueueLength;\n        if (nwlTotalValidatorCount > 0) {\n            nwlKeys = nwlOperatorController.getNextValidators(nwlTotalValidatorCount);\n        }\n\n        if (nwlTotalValidatorCount < _totalValidatorCount) {\n            (wlOperatorIds, wlValidatorCounts, wlTotalValidatorCount, wlKeys) = wlOperatorController.getNextValidators(\n                _totalValidatorCount - nwlTotalValidatorCount\n            );\n        }\n    }\n}\n"
    },
    "contracts/ethStaking/interfaces/IEthStakingStrategy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\ninterface IEthStakingStrategy {\n    function nwlWithdraw(address _receiver, uint _amount) external;\n\n    function depositEther(\n        uint _nwlTotalValidatorCount,\n        uint _wlTotalValidatorCount,\n        uint[] calldata _wlOperatorIds,\n        uint[] calldata _wlValidatorCounts\n    ) external;\n}\n"
    },
    "contracts/ethStaking/test/EthStakingStrategyMock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"../interfaces/INWLOperatorController.sol\";\n\ncontract EthStakingStrategyMock {\n    address public nwlOperatorController;\n\n    receive() external payable {}\n\n    function depositEther(uint _totalValidatorCount) external {\n        INWLOperatorController(nwlOperatorController).assignNextValidators(_totalValidatorCount);\n    }\n\n    function nwlWithdraw(address _receiver, uint _amount) external {\n        require(msg.sender == address(nwlOperatorController), \"Sender is not non-whitelisted operator controller\");\n    }\n\n    function setNWLOperatorController(address _nwlOperatorController) external {\n        nwlOperatorController = _nwlOperatorController;\n    }\n}\n"
    },
    "contracts/ethStaking/NWLOperatorController.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"./base/OperatorController.sol\";\nimport \"./interfaces/IOperatorWhitelist.sol\";\nimport \"./interfaces/IEthStakingStrategy.sol\";\n\n/**\n * @title Non-Whitelist Operator Controller\n * @notice Handles non-whitelisted validator keys, operator stakes, and operator rewards distribution\n */\ncontract NWLOperatorController is OperatorController {\n    uint public constant DEPOSIT_AMOUNT = 16 ether;\n\n    struct QueueEntry {\n        uint operatorId;\n        uint numKeyPairs;\n    }\n\n    QueueEntry[] private queue;\n    uint public queueIndex;\n\n    mapping(uint => uint) public ethLost;\n    mapping(uint => uint) public ethWithdrawn;\n\n    event RemoveKeyPairs(uint indexed operatorId, uint quantity);\n    event ReportKeyPairValidation(uint indexed operatorId, bool success);\n    event ReportStoppedValidators(uint indexed operatorId, uint totalStoppedValidators, uint totalEthLost);\n    event WithdrawStake(uint indexed _operatorId, uint amount);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address _ethStakingStrategy, address _wsdToken) public initializer {\n        __OperatorController_init(_ethStakingStrategy, _wsdToken);\n    }\n\n    /**\n     * @notice Returns a list of queue entries\n     * @param _startIndex start index of entries to return\n     * @param _numEntries number of entries to return\n     * @return entries list of queue entries\n     */\n    function getQueueEntries(uint _startIndex, uint _numEntries) external view returns (QueueEntry[] memory entries) {\n        require(_startIndex < queue.length, \"startIndex out of range\");\n\n        uint endIndex = _startIndex + _numEntries;\n        if (endIndex > queue.length) {\n            endIndex = queue.length;\n        }\n\n        entries = new QueueEntry[](endIndex - _startIndex);\n        for (uint i = _startIndex; i < endIndex; i++) {\n            entries[i] = queue[i];\n        }\n    }\n\n    /**\n     * @notice Returns the total active stake across all validators\n     * @return totalActiveStake total active stake\n     */\n    function totalActiveStake() external view returns (uint) {\n        return totalActiveValidators * DEPOSIT_AMOUNT;\n    }\n\n    /**\n     * @notice Adds a new operator\n     * @param _name name of operator\n     */\n    function addOperator(string calldata _name) external {\n        _addOperator(_name);\n    }\n\n    /**\n     * @notice Adds a set of new validator pubkey/signature pairs for an operator\n     * @param _operatorId id of operator\n     * @param _quantity number of new pairs to add\n     * @param _pubkeys concatenated set of pubkeys to add\n     * @param _signatures concatenated set of signatures to add\n     */\n    function addKeyPairs(\n        uint _operatorId,\n        uint _quantity,\n        bytes calldata _pubkeys,\n        bytes calldata _signatures\n    ) external payable operatorExists(_operatorId) {\n        require(msg.sender == operators[_operatorId].owner, \"Sender is not operator owner\");\n        require(msg.value == _quantity * DEPOSIT_AMOUNT, \"Incorrect stake amount\");\n        _addKeyPairs(_operatorId, _quantity, _pubkeys, _signatures);\n    }\n\n    /**\n     * @notice Removes added pubkey/signature pairs from an operator in LIFO order\n     * @param _operatorId id of operator\n     * @param _quantity number of pairs to remove\n     * @param _queueEntryIndexes indexes of this operator's queue entries to remove\n     */\n    function removeKeyPairs(\n        uint _operatorId,\n        uint _quantity,\n        uint[] calldata _queueEntryIndexes\n    ) external operatorExists(_operatorId) {\n        require(msg.sender == operators[_operatorId].owner, \"Sender is not operator owner\");\n        require(_quantity > 0, \"Quantity must be greater than 0\");\n        require(\n            _quantity <= operators[_operatorId].totalKeyPairs - operators[_operatorId].usedKeyPairs,\n            \"Cannot remove used key pairs or more keys than are added\"\n        );\n\n        uint toRemove = _quantity;\n        uint unverifiedKeys = operators[_operatorId].totalKeyPairs - operators[_operatorId].validatorLimit;\n\n        if (unverifiedKeys < toRemove) {\n            toRemove -= unverifiedKeys;\n            queueLength -= toRemove;\n            for (uint i = 0; i < _queueEntryIndexes.length; i++) {\n                require(_queueEntryIndexes[i] >= queueIndex, \"Cannot remove from queue entry that is already passed by\");\n                require(_queueEntryIndexes[i] < queue.length, \"Cannot remove from queue entry that does not exist\");\n\n                QueueEntry memory entry = queue[_queueEntryIndexes[i]];\n                require(entry.operatorId == _operatorId, \"Sender is not operator owner of queue entry\");\n\n                if (entry.numKeyPairs < toRemove) {\n                    queue[_queueEntryIndexes[i]].numKeyPairs = 0;\n                    toRemove -= entry.numKeyPairs;\n                } else {\n                    queue[_queueEntryIndexes[i]].numKeyPairs -= toRemove;\n                    break;\n                }\n            }\n        }\n\n        operators[_operatorId].totalKeyPairs -= uint64(_quantity);\n        if (operators[_operatorId].validatorLimit > operators[_operatorId].totalKeyPairs) {\n            operators[_operatorId].validatorLimit = operators[_operatorId].totalKeyPairs;\n        }\n\n        currentStateHash = keccak256(\n            abi.encodePacked(currentStateHash, \"removeKeyPairs\", _operatorId, _quantity, _queueEntryIndexes)\n        );\n\n        (bool success, ) = payable(msg.sender).call{value: _quantity * DEPOSIT_AMOUNT}(\"\");\n        require(success, \"ETH transfer failed\");\n\n        emit RemoveKeyPairs(_operatorId, _quantity);\n    }\n\n    /**\n     * @notice Reports the results of key pair validation for an operator\n     * @param _operatorId id of operator\n     * @param _success whether the pairs are valid\n     */\n    function reportKeyPairValidation(uint _operatorId, bool _success)\n        external\n        onlyKeyValidationOracle\n        operatorExists(_operatorId)\n    {\n        require(operators[_operatorId].keyValidationInProgress, \"No key validation in progress\");\n\n        if (_success && operators[_operatorId].active) {\n            uint newKeyPairs = operators[_operatorId].totalKeyPairs - operators[_operatorId].validatorLimit;\n            queue.push(QueueEntry(_operatorId, newKeyPairs));\n            queueLength += newKeyPairs;\n            operators[_operatorId].validatorLimit = operators[_operatorId].totalKeyPairs;\n            currentStateHash = keccak256(abi.encodePacked(currentStateHash, \"reportKeyPairValidation\", _operatorId));\n        }\n        operators[_operatorId].keyValidationInProgress = false;\n\n        emit ReportKeyPairValidation(_operatorId, _success);\n    }\n\n    /**\n     * @notice Assigns the next set of validators in the queue\n     * @param _totalValidatorCount total number of validators to assign\n     * @return keys concatenated list of pubkeys\n     * @return signatures concatenated list of signatures\n     */\n    function assignNextValidators(uint _totalValidatorCount)\n        external\n        onlyEthStakingStrategy\n        returns (bytes memory keys, bytes memory signatures)\n    {\n        require(_totalValidatorCount > 0, \"Validator count must be greater than 0\");\n        require(_totalValidatorCount <= queueLength, \"Cannot assign more than queue length\");\n\n        bytes32 stateHash = currentStateHash;\n        uint toAssign = _totalValidatorCount;\n        uint index = queueIndex;\n\n        while (index < queue.length) {\n            uint numKeyPairs = queue[index].numKeyPairs;\n            uint operatorId = queue[index].operatorId;\n\n            if (numKeyPairs > 0 && operators[operatorId].active) {\n                uint assignToOperator;\n\n                if (numKeyPairs < toAssign) {\n                    assignToOperator = numKeyPairs;\n                    toAssign -= numKeyPairs;\n                } else {\n                    assignToOperator = toAssign;\n                    if (numKeyPairs == toAssign) {\n                        index++;\n                    } else {\n                        queue[index].numKeyPairs -= toAssign;\n                    }\n                    toAssign = 0;\n                }\n\n                rewardsPool.updateReward(operators[operatorId].owner);\n\n                operators[operatorId].usedKeyPairs += uint64(assignToOperator);\n                activeValidators[operators[operatorId].owner] += assignToOperator;\n\n                uint usedKeyPairs = operators[operatorId].usedKeyPairs;\n\n                for (uint j = usedKeyPairs - assignToOperator; j < usedKeyPairs; j++) {\n                    (bytes memory key, bytes memory signature) = _loadKeyPair(operatorId, j);\n                    keys = bytes.concat(keys, key);\n                    signatures = bytes.concat(signatures, signature);\n                    stateHash = keccak256(abi.encodePacked(stateHash, \"assignKey\", operatorId, key));\n                }\n\n                if (toAssign == 0) {\n                    break;\n                }\n            }\n            index++;\n        }\n\n        (bool success, ) = payable(ethStakingStrategy).call{value: _totalValidatorCount * DEPOSIT_AMOUNT}(\"\");\n        require(success, \"ETH transfer failed\");\n\n        currentStateHash = stateHash;\n        totalAssignedValidators += _totalValidatorCount;\n        totalActiveValidators += _totalValidatorCount;\n        queueLength -= _totalValidatorCount;\n        queueIndex = index;\n    }\n\n    /**\n     * @notice Returns the next set of validator keys to be assigned\n     * @param _validatorCount total number of validators to assign\n     * @return keys validator keys to be assigned\n     */\n    function getNextValidators(uint _validatorCount) external view returns (bytes memory keys) {\n        require(_validatorCount > 0, \"Validator count must be greater than 0\");\n        require(_validatorCount <= queueLength, \"Cannot assign more than queue length\");\n\n        uint[] memory assignedToOperators = new uint[](operators.length);\n        uint toAssign = _validatorCount;\n        uint index = queueIndex;\n\n        while (index < queue.length) {\n            uint numKeyPairs = queue[index].numKeyPairs;\n            uint operatorId = queue[index].operatorId;\n\n            if (numKeyPairs > 0 && operators[operatorId].active) {\n                uint assignToOperator;\n\n                if (numKeyPairs < toAssign) {\n                    assignToOperator = numKeyPairs;\n                    toAssign -= numKeyPairs;\n                } else {\n                    assignToOperator = toAssign;\n                    toAssign = 0;\n                }\n\n                uint usedKeyPairs = operators[operatorId].usedKeyPairs + assignedToOperators[operatorId];\n                assignedToOperators[operatorId] += assignToOperator;\n\n                for (uint j = usedKeyPairs; j < usedKeyPairs + assignToOperator; j++) {\n                    (bytes memory key, ) = _loadKeyPair(operatorId, j);\n                    keys = bytes.concat(keys, key);\n                }\n\n                if (toAssign == 0) {\n                    break;\n                }\n            }\n            index++;\n        }\n    }\n\n    /**\n     * @notice Reports lifetime stopped validators and ETH lost for a list of operators\n     * @param _operatorIds list of operator ids to report for\n     * @param _stoppedValidators list of lifetime stopped validators for each operator\n     * @param _ethLost list of lifetime lost ETH sum for each operator\n     */\n    function reportStoppedValidators(\n        uint[] calldata _operatorIds,\n        uint[] calldata _stoppedValidators,\n        uint[] calldata _ethLost\n    ) external onlyBeaconOracle {\n        require(\n            _operatorIds.length == _stoppedValidators.length && _operatorIds.length == _ethLost.length,\n            \"Inconsistent list lengths\"\n        );\n\n        uint totalNewlyStoppedValidators;\n        uint totalNewlyLostETH;\n\n        for (uint i = 0; i < _operatorIds.length; i++) {\n            uint operatorId = _operatorIds[i];\n            require(operatorId < operators.length, \"Operator does not exist\");\n            require(\n                _stoppedValidators[i] > operators[operatorId].stoppedValidators,\n                \"Reported negative or zero stopped validators\"\n            );\n            require(_ethLost[i] >= ethLost[operatorId], \"Reported negative lost ETH\");\n            require(\n                _stoppedValidators[i] <= operators[operatorId].usedKeyPairs,\n                \"Reported more stopped validators than active\"\n            );\n\n            rewardsPool.updateReward(operators[operatorId].owner);\n\n            uint newlyStoppedValidators = _stoppedValidators[i] - operators[operatorId].stoppedValidators;\n            uint newlyLostETH = _ethLost[i] - ethLost[operatorId];\n\n            require(\n                newlyLostETH <= newlyStoppedValidators * DEPOSIT_AMOUNT,\n                \"Reported more than max loss of 16 ETH per validator\"\n            );\n\n            operators[operatorId].stoppedValidators += uint64(newlyStoppedValidators);\n            ethLost[operatorId] += newlyLostETH;\n            totalNewlyLostETH += newlyLostETH;\n\n            if (operators[operatorId].active) {\n                activeValidators[operators[operatorId].owner] -= newlyStoppedValidators;\n                totalNewlyStoppedValidators += newlyStoppedValidators;\n            }\n\n            emit ReportStoppedValidators(operatorId, _stoppedValidators[i], _ethLost[i]);\n        }\n\n        totalActiveValidators -= totalNewlyStoppedValidators;\n    }\n\n    /**\n     * @notice Withdraws an operator's stake\n     * @param _operatorId id of operator\n     * @param _amount amount to withdraw\n     */\n    function withdrawStake(uint _operatorId, uint _amount) external operatorExists(_operatorId) {\n        require(msg.sender == operators[_operatorId].owner, \"Sender is not operator owner\");\n        require(_amount <= withdrawableStake(_operatorId), \"Cannot withdraw more than available\");\n\n        ethWithdrawn[_operatorId] += _amount;\n        IEthStakingStrategy(ethStakingStrategy).nwlWithdraw(msg.sender, _amount);\n\n        emit WithdrawStake(_operatorId, _amount);\n    }\n\n    /**\n     * @notice Returns the total withdrawable stake for an operator\n     * @param _operatorId id of operator\n     * @return withdrawableStake total withdrawable stake\n     */\n    function withdrawableStake(uint _operatorId) public view returns (uint) {\n        return\n            operators[_operatorId].stoppedValidators * DEPOSIT_AMOUNT - (ethLost[_operatorId] + ethWithdrawn[_operatorId]);\n    }\n}\n"
    },
    "contracts/ethStaking/interfaces/IOperatorWhitelist.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\ninterface IOperatorWhitelist {\n    function useWhitelist(address _ownerAddress) external;\n}\n"
    },
    "contracts/ethStaking/WLOperatorController.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"./base/OperatorController.sol\";\nimport \"./interfaces/IOperatorWhitelist.sol\";\n\n/**\n * @title Whitelist Operator Controller\n * @notice Handles whitelisted validator keys and operator rewards distribution\n */\ncontract WLOperatorController is OperatorController {\n    struct OperatorCache {\n        uint id;\n        uint usedKeyPairs;\n        uint validatorLimit;\n        uint validatorCount;\n    }\n\n    IOperatorWhitelist public operatorWhitelist;\n\n    uint public batchSize;\n    uint public assignmentIndex;\n\n    event RemoveKeyPairs(uint indexed operatorId, uint quantity);\n    event ReportKeyPairValidation(uint indexed operatorId, bool success);\n    event ReportStoppedValidators(uint indexed operatorId, uint totalStoppedValidators);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address _ethStakingStrategy,\n        address _wsdToken,\n        address _operatorWhitelist,\n        uint _batchSize\n    ) public initializer {\n        __OperatorController_init(_ethStakingStrategy, _wsdToken);\n        operatorWhitelist = IOperatorWhitelist(_operatorWhitelist);\n        batchSize = _batchSize;\n    }\n\n    /**\n     * @notice Adds a new operator\n     * @param _name name of operator\n     */\n    function addOperator(string calldata _name) external {\n        operatorWhitelist.useWhitelist(msg.sender);\n        _addOperator(_name);\n    }\n\n    /**\n     * @notice Adds a set of new validator pubkey/signature pairs for an operator\n     * @param _operatorId id of operator\n     * @param _quantity number of new pairs to add\n     * @param _pubkeys concatenated set of pubkeys to add\n     * @param _signatures concatenated set of signatures to add\n     */\n    function addKeyPairs(\n        uint _operatorId,\n        uint _quantity,\n        bytes calldata _pubkeys,\n        bytes calldata _signatures\n    ) external operatorExists(_operatorId) {\n        require(msg.sender == operators[_operatorId].owner, \"Sender is not operator owner\");\n        _addKeyPairs(_operatorId, _quantity, _pubkeys, _signatures);\n    }\n\n    /**\n     * @notice Removes added pubkey/signature pairs from an operator in LIFO order\n     * @param _operatorId id of operator\n     * @param _quantity number of pairs to remove\n     */\n    function removeKeyPairs(uint _operatorId, uint _quantity) external operatorExists(_operatorId) {\n        require(msg.sender == operators[_operatorId].owner, \"Sender is not operator owner\");\n        require(_quantity > 0, \"Quantity must be greater than 0\");\n        require(_quantity <= operators[_operatorId].totalKeyPairs, \"Cannot remove more keys than are added\");\n        require(\n            _quantity <= operators[_operatorId].totalKeyPairs - operators[_operatorId].usedKeyPairs,\n            \"Cannot remove used key pairs\"\n        );\n\n        operators[_operatorId].totalKeyPairs -= uint64(_quantity);\n        if (operators[_operatorId].validatorLimit > operators[_operatorId].totalKeyPairs) {\n            queueLength -= operators[_operatorId].validatorLimit - operators[_operatorId].totalKeyPairs;\n            operators[_operatorId].validatorLimit = operators[_operatorId].totalKeyPairs;\n        }\n\n        currentStateHash = keccak256(abi.encodePacked(currentStateHash, \"removeKeyPairs\", _operatorId, _quantity));\n\n        emit RemoveKeyPairs(_operatorId, _quantity);\n    }\n\n    /**\n     * @notice Reports the results of key pair validation for an operator\n     * @param _operatorId id of operator\n     * @param _success whether the pairs are valid\n     */\n    function reportKeyPairValidation(uint _operatorId, bool _success)\n        external\n        onlyKeyValidationOracle\n        operatorExists(_operatorId)\n    {\n        require(operators[_operatorId].keyValidationInProgress, \"No key validation in progress\");\n\n        if (_success && operators[_operatorId].active) {\n            queueLength += operators[_operatorId].totalKeyPairs - operators[_operatorId].validatorLimit;\n            operators[_operatorId].validatorLimit = operators[_operatorId].totalKeyPairs;\n            currentStateHash = keccak256(abi.encodePacked(currentStateHash, \"reportKeyPairValidation\", _operatorId));\n        }\n        operators[_operatorId].keyValidationInProgress = false;\n\n        emit ReportKeyPairValidation(_operatorId, _success);\n    }\n\n    /**\n     * @notice Assigns the next set of validators in the queue\n     * @param _operatorIds ids of operators that should be assigned validators\n     * @param _validatorCounts number of validators to assign each operator\n     * @param _totalValidatorCount sum of all entries in _validatorCounts\n     * @return keys concatenated list of pubkeys\n     * @return signatures concatenated list of signatures\n     */\n    function assignNextValidators(\n        uint[] calldata _operatorIds,\n        uint[] calldata _validatorCounts,\n        uint _totalValidatorCount\n    ) external onlyEthStakingStrategy returns (bytes memory keys, bytes memory signatures) {\n        require(_operatorIds.length > 0, \"Empty operatorIds\");\n        require(_operatorIds.length == _validatorCounts.length, \"Inconsistent operatorIds and validatorCounts length\");\n\n        OperatorCache memory lastOperator = OperatorCache(\n            assignmentIndex == 0 ? operators.length - 1 : assignmentIndex - 1,\n            0,\n            0,\n            0\n        );\n\n        bool[] memory seenOperatorIds = new bool[](operators.length);\n        uint totalValidatorCount;\n        uint maxBatches;\n        uint maxBatchOperatorId;\n        bytes32 stateHash = currentStateHash;\n\n        for (uint i = 0; i < _operatorIds.length; i++) {\n            uint operatorId = _operatorIds[i];\n\n            require(operators[operatorId].active, \"Inactive operator\");\n            require(!seenOperatorIds[operatorId], \"Duplicate operator\");\n            seenOperatorIds[operatorId] = true;\n\n            rewardsPool.updateReward(operators[operatorId].owner);\n\n            operators[operatorId].usedKeyPairs += uint64(_validatorCounts[i]);\n            activeValidators[operators[operatorId].owner] += _validatorCounts[i];\n\n            OperatorCache memory operator = OperatorCache(\n                operatorId,\n                operators[operatorId].usedKeyPairs,\n                operators[operatorId].validatorLimit,\n                _validatorCounts[i]\n            );\n\n            require(\n                totalValidatorCount + operator.validatorCount <= _totalValidatorCount,\n                \"Inconsistent total validator count\"\n            );\n\n            for (uint j = operator.usedKeyPairs - operator.validatorCount; j < operator.usedKeyPairs; j++) {\n                (bytes memory key, bytes memory signature) = _loadKeyPair(operatorId, j);\n                keys = bytes.concat(keys, key);\n                signatures = bytes.concat(signatures, signature);\n                stateHash = keccak256(abi.encodePacked(stateHash, \"assignKey\", operatorId, key));\n                totalValidatorCount++;\n            }\n\n            require(operator.usedKeyPairs <= operator.validatorLimit, \"Assigned more keys than validator limit\");\n            require(\n                (operator.validatorCount % batchSize == 0) || (operator.usedKeyPairs == operator.validatorLimit),\n                \"Invalid batching\"\n            );\n\n            // All excluded operators between any 2 successive included operators must be at capacity\n            if (operatorId > (lastOperator.id + 1)) {\n                for (uint j = lastOperator.id + 1; j < operatorId; j++) {\n                    require(\n                        operators[j].usedKeyPairs == operators[j].validatorLimit,\n                        \"1: Validator assignments were skipped\"\n                    );\n                }\n            } else if (operatorId < (lastOperator.id + 1)) {\n                for (uint j = lastOperator.id + 1; j < operators.length; j++) {\n                    require(\n                        operators[j].usedKeyPairs == operators[j].validatorLimit,\n                        \"2: Validator assignments were skipped\"\n                    );\n                }\n                for (uint j = 0; j < operatorId; j++) {\n                    require(\n                        operators[j].usedKeyPairs == operators[j].validatorLimit,\n                        \"3: Validator assignments were skipped\"\n                    );\n                }\n            }\n\n            if (operator.validatorCount > lastOperator.validatorCount) {\n                // An operator cannot be assigned more validators than the operator before unless the operator before is at capacity\n                require(\n                    lastOperator.usedKeyPairs == lastOperator.validatorLimit,\n                    \"1: Validator assignments incorrectly split\"\n                );\n            } else if (operator.validatorCount < lastOperator.validatorCount) {\n                // An operator cannot be assigned greater than a single batch more than the operator after unless the operator\n                // after is at capacity\n                require(\n                    ((lastOperator.validatorCount - operator.validatorCount) <= batchSize) ||\n                        (operator.usedKeyPairs == operator.validatorLimit),\n                    \"2: Validator assignments incorrectly split\"\n                );\n            }\n\n            uint batches = operator.validatorCount / batchSize + (operator.validatorCount % batchSize > 0 ? 1 : 0);\n            if (batches >= maxBatches) {\n                maxBatches = batches;\n                maxBatchOperatorId = operatorId;\n            }\n\n            lastOperator = operator;\n        }\n\n        require(totalValidatorCount == _totalValidatorCount, \"Inconsistent total validator count\");\n\n        // If any operator received more than 1 batch, a full loop has occurred - we need to check that every operator\n        // between the last one in _operatorIds and assignmentIndex is at capacity\n        if (maxBatches > 1) {\n            if (lastOperator.id < assignmentIndex) {\n                for (uint i = lastOperator.id + 1; i < assignmentIndex; i++) {\n                    require(\n                        operators[i].usedKeyPairs == operators[i].validatorLimit,\n                        \"4: Validator assignments were skipped\"\n                    );\n                }\n            } else if (lastOperator.id > assignmentIndex) {\n                for (uint i = lastOperator.id + 1; i < operators.length; i++) {\n                    require(\n                        operators[i].usedKeyPairs == operators[i].validatorLimit,\n                        \"5: Validator assignments were skipped\"\n                    );\n                }\n                for (uint i = 0; i < assignmentIndex; i++) {\n                    require(\n                        operators[i].usedKeyPairs == operators[i].validatorLimit,\n                        \"6: Validator assignments were skipped\"\n                    );\n                }\n            }\n        }\n\n        // The next assignmentIndex should be the one right after the operator that received the most batches,\n        // the farthest back in the loop\n        if (maxBatchOperatorId == operators.length - 1) {\n            assignmentIndex = 0;\n        } else {\n            assignmentIndex = maxBatchOperatorId + 1;\n        }\n\n        totalAssignedValidators += totalValidatorCount;\n        totalActiveValidators += totalValidatorCount;\n        queueLength -= totalValidatorCount;\n        currentStateHash = stateHash;\n    }\n\n    /**\n     * @notice Returns the next set of validators to be assigned\n     * @param _validatorCount target number of validators to assign\n     * @return operatorIds ids of operators that should be assigned validators\n     * @return validatorCounts number of validators to assign each operator\n     * @return totalValidatorCount actual number of validators to be assigned\n     * @return keys validator keys to be assigned\n     */\n    function getNextValidators(uint _validatorCount)\n        external\n        view\n        returns (\n            uint[] memory operatorIds,\n            uint[] memory validatorCounts,\n            uint totalValidatorCount,\n            bytes memory keys\n        )\n    {\n        require(_validatorCount > 0, \"Validator count must be greater than 0\");\n        require(_validatorCount <= queueLength, \"Cannot assign more than queue length\");\n\n        uint[] memory validatorCounter = new uint[](operators.length);\n        uint[] memory operatorTracker = new uint[](operators.length);\n        uint operatorCount;\n        uint remainingToAssign = _validatorCount;\n\n        uint loopValidatorCount;\n        uint index = assignmentIndex;\n        uint loopEnd = index == 0 ? operators.length - 1 : index - 1;\n\n        while (true) {\n            uint validatorRoom = operators[index].validatorLimit - (operators[index].usedKeyPairs + validatorCounter[index]);\n\n            if (validatorRoom > 0 && operators[index].active) {\n                if (validatorRoom <= batchSize && validatorRoom <= remainingToAssign) {\n                    if (validatorCounter[index] == 0) {\n                        operatorTracker[operatorCount] = index;\n                        operatorCount++;\n                    }\n                    validatorCounter[index] += validatorRoom;\n                    loopValidatorCount += validatorRoom;\n                    remainingToAssign -= validatorRoom;\n                } else if (batchSize <= remainingToAssign) {\n                    if (validatorCounter[index] == 0) {\n                        operatorTracker[operatorCount] = index;\n                        operatorCount++;\n                    }\n                    validatorCounter[index] += batchSize;\n                    loopValidatorCount += batchSize;\n                    remainingToAssign -= batchSize;\n                } else {\n                    break;\n                }\n            }\n\n            if (index == loopEnd) {\n                if (loopValidatorCount == 0) {\n                    break;\n                } else {\n                    loopValidatorCount = 0;\n                }\n            }\n\n            if (index == operators.length - 1) {\n                index = 0;\n            } else {\n                index++;\n            }\n        }\n\n        totalValidatorCount = _validatorCount - remainingToAssign;\n\n        operatorIds = new uint[](operatorCount);\n        validatorCounts = new uint[](operatorCount);\n\n        for (uint i = 0; i < operatorCount; i++) {\n            operatorIds[i] = operatorTracker[i];\n            validatorCounts[i] = validatorCounter[operatorTracker[i]];\n\n            uint operatorId = operatorIds[i];\n            uint usedKeyPairs = operators[operatorId].usedKeyPairs;\n\n            for (uint j = usedKeyPairs; j < usedKeyPairs + validatorCounts[i]; j++) {\n                (bytes memory key, ) = _loadKeyPair(operatorId, j);\n                keys = bytes.concat(keys, key);\n            }\n        }\n    }\n\n    /**\n     * @notice Reports lifetime stopped validators for a list of operators\n     * @param _operatorIds list of operator ids to report for\n     * @param _stoppedValidators list of lifetime stopped validators for each operator\n     */\n    function reportStoppedValidators(uint[] calldata _operatorIds, uint[] calldata _stoppedValidators)\n        external\n        onlyBeaconOracle\n    {\n        require(_operatorIds.length == _stoppedValidators.length, \"Inconsistent list lengths\");\n\n        uint totalNewlyStoppedValidators;\n\n        for (uint i = 0; i < _operatorIds.length; i++) {\n            uint operatorId = _operatorIds[i];\n            require(operatorId < operators.length, \"Operator does not exist\");\n            require(\n                _stoppedValidators[i] > operators[operatorId].stoppedValidators,\n                \"Reported negative or zero stopped validators\"\n            );\n            require(\n                _stoppedValidators[i] <= operators[operatorId].usedKeyPairs,\n                \"Reported more stopped validators than active\"\n            );\n\n            rewardsPool.updateReward(operators[operatorId].owner);\n\n            uint newlyStoppedValidators = _stoppedValidators[i] - operators[operatorId].stoppedValidators;\n\n            operators[operatorId].stoppedValidators += uint64(newlyStoppedValidators);\n\n            if (operators[operatorId].active) {\n                activeValidators[operators[operatorId].owner] -= newlyStoppedValidators;\n                totalNewlyStoppedValidators += newlyStoppedValidators;\n            }\n\n            emit ReportStoppedValidators(operatorId, _stoppedValidators[i]);\n        }\n\n        totalActiveValidators -= totalNewlyStoppedValidators;\n    }\n\n    /**\n     * @notice Sets the batch size for validator assignment\n     * @param _batchSize new batch size\n     */\n    function setBatchSize(uint _batchSize) external onlyOwner {\n        batchSize = _batchSize;\n    }\n\n    /**\n     * @notice Sets the location of the operator whitelist\n     * @param _operatorWhitelist new location of operator whitelist\n     */\n    function setOperatorWhitelist(address _operatorWhitelist) external onlyOwner {\n        operatorWhitelist = IOperatorWhitelist(_operatorWhitelist);\n    }\n}\n"
    },
    "contracts/core/tokens/LinkPoolNFT.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\n/**\n * @title LinkPoolNFT\n * @notice NFT for original crowdsale participants\n */\ncontract LinkPoolNFT is ERC721URIStorage, Ownable {\n    address public lpMigration;\n    string public baseURI;\n    uint public totalSupply;\n\n    constructor(address _lpMigration, string memory _baseUri) ERC721(\"LinkPool OG\", \"LPOG\") {\n        lpMigration = _lpMigration;\n        baseURI = _baseUri;\n    }\n\n    /**\n     * @notice mints new NFT\n     * @param _to address to mint NFT for\n     **/\n    function mint(address _to) external {\n        require(msg.sender == lpMigration, \"LPMigration only\");\n        uint256 tokenId = ++totalSupply;\n        _safeMint(_to, tokenId);\n        _setTokenURI(tokenId, \"/\");\n    }\n\n    /**\n     * @notice sets baseURI for NFTs\n     * @param _baseUri URI to set\n     **/\n    function setBaseURI(string memory _baseUri) external onlyOwner {\n        baseURI = _baseUri;\n    }\n\n    function _baseURI() internal view override returns (string memory) {\n        return baseURI;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/extensions/ERC721URIStorage.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\n\n/**\n * @dev ERC721 token with storage based token URI management.\n */\nabstract contract ERC721URIStorage is ERC721 {\n    using Strings for uint256;\n\n    // Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = _baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n\n        return super.tokenURI(tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721URIStorage: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev See {ERC721-_burn}. This override additionally checks to see if a\n     * token-specific URI was set for the token, and if so, it deletes the token URI from\n     * the storage mapping.\n     */\n    function _burn(uint256 tokenId) internal virtual override {\n        super._burn(tokenId);\n\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n}\n"
    },
    "contracts/ethStaking/RewardsReceiver.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title RewardsReceiver\n * @notice Receives rewards to be distributed to the ETH staking strategy\n */\ncontract RewardsReceiver is Ownable {\n    address payable public immutable ethStakingStrategy;\n    uint public minWithdrawalAmount;\n    uint public maxWithdrawalAmount;\n\n    event RewardsReceived(uint amount);\n    event RewardsWithdrawn(uint amount);\n    event SetWithdrawalLimits(uint min, uint max);\n\n    constructor(\n        address _ethStakingStrategy,\n        uint _minWithdrawalAmount,\n        uint _maxWithdrawalAmount\n    ) {\n        ethStakingStrategy = payable(_ethStakingStrategy);\n        minWithdrawalAmount = _minWithdrawalAmount;\n        maxWithdrawalAmount = _maxWithdrawalAmount;\n    }\n\n    receive() external payable {\n        emit RewardsReceived(msg.value);\n    }\n\n    /**\n     * @notice Withdraws rewards to the ETH staking strategy\n     */\n    function withdraw() external returns (uint) {\n        require(msg.sender == ethStakingStrategy, \"Sender is not ETH staking strategy\");\n\n        uint balance = address(this).balance;\n        uint value;\n\n        if (balance < minWithdrawalAmount) {\n            value = 0;\n        } else if (balance > maxWithdrawalAmount) {\n            value = maxWithdrawalAmount;\n        } else {\n            value = balance;\n        }\n\n        if (value > 0) {\n            (bool success, ) = ethStakingStrategy.call{value: value}(\"\");\n            require(success, \"ETH transfer failed\");\n            emit RewardsWithdrawn(value);\n        }\n\n        return value;\n    }\n\n    /**\n     * @notice Sets the minimum and maximum amount that can be withdrawn per transaction\n     * @param _minWithdrawalAmount minimum amount\n     * @param _maxWithdrawalAmount maximum amount\n     */\n    function setWithdrawalLimits(uint _minWithdrawalAmount, uint _maxWithdrawalAmount) external onlyOwner {\n        require(_minWithdrawalAmount <= _maxWithdrawalAmount, \"min must be less than or equal to max\");\n        minWithdrawalAmount = _minWithdrawalAmount;\n        maxWithdrawalAmount = _maxWithdrawalAmount;\n        emit SetWithdrawalLimits(_minWithdrawalAmount, _maxWithdrawalAmount);\n    }\n}\n"
    },
    "contracts/ethStaking/OperatorWhitelist.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title Operator Whitelist\n * @notice Tracks which accounts are able to add new whitelisted operators\n */\ncontract OperatorWhitelist is Ownable {\n    struct WhitelistEntry {\n        bool isWhitelisted;\n        bool isUsed;\n    }\n\n    address public wlOperatorController;\n    mapping(address => WhitelistEntry) private whitelist;\n\n    constructor(address _wlOperatorController, address[] memory _whitelist) {\n        wlOperatorController = _wlOperatorController;\n\n        for (uint i = 0; i < _whitelist.length; i++) {\n            whitelist[_whitelist[i]] = WhitelistEntry(true, false);\n        }\n    }\n\n    /**\n     * @notice Returns a whitelist entry\n     * @param _account account to return entry for\n     * @return entry whitelist entry\n     */\n    function getWhitelistEntry(address _account) external view returns (WhitelistEntry memory) {\n        return whitelist[_account];\n    }\n\n    /**\n     * @notice Checks whether or not an account is whitelisted and marks the respective whitelist\n     * entry as used\n     * @param _account account to check whitelist for\n     */\n    function useWhitelist(address _account) external {\n        require(msg.sender == wlOperatorController, \"Sender is not wl operator controller\");\n        require(whitelist[_account].isWhitelisted, \"Account is not whitelisted\");\n        require(!whitelist[_account].isUsed, \"Account whitelist spot already used\");\n        whitelist[_account].isUsed = true;\n    }\n\n    /**\n     * @notice Adds a list of whitelist entries\n     * @param _accounts list of accounts to add to whitelist\n     */\n    function addWhitelistEntries(address[] calldata _accounts) external onlyOwner {\n        for (uint i = 0; i < _accounts.length; i++) {\n            address account = _accounts[i];\n            require(!whitelist[account].isWhitelisted, \"Account already whitelisted\");\n            whitelist[account] = WhitelistEntry(true, false);\n        }\n    }\n\n    /**\n     * @notice Removes a list of whitelist entries\n     * @param _accounts list of accounts to remove from whitelist\n     */\n    function removeWhitelistEntries(address[] calldata _accounts) external onlyOwner {\n        for (uint i = 0; i < _accounts.length; i++) {\n            address account = _accounts[i];\n            require(whitelist[account].isWhitelisted, \"Account is not whitelisted\");\n            whitelist[account].isWhitelisted = false;\n        }\n    }\n\n    /**\n     * @notice Sets the whitelisted operator controller\n     * @param _wlOperatorController controller address\n     */\n    function setWLOperatorController(address _wlOperatorController) external onlyOwner {\n        wlOperatorController = _wlOperatorController;\n    }\n}\n"
    },
    "contracts/core/feeCurves/Flat.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title Flat Fee\n * @notice Sets a flat fee\n */\ncontract FlatFee is Ownable {\n    uint public feeBasisPoints;\n\n    event FeeSet(uint _feeBasisPoints);\n\n    constructor(uint _feeBasisPoints) {\n        feeBasisPoints = _feeBasisPoints;\n    }\n\n    /**\n     * @notice sets the fee basis points\n     * @param _feeBasisPoints\n     **/\n    function setFeeBasisPoints(uint _feeBasisPoints) public onlyOwner {\n        require(_feeBasisPoints >= 0 && _feeBasisPoints <= 9500, \"Invalid flat fee\");\n        feeBasisPoints = _feeBasisPoints;\n        emit FeeSet(_feeBasisPoints);\n    }\n\n    /**\n     * @notice returns the flat fee\n     * @return current rate\n     **/\n    function currentRate(uint) external view returns (uint) {\n        return feeBasisPoints;\n    }\n}\n"
    },
    "contracts/core/GovernanceController.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title Governance Controller\n * @notice Proxies owners functions for all contracts and handles RBAC\n */\ncontract GovernanceController is Ownable {\n    struct Role {\n        string name;\n        mapping(address => bool) members;\n        mapping(bytes32 => bool) functions;\n    }\n\n    Role[] private roles;\n\n    event CallFunction(address indexed sender, address indexed contractAddress);\n    event AddRole(uint indexed roleId, string name, address[] members, address[] contracts, bytes4[][] functionSelectors);\n    event GrantRole(uint indexed roleId, address indexed account);\n    event RevokeRole(uint indexed roleId, address indexed account);\n    event AddRoleFunctions(uint indexed roleId, address[] contracts, bytes4[][] functionSelectors);\n    event RemoveRoleFunctions(uint indexed roleId, address[] contracts, bytes4[][] functionSelectors);\n\n    modifier roleExists(uint _roleId) {\n        require(_roleId < roles.length, \"Role does not exist\");\n        _;\n    }\n\n    /**\n     * @notice returns a list of all role names\n     * @return roleNames list of all roles names\n     **/\n    function getRoles() external view returns (string[] memory roleNames) {\n        roleNames = new string[](roles.length);\n        for (uint i = 0; i < roles.length; i++) {\n            roleNames[i] = roles[i].name;\n        }\n    }\n\n    /**\n     * @notice returns whether an account holds a role\n     * @param _roleId id of role\n     * @param _account address of account\n     * @return hasRole whether or not account holds tole\n     **/\n    function hasRole(uint _roleId, address _account) external view returns (bool) {\n        return roles[_roleId].members[_account];\n    }\n\n    /**\n     * @notice returns whether a role is authorized to call a function\n     * @param _roleId id of role\n     * @param _contract address of contract that function belongs to\n     * @param _functionSelector function selector to check\n     * @return isAuthorized whether or not role is authorized to call function\n     **/\n    function hasFunction(\n        uint _roleId,\n        address _contract,\n        bytes4 _functionSelector\n    ) external view returns (bool) {\n        return roles[_roleId].functions[_getFunctionId(_contract, _functionSelector)];\n    }\n\n    /**\n     * @notice executes a function call if sender is authorized\n     * @param _roleId id of sender's role\n     * @param _contract contract address to call\n     * @param _encodedCalldata encoded function call\n     **/\n    function callFunction(\n        uint _roleId,\n        address _contract,\n        bytes calldata _encodedCalldata\n    ) external roleExists(_roleId) {\n        require(roles[_roleId].members[msg.sender], \"Sender does not hold specified role\");\n\n        bytes4 functionSelector = bytes4(_encodedCalldata[0:4]);\n        require(\n            roles[_roleId].functions[_getFunctionId(_contract, functionSelector)],\n            \"Role is not authorized to call specified function\"\n        );\n\n        (bool status, bytes memory ret) = _contract.call(_encodedCalldata);\n        require(status, string(ret));\n\n        emit CallFunction(msg.sender, _contract);\n    }\n\n    /**\n     * @notice adds a new role\n     * @param _name name of role\n     * @param _members list of accounts to grant this role to\n     * @param _contracts list of contract addresses this role will govern\n     * @param _functionSelectors list of function selectors for each contract this role will govern\n     **/\n    function addRole(\n        string calldata _name,\n        address[] calldata _members,\n        address[] calldata _contracts,\n        bytes4[][] calldata _functionSelectors\n    ) external onlyOwner {\n        Role storage role = roles.push();\n        role.name = _name;\n\n        for (uint i = 0; i < _members.length; i++) {\n            role.members[_members[i]] = true;\n        }\n\n        for (uint i = 0; i < _contracts.length; i++) {\n            address contractAddress = _contracts[i];\n            for (uint j = 0; j < _functionSelectors[i].length; j++) {\n                role.functions[_getFunctionId(contractAddress, _functionSelectors[i][j])] = true;\n            }\n        }\n\n        emit AddRole(roles.length - 1, _name, _members, _contracts, _functionSelectors);\n    }\n\n    /**\n     * @notice grants a role to an account\n     * @param _roleId id of role to grant\n     * @param _account address to grant role to\n     **/\n    function grantRole(uint _roleId, address _account) external onlyOwner roleExists(_roleId) {\n        require(!roles[_roleId].members[_account], \"Account already holds role\");\n        roles[_roleId].members[_account] = true;\n        emit GrantRole(_roleId, _account);\n    }\n\n    /**\n     * @notice revokes a role from an account\n     * @param _roleId id of role to revoke\n     * @param _account address to revoke role from\n     **/\n    function revokeRole(uint _roleId, address _account) external onlyOwner roleExists(_roleId) {\n        _revokeRole(_roleId, _account);\n    }\n\n    /**\n     * @notice renounces a role from the sender\n     * @param _roleId id of role to renounce\n     **/\n    function renounceRole(uint _roleId) external roleExists(_roleId) {\n        _revokeRole(_roleId, msg.sender);\n    }\n\n    /**\n     * @notice adds functions to a role\n     * @param _roleId id of role\n     * @param _contracts list of contract addresses the functions belong to\n     * @param _functionSelectors list of function selectors to add for each contract\n     **/\n    function addRoleFunctions(\n        uint _roleId,\n        address[] calldata _contracts,\n        bytes4[][] calldata _functionSelectors\n    ) external onlyOwner roleExists(_roleId) {\n        for (uint i = 0; i < _contracts.length; i++) {\n            address contractAddress = _contracts[i];\n\n            for (uint j = 0; j < _functionSelectors[i].length; j++) {\n                bytes32 functionId = _getFunctionId(contractAddress, _functionSelectors[i][j]);\n                require(!roles[_roleId].functions[functionId], \"Function is already part of role\");\n                roles[_roleId].functions[functionId] = true;\n            }\n        }\n\n        emit AddRoleFunctions(_roleId, _contracts, _functionSelectors);\n    }\n\n    /**\n     * @notice removes functions from a role\n     * @param _roleId id of role\n     * @param _contracts list of contract addresses the functions belong to\n     * @param _functionSelectors list of function selectors to remove for each contract\n     **/\n    function removeRoleFunctions(\n        uint _roleId,\n        address[] calldata _contracts,\n        bytes4[][] calldata _functionSelectors\n    ) external onlyOwner roleExists(_roleId) {\n        for (uint i = 0; i < _contracts.length; i++) {\n            address contractAddress = _contracts[i];\n\n            for (uint j = 0; j < _functionSelectors[i].length; j++) {\n                bytes32 functionId = _getFunctionId(contractAddress, _functionSelectors[i][j]);\n                require(roles[_roleId].functions[functionId], \"Function is not part of role\");\n                roles[_roleId].functions[functionId] = false;\n            }\n        }\n\n        emit RemoveRoleFunctions(_roleId, _contracts, _functionSelectors);\n    }\n\n    /**\n     * @notice revokes a role from an account\n     * @param _roleId id of role to revoke\n     * @param _account address to revoke role from\n     **/\n    function _revokeRole(uint _roleId, address _account) private {\n        require(roles[_roleId].members[_account], \"Account does not hold role\");\n        roles[_roleId].members[_account] = false;\n        emit RevokeRole(_roleId, _account);\n    }\n\n    /**\n     * @notice returns a function id\n     * @param _contract address of contract that function belongs to\n     * @param _functionSelector function selector\n     * @return functionId id of function\n     **/\n    function _getFunctionId(address _contract, bytes4 _functionSelector) private pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_contract, _functionSelector));\n    }\n}\n"
    },
    "contracts/linkStaking/OperatorVault.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"./base/Vault.sol\";\n\n/**\n * @title Operator Vault\n * @notice Vault contract for depositing LINK collateral into the Chainlink staking controller as an operator\n */\ncontract OperatorVault is Vault {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    address public operator;\n\n    event AlertRaised();\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address _token,\n        address _vaultController,\n        address _stakeController,\n        address _operator\n    ) public initializer {\n        __Vault_init(_token, _vaultController, _stakeController);\n        operator = _operator;\n    }\n\n    modifier onlyOperator() {\n        require(operator == msg.sender, \"Operator only\");\n        _;\n    }\n\n    /**\n     * @notice returns the total balance of this contract in the Chainlink staking contract\n     * @return balance total balance\n     */\n    function getTotalDeposits() public view override returns (uint) {\n        return\n            stakeController.getStake(address(this)) +\n            stakeController.getBaseReward(address(this)) +\n            stakeController.getDelegationReward(address(this));\n    }\n\n    /**\n     * @notice raises an alert in the stake controller\n     */\n    function raiseAlert() external onlyOperator {\n        stakeController.raiseAlert();\n        token.safeTransfer(vaultController, token.balanceOf(address(this)));\n        emit AlertRaised();\n    }\n\n    /**\n     * @notice sets the operator that this vault represents if not already set\n     * @param _operator address of operator\n     */\n    function setOperator(address _operator) external onlyOwner {\n        require(operator == address(0), \"Operator is already set\");\n        operator = _operator;\n    }\n}\n"
    },
    "contracts/linkStaking/test/OperatorVaultV2Mock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"../OperatorVault.sol\";\n\n/**\n * @title Operator Vault V2 Mock\n * @notice Mocks contract for testing\n */\ncontract OperatorVaultV2Mock is OperatorVault {\n    uint public version;\n\n    function initializeV2(uint _version) public reinitializer(2) {\n        version = _version;\n    }\n\n    function isUpgraded() external view returns (bool) {\n        return true;\n    }\n\n    function getVersion() external view returns (uint) {\n        return version;\n    }\n}\n"
    },
    "contracts/linkStaking/CommunityVault.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"./base/Vault.sol\";\n\n/**\n * @title Community Vault\n * @notice Vault contract for depositing LINK collateral into the Chainlink staking controller as a community staker\n */\ncontract CommunityVault is Vault {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address _token,\n        address _vaultController,\n        address _stakeController\n    ) public initializer {\n        __Vault_init(_token, _vaultController, _stakeController);\n    }\n\n    /**\n     * @notice returns the total balance of this contract in the Chainlink staking contract\n     * @return balance total balance\n     */\n    function getTotalDeposits() public view override returns (uint) {\n        return stakeController.getStake(address(this)) + stakeController.getBaseReward(address(this));\n    }\n}\n"
    },
    "contracts/linkStaking/OperatorVCS.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"./base/VaultControllerStrategy.sol\";\n\n/**\n * @title Operator Vault Controller Strategy\n * @notice Implemented strategy for managing multiple Chainlink operator staking vaults\n */\ncontract OperatorVCS is VaultControllerStrategy {\n    uint private totalPrincipalDeposits;\n\n    event VaultAdded(address indexed operator);\n    event DepositBufferedTokens(uint depositedAmount);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address _token,\n        address _stakingPool,\n        address _stakeController,\n        address _vaultImplementation,\n        uint _minDepositThreshold,\n        Fee[] memory _fees,\n        address[] calldata _initialVaults\n    ) public initializer {\n        __VaultControllerStrategy_init(\n            _token,\n            _stakingPool,\n            _stakeController,\n            _vaultImplementation,\n            _minDepositThreshold,\n            _fees\n        );\n        for (uint i = 0; i < _initialVaults.length; i++) {\n            address vault = _initialVaults[i];\n            vaults.push(IVault(vault));\n            token.approve(vault, type(uint256).max);\n        }\n    }\n\n    /**\n     * @notice returns the maximum that can be deposited into this strategy\n     * @return max deposit\n     */\n    function getMaxDeposits() public view override returns (uint) {\n        (, uint vaultMaxDeposits) = getVaultDepositLimits();\n        return totalDeposits + vaultMaxDeposits * vaults.length - (totalPrincipalDeposits + bufferedDeposits);\n    }\n\n    /**\n     * @notice returns the minimum that must remain this strategy\n     * @return min deposit\n     */\n    function getMinDeposits() public view override returns (uint) {\n        return totalDeposits;\n    }\n\n    /**\n     * @notice returns the vault deposit limits\n     * @return minimum minimum amount of deposits that a vault can hold\n     * @return maximum maximum amount of deposits that a vault can hold\n     */\n    function getVaultDepositLimits() public view override returns (uint, uint) {\n        return stakeController.getOperatorLimits();\n    }\n\n    /**\n     * @notice deploys a new vault\n     * @param _operator address of operator that the vault represents\n     */\n    function addVault(address _operator) external onlyOwner {\n        bytes memory data = abi.encodeWithSignature(\n            \"initialize(address,address,address,address)\",\n            address(token),\n            address(this),\n            address(stakeController),\n            _operator\n        );\n        _deployVault(data);\n        emit VaultAdded(_operator);\n    }\n\n    /**\n     * @notice deposits buffered tokens into vaults\n     * @param _startIndex index of first vault to deposit into\n     * @param _toDeposit amount to deposit\n     * @param _vaultMinDeposits minimum amount of deposits that a vault can hold\n     * @param _vaultMaxDeposits minimum amount of deposits that a vault can hold\n     */\n    function _depositBufferedTokens(\n        uint _startIndex,\n        uint _toDeposit,\n        uint _vaultMinDeposits,\n        uint _vaultMaxDeposits\n    ) internal override {\n        uint deposited = _depositToVaults(_startIndex, _toDeposit, _vaultMinDeposits, _vaultMaxDeposits);\n        totalPrincipalDeposits += deposited;\n        bufferedDeposits -= deposited;\n        emit DepositBufferedTokens(deposited);\n    }\n}\n"
    },
    "contracts/linkStaking/CommunityVCS.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport \"./base/VaultControllerStrategy.sol\";\n\n/**\n * @title Community Vault Controller Strategy\n * @notice Implemented strategy for managing multiple Chainlink community staking vaults\n */\ncontract CommunityVCS is VaultControllerStrategy {\n    uint private maxDeposits;\n    uint public maxVaultDeployments;\n\n    event SetMaxDeposits(uint maxDeposits);\n    event SetMaxVaultDeployments(uint maxVaultDeployments);\n    event DepositBufferedTokens(uint amountDeposited, uint vaultsDeployed);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address _token,\n        address _stakingPool,\n        address _stakeController,\n        address _vaultImplementation,\n        uint _minDepositThreshold,\n        Fee[] memory _fees,\n        uint _maxDeposits,\n        uint _maxVaultDeployments\n    ) public initializer {\n        __VaultControllerStrategy_init(\n            _token,\n            _stakingPool,\n            _stakeController,\n            _vaultImplementation,\n            _minDepositThreshold,\n            _fees\n        );\n        maxDeposits = _maxDeposits;\n        maxVaultDeployments = _maxVaultDeployments;\n        _deployVaults(1);\n    }\n\n    /**\n     * @notice returns the maximum that can be deposited into this strategy\n     * @return max deposit\n     */\n    function getMaxDeposits() public view override returns (uint) {\n        return maxDeposits;\n    }\n\n    /**\n     * @notice returns the minimum that must remain this strategy\n     * @return min deposit\n     */\n    function getMinDeposits() public view override returns (uint) {\n        return totalDeposits;\n    }\n\n    /**\n     * @notice returns the vault deposit limits\n     * @return minimum minimum amount of deposits that a vault can hold\n     * @return maximum maximum amount of deposits that a vault can hold\n     */\n    function getVaultDepositLimits() public view override returns (uint, uint) {\n        return stakeController.getCommunityStakerLimits();\n    }\n\n    /**\n     * @notice sets the maximum that can be deposited into this strategy\n     * @param _maxDeposits maximum amount\n     */\n    function setMaxDeposits(uint _maxDeposits) external onlyOwner {\n        maxDeposits = _maxDeposits;\n        emit SetMaxDeposits(_maxDeposits);\n    }\n\n    /**\n     * @notice sets the maximum number of vaults that can be deployed at once\n     * @param _maxVaultDeployments maximum amount\n     */\n    function setMaxVaultDeployments(uint _maxVaultDeployments) external onlyOwner {\n        maxVaultDeployments = _maxVaultDeployments;\n        emit SetMaxVaultDeployments(_maxVaultDeployments);\n    }\n\n    /**\n     * @notice deposits buffered tokens into vaults\n     * @param _startIndex index of first vault to deposit into\n     * @param _toDeposit amount to deposit\n     * @param _vaultMinDeposits minimum amount of deposits that a vault can hold\n     * @param _vaultMaxDeposits minimum amount of deposits that a vault can hold\n     */\n    function _depositBufferedTokens(\n        uint _startIndex,\n        uint _toDeposit,\n        uint _vaultMinDeposits,\n        uint _vaultMaxDeposits\n    ) internal override {\n        uint deposited = _depositToVaults(_startIndex, _toDeposit, _vaultMinDeposits, _vaultMaxDeposits);\n        require(\n            deposited >= minDepositThreshold || vaults[vaults.length - 1].getPrincipalDeposits() >= _vaultMaxDeposits,\n            \"Invalid deposit\"\n        );\n\n        uint toDepositRemaining = _toDeposit - deposited;\n        uint vaultsToDeploy = toDepositRemaining / _vaultMaxDeposits;\n        if (toDepositRemaining % _vaultMaxDeposits >= _vaultMinDeposits) {\n            vaultsToDeploy += 1;\n        }\n\n        if (vaultsToDeploy > 0) {\n            if (vaultsToDeploy > maxVaultDeployments) {\n                vaultsToDeploy = maxVaultDeployments;\n            }\n            _deployVaults(vaultsToDeploy);\n            deposited += _depositToVaults(\n                vaults.length - vaultsToDeploy,\n                toDepositRemaining,\n                _vaultMinDeposits,\n                _vaultMaxDeposits\n            );\n        }\n\n        bufferedDeposits -= deposited;\n        emit DepositBufferedTokens(deposited, vaultsToDeploy);\n    }\n\n    /**\n     * @notice deploys new vaults\n     * @param _numVaults number of vaults to deploy\n     */\n    function _deployVaults(uint _numVaults) internal {\n        bytes memory data = abi.encodeWithSignature(\n            \"initialize(address,address,address)\",\n            address(token),\n            address(this),\n            address(stakeController)\n        );\n        for (uint i = 0; i < _numVaults; i++) {\n            _deployVault(data);\n        }\n    }\n}\n"
    },
    "contracts/core/test/LendingPoolMock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\n/**\n * @title Delegator Pool Mock\n * @notice Mocks contract for testing\n */\ncontract DelegatorPoolMock {\n    address public token;\n    uint16 public index;\n    uint public totalRewards;\n    uint public rate;\n\n    constructor(\n        address _token,\n        uint16 _index,\n        uint _rate\n    ) {\n        token = _token;\n        index = _index;\n        rate = _rate;\n    }\n\n    function onTokenTransfer(\n        address _sender,\n        uint _value,\n        bytes calldata _calldata\n    ) external {\n        totalRewards += _value;\n    }\n\n    function currentRate(address _token, uint16 _index) public view returns (uint) {\n        if (_token != token || _index != index) {\n            return 0;\n        }\n        return rate;\n    }\n}\n"
    },
    "contracts/core/test/Multicall3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/// @title Multicall3\n/// @notice Aggregate results from multiple function calls\n/// @dev Multicall & Multicall2 backwards-compatible\n/// @dev Aggregate methods are marked `payable` to save 24 gas per call\n/// @author Michael Elliot <mike@makerdao.com>\n/// @author Joshua Levine <joshua@makerdao.com>\n/// @author Nick Johnson <arachnid@notdot.net>\n/// @author Andreas Bigger <andreas@nascent.xyz>\n/// @author Matt Solomon <matt@mattsolomon.dev>\ncontract Multicall3 {\n    struct Call {\n        address target;\n        bytes callData;\n    }\n\n    struct Call3 {\n        address target;\n        bool allowFailure;\n        bytes callData;\n    }\n\n    struct Call3Value {\n        address target;\n        bool allowFailure;\n        uint256 value;\n        bytes callData;\n    }\n\n    struct Result {\n        bool success;\n        bytes returnData;\n    }\n\n    /// @notice Backwards-compatible call aggregation with Multicall\n    /// @param calls An array of Call structs\n    /// @return blockNumber The block number where the calls were executed\n    /// @return returnData An array of bytes containing the responses\n    function aggregate(Call[] calldata calls) public payable returns (uint256 blockNumber, bytes[] memory returnData) {\n        blockNumber = block.number;\n        uint256 length = calls.length;\n        returnData = new bytes[](length);\n        Call calldata call;\n        for (uint256 i = 0; i < length; ) {\n            bool success;\n            call = calls[i];\n            (success, returnData[i]) = call.target.call(call.callData);\n            require(success, \"Multicall3: call failed\");\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Backwards-compatible with Multicall2\n    /// @notice Aggregate calls without requiring success\n    /// @param requireSuccess If true, require all calls to succeed\n    /// @param calls An array of Call structs\n    /// @return returnData An array of Result structs\n    function tryAggregate(bool requireSuccess, Call[] calldata calls) public payable returns (Result[] memory returnData) {\n        uint256 length = calls.length;\n        returnData = new Result[](length);\n        Call calldata call;\n        for (uint256 i = 0; i < length; ) {\n            Result memory result = returnData[i];\n            call = calls[i];\n            (result.success, result.returnData) = call.target.call(call.callData);\n            if (requireSuccess) require(result.success, \"Multicall3: call failed\");\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Backwards-compatible with Multicall2\n    /// @notice Aggregate calls and allow failures using tryAggregate\n    /// @param calls An array of Call structs\n    /// @return blockNumber The block number where the calls were executed\n    /// @return blockHash The hash of the block where the calls were executed\n    /// @return returnData An array of Result structs\n    function tryBlockAndAggregate(bool requireSuccess, Call[] calldata calls)\n        public\n        payable\n        returns (\n            uint256 blockNumber,\n            bytes32 blockHash,\n            Result[] memory returnData\n        )\n    {\n        blockNumber = block.number;\n        blockHash = blockhash(block.number);\n        returnData = tryAggregate(requireSuccess, calls);\n    }\n\n    /// @notice Backwards-compatible with Multicall2\n    /// @notice Aggregate calls and allow failures using tryAggregate\n    /// @param calls An array of Call structs\n    /// @return blockNumber The block number where the calls were executed\n    /// @return blockHash The hash of the block where the calls were executed\n    /// @return returnData An array of Result structs\n    function blockAndAggregate(Call[] calldata calls)\n        public\n        payable\n        returns (\n            uint256 blockNumber,\n            bytes32 blockHash,\n            Result[] memory returnData\n        )\n    {\n        (blockNumber, blockHash, returnData) = tryBlockAndAggregate(true, calls);\n    }\n\n    /// @notice Aggregate calls, ensuring each returns success if required\n    /// @param calls An array of Call3 structs\n    /// @return returnData An array of Result structs\n    function aggregate3(Call3[] calldata calls) public payable returns (Result[] memory returnData) {\n        uint256 length = calls.length;\n        returnData = new Result[](length);\n        Call3 calldata calli;\n        for (uint256 i = 0; i < length; ) {\n            Result memory result = returnData[i];\n            calli = calls[i];\n            (result.success, result.returnData) = calli.target.call(calli.callData);\n            assembly {\n                // Revert if the call fails and failure is not allowed\n                // `allowFailure := calldataload(add(calli, 0x20))` and `success := mload(result)`\n                if iszero(or(calldataload(add(calli, 0x20)), mload(result))) {\n                    // set \"Error(string)\" signature: bytes32(bytes4(keccak256(\"Error(string)\")))\n                    mstore(0x00, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n                    // set data offset\n                    mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\n                    // set length of revert string\n                    mstore(0x24, 0x0000000000000000000000000000000000000000000000000000000000000017)\n                    // set revert string: bytes32(abi.encodePacked(\"Multicall3: call failed\"))\n                    mstore(0x44, 0x4d756c746963616c6c333a2063616c6c206661696c6564000000000000000000)\n                    revert(0x00, 0x64)\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Aggregate calls with a msg value\n    /// @notice Reverts if msg.value is less than the sum of the call values\n    /// @param calls An array of Call3Value structs\n    /// @return returnData An array of Result structs\n    function aggregate3Value(Call3Value[] calldata calls) public payable returns (Result[] memory returnData) {\n        uint256 valAccumulator;\n        uint256 length = calls.length;\n        returnData = new Result[](length);\n        Call3Value calldata calli;\n        for (uint256 i = 0; i < length; ) {\n            Result memory result = returnData[i];\n            calli = calls[i];\n            uint256 val = calli.value;\n            // Humanity will be a Type V Kardashev Civilization before this overflows - andreas\n            // ~ 10^25 Wei in existence << ~ 10^76 size uint fits in a uint256\n            unchecked {\n                valAccumulator += val;\n            }\n            (result.success, result.returnData) = calli.target.call{value: val}(calli.callData);\n            assembly {\n                // Revert if the call fails and failure is not allowed\n                // `allowFailure := calldataload(add(calli, 0x20))` and `success := mload(result)`\n                if iszero(or(calldataload(add(calli, 0x20)), mload(result))) {\n                    // set \"Error(string)\" signature: bytes32(bytes4(keccak256(\"Error(string)\")))\n                    mstore(0x00, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n                    // set data offset\n                    mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\n                    // set length of revert string\n                    mstore(0x24, 0x0000000000000000000000000000000000000000000000000000000000000017)\n                    // set revert string: bytes32(abi.encodePacked(\"Multicall3: call failed\"))\n                    mstore(0x44, 0x4d756c746963616c6c333a2063616c6c206661696c6564000000000000000000)\n                    revert(0x00, 0x84)\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        // Finally, make sure the msg.value = SUM(call[0...i].value)\n        require(msg.value == valAccumulator, \"Multicall3: value mismatch\");\n    }\n\n    /// @notice Returns the block hash for the given block number\n    /// @param blockNumber The block number\n    function getBlockHash(uint256 blockNumber) public view returns (bytes32 blockHash) {\n        blockHash = blockhash(blockNumber);\n    }\n\n    /// @notice Returns the block number\n    function getBlockNumber() public view returns (uint256 blockNumber) {\n        blockNumber = block.number;\n    }\n\n    /// @notice Returns the block coinbase\n    function getCurrentBlockCoinbase() public view returns (address coinbase) {\n        coinbase = block.coinbase;\n    }\n\n    /// @notice Returns the block difficulty\n    function getCurrentBlockDifficulty() public view returns (uint256 difficulty) {\n        difficulty = block.difficulty;\n    }\n\n    /// @notice Returns the block gas limit\n    function getCurrentBlockGasLimit() public view returns (uint256 gaslimit) {\n        gaslimit = block.gaslimit;\n    }\n\n    /// @notice Returns the block timestamp\n    function getCurrentBlockTimestamp() public view returns (uint256 timestamp) {\n        timestamp = block.timestamp;\n    }\n\n    /// @notice Returns the (ETH) balance of a given address\n    function getEthBalance(address addr) public view returns (uint256 balance) {\n        balance = addr.balance;\n    }\n\n    /// @notice Returns the block hash of the last block\n    function getLastBlockHash() public view returns (bytes32 blockHash) {\n        unchecked {\n            blockHash = blockhash(block.number - 1);\n        }\n    }\n\n    /// @notice Gets the base fee of the given block\n    /// @notice Can revert if the BASEFEE opcode is not implemented by the given chain\n    function getBasefee() public view returns (uint256 basefee) {\n        basefee = block.basefee;\n    }\n\n    /// @notice Returns the chain id\n    function getChainId() public view returns (uint256 chainid) {\n        chainid = block.chainid;\n    }\n}\n"
    },
    "contracts/ethStaking/test/OperatorWhitelistMock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\ncontract OperatorWhitelistMock {\n    struct WhitelistEntry {\n        bool isWhitelisted;\n        bool isUsed;\n    }\n\n    mapping(address => WhitelistEntry) private whitelist;\n\n    constructor(address[] memory _whitelist) {\n        for (uint i = 0; i < _whitelist.length; i++) {\n            whitelist[_whitelist[i]] = WhitelistEntry(true, false);\n        }\n    }\n\n    function useWhitelist(address _operator) external view {\n        require(whitelist[_operator].isWhitelisted, \"Operator is not whitelisted\");\n        //require(!whitelist[_operator].isUsed, \"Operator whitelist spot already used\");\n        //whitelist[_operator].isUsed = true;\n    }\n\n    function getWhitelistEntry(address _operator) external view returns (WhitelistEntry memory) {\n        return whitelist[_operator];\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}